{
    "version": "https://jsonfeed.org/version/1",
    "title": "陆时忤的博客 • All posts by \"spring\" tag",
    "description": "要再见 不要再见",
    "home_page_url": "https://blog.aixcc.top",
    "items": [
        {
            "id": "https://blog.aixcc.top/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "Spring应用与总结",
            "date_published": "2024-06-22T10:11:04.000Z",
            "content_html": "<h2 id=\"Spring-常见面试题总结\"><a class=\"headerlink\" href=\"#Spring-常见面试题总结\"></a>Spring 常见面试题总结</h2>\n<h3 id=\"什么是Spring框架？\"><a class=\"headerlink\" href=\"#什么是Spring框架？\"></a>什么是Spring框架？</h3>\n<p>Spring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。</p>\n<h3 id=\"谈谈自己对于Spring-IoC的了解\"><a class=\"headerlink\" href=\"#谈谈自己对于Spring-IoC的了解\"></a>谈谈自己对于Spring IoC的了解</h3>\n<p><strong>IoC</strong> （Inversion of Control 控制反转）是一种设计模式，用来实现对象之间的解耦。</p>\n<p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。</p>\n<h4 id=\"为什么叫控制反转？\"><a class=\"headerlink\" href=\"#为什么叫控制反转？\"></a>为什么叫控制反转？</h4>\n<ul>\n<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权利</li>\n<li><strong>反转</strong>：控制权交给外部环境（Spring框架、IoC容器）</li>\n</ul>\n<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。</p>\n<h3 id=\"什么是-Bean？\"><a class=\"headerlink\" href=\"#什么是-Bean？\"></a>什么是 Bean？</h3>\n<p>Bean 就是哪些被 IoC 容器所管理的对象。</p>\n<h3 id=\"Component和-Bean的区别是什么？\"><a class=\"headerlink\" href=\"#Component和-Bean的区别是什么？\"></a>@Component和@Bean的区别是什么？</h3>\n<ul>\n<li>@Component 注解用于类，@Bean 注解用于方法。</li>\n<li>@Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。</li>\n<li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。</li>\n</ul>\n<h3 id=\"注入Bean的注解有哪些？\"><a class=\"headerlink\" href=\"#注入Bean的注解有哪些？\"></a>注入Bean的注解有哪些？</h3>\n<p>Spring 内置的<code>@Autowired</code> 还有 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>\n<h3 id=\"Autowired和-Resource的区别是什么？\"><a class=\"headerlink\" href=\"#Autowired和-Resource的区别是什么？\"></a>@Autowired和@Resource的区别是什么？</h3>\n<ul>\n<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>\n<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>\n<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code> 都需要通过名称才能正确匹配到对应的  Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code> 可以通过 name 属性来显式指定名称。</li>\n<li>@Autowired 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li>\n</ul>\n<h3 id=\"Bean-的作用域有哪些\"><a class=\"headerlink\" href=\"#Bean-的作用域有哪些\"></a>Bean 的作用域有哪些?</h3>\n<ul>\n<li><strong>Singleton</strong> Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。</li>\n<li><strong>prototype</strong>  每次请求都会创建一个新的 bean 实例。</li>\n<li><strong>Request</strong> 每次 Http 请求都会创建一个新的 bean 实例。</li>\n<li><strong>Session</strong> 每个 Http Session 中会有一个 bean 实例。</li>\n</ul>\n<h3 id=\"Bean-是线程安全的吗？\"><a class=\"headerlink\" href=\"#Bean-是线程安全的吗？\"></a>Bean 是线程安全的吗？</h3>\n<p>在 Spring 中 Bean 是否安全，取决于其作用域和状态。</p>\n<p>单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。</p>\n<h3 id=\"Bean的生命周期了解么？\"><a class=\"headerlink\" href=\"#Bean的生命周期了解么？\"></a>Bean的生命周期了解么？</h3>\n<p>bean 的生命周期分为五个阶段：</p>\n<ol>\n<li>调用构造器或者是通过工厂的方式创建 bean</li>\n<li>给 bean 的属性注入值</li>\n<li>调用初始化方法，进行初始化</li>\n<li>bean 被完全初始化和配置，就可以使用了</li>\n<li>当 IOC 容器关闭的时候，销毁 bean</li>\n</ol>\n<h3 id=\"谈谈对于AOP的了解\"><a class=\"headerlink\" href=\"#谈谈对于AOP的了解\"></a>谈谈对于AOP的了解</h3>\n<p>AOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。</p>\n<p>Spring AOP 是通过动态代理来实现切面功能，<strong>JDK动态代理</strong>：用于代理实现了接口的类。<strong>CGLIB代理</strong>：用于代理没有实现接口的类，通过生成目标类的子类来实现。</p>\n<h3 id=\"Spring-AOP-和-AspectJ-AOP-有什么区别？\"><a class=\"headerlink\" href=\"#Spring-AOP-和-AspectJ-AOP-有什么区别？\"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3>\n<p>Spring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。</p>\n<h3 id=\"AspectJ-定义的通知类型有哪些？\"><a class=\"headerlink\" href=\"#AspectJ-定义的通知类型有哪些？\"></a>AspectJ 定义的通知类型有哪些？</h3>\n<ul>\n<li>\n<p><strong>Before</strong>（前置通知）：在方法执行之前运行。</p>\n</li>\n<li>\n<p><strong>After</strong>（后置通知）：在方法执行之后运行，无论方法是否成功完成。</p>\n</li>\n<li>\n<p><strong>AfterReturning</strong>（返回通知）：在方法成功完成后运行。</p>\n</li>\n<li>\n<p><strong>AfterThorowing</strong>（异常通知）：在方法抛出异常后运行。</p>\n</li>\n<li>\n<p><strong>Around</strong>（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。</p>\n</li>\n</ul>\n<h3 id=\"多个切面执行顺序如何控制？\"><a class=\"headerlink\" href=\"#多个切面执行顺序如何控制？\"></a>多个切面执行顺序如何控制？</h3>\n<ol>\n<li>通常使用<code>@Order</code> 注解直接定义切面顺序</li>\n<li>实现<code>Ordered</code>接口重写<code>getOrder</code>方法</li>\n</ol>\n<h3 id=\"说说自己对于-Spring-MVC-了解？\"><a class=\"headerlink\" href=\"#说说自己对于-Spring-MVC-了解？\"></a>说说自己对于 Spring MVC 了解？</h3>\n<p>SpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。</p>\n<h3 id=\"SpringMVC-的工作流程是什么？\"><a class=\"headerlink\" href=\"#SpringMVC-的工作流程是什么？\"></a>SpringMVC 的工作流程是什么？</h3>\n<ol>\n<li>客户端请求首先到达<code>DispatcherServlet</code>。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerMapping</code>找到具体的处理器（Controller）。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerAdapter</code>调用处理器中的具体方法。</li>\n<li>处理器方法执行完毕后返回<code>ModelAndView</code>对象，包含视图名称和模型数据。</li>\n<li><code>DispatcherServlet</code>使用<code>ViewResolver</code>将视图名称解析为具体的视图。</li>\n<li>最后，<code>DispatcherServlet</code>将模型数据传递给视图，视图渲染并返回响应给客户端。</li>\n</ol>\n<p>客户端发送请求 -&gt; 2. DispatcherServlet接收请求 -&gt; 3. HandlerMapping查找控制器 -&gt; 4. HandlerAdapter调用控制器方法 -&gt; 5. Controller处理请求 -&gt; 6. ViewResolver解析视图 -&gt; 7. 视图渲染 -&gt; 8. 返回响应给客户端</p>\n<h3 id=\"统一异常处理怎么做？\"><a class=\"headerlink\" href=\"#统一异常处理怎么做？\"></a>统一异常处理怎么做？</h3>\n<p>使用注解的方式统一异常处理，使用<code>@controllerAdvice</code>和<code>@ExceptionHandler</code>这两个注解。</p>\n<h3 id=\"Spring-中用到了哪些设计模式？\"><a class=\"headerlink\" href=\"#Spring-中用到了哪些设计模式？\"></a>Spring 中用到了哪些设计模式？</h3>\n<ul>\n<li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过<code>BeanFactory</code>、<code>ApplicationContext</code>创建 bean 对象。</li>\n<li><strong>代理设计模式</strong>：SpringAOP 功能实现。</li>\n<li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li>\n<li><strong>模版方法模式</strong>：Spring 中<code>jdbcTemplate</code>、<code>hibernateTemplate</code>等以 Template 结尾的对数据库操作的类，都使用到了模版模式。</li>\n<li><strong>包装器设计模式</strong>：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。</li>\n<li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式。</li>\n<li><strong>适配器模式</strong>：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配<code>Controller</code>。</li>\n</ul>\n<h3 id=\"Spring-循环依赖了解吗，怎么解决？\"><a class=\"headerlink\" href=\"#Spring-循环依赖了解吗，怎么解决？\"></a>Spring 循环依赖了解吗，怎么解决？</h3>\n<p>Spring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。</p>\n<h4 id=\"使用-setter-注入\"><a class=\"headerlink\" href=\"#使用-setter-注入\"></a>使用 setter 注入</h4>\n<p>Spring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。</p>\n<h4 id=\"使用-Lazy-注解\"><a class=\"headerlink\" href=\"#使用-Lazy-注解\"></a>使用 @Lazy 注解</h4>\n<p>在其中一个 Bean 的依赖上使用<code>@Lazy</code>注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。</p>\n<h3 id=\"Spring-管理事务的方式有几种？\"><a class=\"headerlink\" href=\"#Spring-管理事务的方式有几种？\"></a>Spring 管理事务的方式有几种？</h3>\n<ul>\n<li><strong>编程式事务</strong>：在代码中硬编码（在分布式系统中推荐使用）：通过<code>TranscationTemplate</code>或者<code>TransactionManager</code>在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li>\n<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于<code>@Transcational</code>的全注解方式使用最多）</li>\n</ul>\n<h3 id=\"Srping事务中哪几种事务传播行为？\"><a class=\"headerlink\" href=\"#Srping事务中哪几种事务传播行为？\"></a>Srping事务中哪几种事务传播行为？</h3>\n<blockquote>\n<p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p>\n<p>当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。</p>\n<p>例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。</p>\n</blockquote>\n<ol>\n<li><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。</li>\n</ol>\n<h3 id=\"什么是-SpringBoot？为什么要有-SpringBoot？\"><a class=\"headerlink\" href=\"#什么是-SpringBoot？为什么要有-SpringBoot？\"></a>什么是 SpringBoot？为什么要有 SpringBoot？</h3>\n<p>SpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）</p>\n<h3 id=\"如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"><a class=\"headerlink\" href=\"#如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"></a>如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？</h3>\n<p>SpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。</p>\n<h3 id=\"介绍一下-SpringBootApplication-注解\"><a class=\"headerlink\" href=\"#介绍一下-SpringBootApplication-注解\"></a>介绍一下 @SpringBootApplication 注解</h3>\n<p><code>@SpringBootApplication</code>可以看作是<code>@Configuration、@EnableAutoConfiguration、@ComponentScan</code>注解的集合。</p>\n<ul>\n<li><code>@Configuration</code>：运行在上下文中注册额外的<code>bean</code>或导入其他配置类</li>\n<li><code>@EnableAutoConfiguration</code>：启用 Springboot 的自动配置机制</li>\n<li><code>@ComponentScan</code>：扫描被<code>@Component</code>(<code>@Service</code>,<code>@Controller</code>)注解的 bean，默认会扫描该类所在的包下的所有的类。</li>\n</ul>\n<h3 id=\"SpringBoot-的自动配置是如何实现的？\"><a class=\"headerlink\" href=\"#SpringBoot-的自动配置是如何实现的？\"></a>SpringBoot 的自动配置是如何实现的？</h3>\n<p>当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。</p>\n<p>SpringBoot 会扫描<code>spring.factories</code>文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。</p>\n<h3 id=\"SpringBoot-常用的两种配置文件\"><a class=\"headerlink\" href=\"#SpringBoot-常用的两种配置文件\"></a>SpringBoot 常用的两种配置文件</h3>\n<p>我们可以通过<code>applcation.properties</code>或者<code>application.yml</code>对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。</p>\n<h3 id=\"什么是-YAML-YAML配置的优势在哪里？\"><a class=\"headerlink\" href=\"#什么是-YAML-YAML配置的优势在哪里？\"></a>什么是 YAML ? YAML配置的优势在哪里？</h3>\n<p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>\n<p>相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。</p>\n<p>但是 YAML 配置文件不支持<code>@PropertySource</code> 注解导入自定义的 YAML 配置。</p>\n<h3 id=\"SpringBoot-常用的读取配置文件的方法有哪些？\"><a class=\"headerlink\" href=\"#SpringBoot-常用的读取配置文件的方法有哪些？\"></a>SpringBoot 常用的读取配置文件的方法有哪些？</h3>\n<ol>\n<li>\n<p>通过<code>@Value(&quot;$&#123;property&#125;&quot;)</code>读取比较简单的配置信息</p>\n<blockquote>\n<p><code>@value</code> 这种方式是不被推荐的</p>\n</blockquote>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperties</code>读取并与 bean 绑定</p>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperies</code>读取并校验</p>\n</li>\n<li>\n<p>通过<code>@PropertySource</code>读取指定的 properties 文件</p>\n</li>\n</ol>\n<h3 id=\"SpringBoot-如何做请求参数校验？\"><a class=\"headerlink\" href=\"#SpringBoot-如何做请求参数校验？\"></a>SpringBoot 如何做请求参数校验？</h3>\n<p>使用 JSR 提供的校验注解</p>\n<h3 id=\"SpringBoot-如何监控系统运行状态？\"><a class=\"headerlink\" href=\"#SpringBoot-如何监控系统运行状态？\"></a>SpringBoot 如何监控系统运行状态？</h3>\n<p>可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。</p>\n<h3 id=\"SpringBoot-中如何实现定时任务？\"><a class=\"headerlink\" href=\"#SpringBoot-中如何实现定时任务？\"></a>SpringBoot 中如何实现定时任务？</h3>\n<p>我们使用<code>@Scheduled</code>注解就能很方便地创建一个定时任务。</p>\n<p>还需要再 SpringBoot 启动类上添加<code>@EnableScheduling</code>注解，这个注解的作用是发现<code>@Scheduled</code>的任务并在后台执行该任务。</p>\n",
            "tags": [
                "Java",
                "总结",
                "Spring"
            ]
        }
    ]
}