{
    "version": "https://jsonfeed.org/version/1",
    "title": "陆时忤的博客 • All posts by \"笔记\" tag",
    "description": "要再见 不要再见",
    "home_page_url": "https://blog.aixcc.top",
    "items": [
        {
            "id": "https://blog.aixcc.top/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "Java集合总结",
            "date_published": "2024-06-22T08:48:56.000Z",
            "content_html": "<h1 id=\"Java集合\"><a class=\"headerlink\" href=\"#Java集合\"></a>Java集合</h1>\n<h3 id=\"说说-List-Set-Queue-Map-四者的区别？\"><a class=\"headerlink\" href=\"#说说-List-Set-Queue-Map-四者的区别？\"></a>说说 List, Set, Queue, Map 四者的区别？</h3>\n<ul>\n<li>\n<p><code>List</code>：存储的元素是有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Set</code>：存储的元素不可重复。</p>\n</li>\n<li>\n<p><code>Queue</code>：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Map</code>：使用键值对存储，<code>key</code>是无序的、不可重复的，<code>value</code>是无序的、可重复的。</p>\n</li>\n</ul>\n<h2 id=\"List\"><a class=\"headerlink\" href=\"#List\"></a>List</h2>\n<h3 id=\"ArrayList-和-Array-（数组）的区别？\"><a class=\"headerlink\" href=\"#ArrayList-和-Array-（数组）的区别？\"></a>ArrayList 和 Array （数组）的区别？</h3>\n<ul>\n<li><strong>ArrayList</strong>：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。</li>\n<li><strong>Array（数组）</strong>：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。</li>\n</ul>\n<h3 id=\"ArrayList-可以添加-null-吗？\"><a class=\"headerlink\" href=\"#ArrayList-可以添加-null-吗？\"></a>ArrayList 可以添加 null 吗？</h3>\n<p><code>ArrayList</code>中可以存储任何类型的对象，包括<code>null</code>。</p>\n<h4 id=\"ArrayList和LinkedList的区别是什么？\"><a class=\"headerlink\" href=\"#ArrayList和LinkedList的区别是什么？\"></a>ArrayList和LinkedList的区别是什么？</h4>\n<ul>\n<li><strong>ArrayList</strong> 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。</li>\n<li>**LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。</li>\n</ul>\n<h3 id=\"ArrayList如何去重？\"><a class=\"headerlink\" href=\"#ArrayList如何去重？\"></a>ArrayList如何去重？</h3>\n<ol>\n<li><strong>使用HashSet</strong>：通过<code>HashSet</code>的特性去重，然后转换回<code>ArrayList</code>。</li>\n<li><strong>使用Stream API</strong>：使用Java 8引入的Stream的<code>distinct()</code>方法去重。</li>\n<li><strong>手动遍历</strong>：手动遍历<code>ArrayList</code>并使用另一个<code>ArrayList</code>存储不重复的元素。</li>\n</ol>\n<h2 id=\"Map\"><a class=\"headerlink\" href=\"#Map\"></a>Map</h2>\n<h3 id=\"HashMap和LinkedHashMap的区别？\"><a class=\"headerlink\" href=\"#HashMap和LinkedHashMap的区别？\"></a>HashMap和LinkedHashMap的区别？</h3>\n<p><code>LinkedHashMap</code>继承自<code>HashMap</code>，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。</p>\n<h3 id=\"HashMap-和-HashTable-有什么区别？\"><a class=\"headerlink\" href=\"#HashMap-和-HashTable-有什么区别？\"></a>HashMap 和 HashTable 有什么区别？</h3>\n<p>因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。</p>\n<h4 id=\"初始化容量和扩容方式：\"><a class=\"headerlink\" href=\"#初始化容量和扩容方式：\"></a>初始化容量和扩容方式：</h4>\n<ul>\n<li><strong>HashMap</strong>：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。</li>\n<li><strong>Hashtable</strong>：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1</li>\n</ul>\n<h3 id=\"ConcurrentHashMap和Hashtable的区别\"><a class=\"headerlink\" href=\"#ConcurrentHashMap和Hashtable的区别\"></a>ConcurrentHashMap和Hashtable的区别?</h3>\n<p><code>ConcurrentHashMap</code>和<code>Hashtable</code>都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。</p>\n<ul>\n<li>\n<p><strong>实现机制</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。</li>\n<li><code>Hashtable</code>使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。</li>\n</ul>\n<p><strong>性能</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。</li>\n<li><code>Hashtable</code>性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。</li>\n</ul>\n<p><strong>锁粒度</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。</li>\n<li><code>Hashtable</code>锁粒度大，所有操作都需要获取全表锁，降低了并发能力。</li>\n</ul>\n<p><strong>Null键和值</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>不允许存储<code>null</code>键和<code>null</code>值，尝试存储<code>null</code>会抛出<code>NullPointerException</code>。</li>\n<li><code>Hashtable</code>也不允许存储<code>null</code>键和<code>null</code>值，存储<code>null</code>时会抛出<code>NullPointerException</code>。</li>\n</ul>\n<p><strong>迭代器安全性</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出<code>ConcurrentModificationException</code>，但不保证读取到的值是最新的。</li>\n<li><code>Hashtable</code>提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出<code>ConcurrentModificationException</code>。</li>\n</ul>\n<h3 id=\"总结：\"><a class=\"headerlink\" href=\"#总结：\"></a>总结：</h3>\n<ul>\n<li><strong>ConcurrentHashMap</strong>适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许<code>null</code>键和值。</li>\n<li><strong>Hashtable</strong>适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许<code>null</code>键和值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HashMap-的底层原理\"><a class=\"headerlink\" href=\"#HashMap-的底层原理\"></a>HashMap 的底层原理</h3>\n<h5 id=\"1-数据结构\"><a class=\"headerlink\" href=\"#1-数据结构\"></a>1. 数据结构</h5>\n<p><code>HashMap</code>底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。</p>\n<ul>\n<li><strong>数组</strong>：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。</li>\n<li><strong>链表</strong>：是处理哈希冲突（多个键的哈希值相同）。当冲突较少时使用链表存储。</li>\n<li><strong>红黑树</strong>：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。</li>\n</ul>\n<h5 id=\"2-插入元素\"><a class=\"headerlink\" href=\"#2-插入元素\"></a>2. 插入元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>检查该位置是否已经有元素：\n<ul>\n<li>如果没有元素，直接插入。</li>\n<li>如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"3-查找元素\"><a class=\"headerlink\" href=\"#3-查找元素\"></a>3. 查找元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中查找匹配键，返回对应的值。</li>\n</ol>\n<h5 id=\"4-删除元素\"><a class=\"headerlink\" href=\"#4-删除元素\"></a>4. 删除元素</h5>\n<ul>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。</li>\n</ul>\n<h5 id=\"5-扩容机制\"><a class=\"headerlink\" href=\"#5-扩容机制\"></a>5. 扩容机制</h5>\n<p>当<code>HashMap</code>中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：</p>\n<ol>\n<li>创建一个新的数组，容量是原来的两倍。</li>\n<li>将原数组中的所有元素重新哈希并放入新数组中。</li>\n<li>重新调整链表或红黑树结构。</li>\n</ol>\n<h4 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h4>\n<ul>\n<li><strong>数据结构</strong>：<code>HashMap</code>使用数组、链表和红黑树存储元素。</li>\n<li><strong>哈希算法</strong>：通过键的<code>hashCode()</code>计算哈希值，并通过哈希值确定数组索引。</li>\n<li><strong>插入元素</strong>：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。</li>\n<li><strong>查找元素</strong>：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。</li>\n<li><strong>删除元素</strong>：定位到数组索引，删除链表或红黑树中的节点。</li>\n<li><strong>扩容机制</strong>：当元素数量超过阈值时，<code>HashMap</code>会自动扩容，重新分配数组并调整元素位置。</li>\n</ul>\n",
            "tags": [
                "Java",
                "笔记"
            ]
        },
        {
            "id": "https://blog.aixcc.top/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "Java基础总结",
            "date_published": "2024-06-21T12:41:04.000Z",
            "content_html": "<h4 id=\"对象相等和引用相等的区别\"><a class=\"headerlink\" href=\"#对象相等和引用相等的区别\"></a>对象相等和引用相等的区别</h4>\n<ul>\n<li><strong>对象相等</strong>：比较的是内存中存放的内容是否相等。</li>\n<li><strong>引用相等</strong>：比较的是它们指向的内存地址是否相等。</li>\n</ul>\n<h4 id=\"如果一个类没有声明构造方法，该程序能正确执行吗？\"><a class=\"headerlink\" href=\"#如果一个类没有声明构造方法，该程序能正确执行吗？\"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h4>\n<ul>\n<li>如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。</li>\n<li>如果添加了类的构造方法，无论是否有参，<code>Java</code>都不会添加默认不带参数的构造方法。</li>\n</ul>\n<h4 id=\"构造方法有哪些特点？是否可被重写？\"><a class=\"headerlink\" href=\"#构造方法有哪些特点？是否可被重写？\"></a>构造方法有哪些特点？是否可被重写？</h4>\n<ul>\n<li><strong>构造方法的特点</strong>：\n<ul>\n<li>名字与类名相同。</li>\n<li>没有返回值。</li>\n<li>生成类的对象时自动执行，无需调用。<br>\n构造方法不能被重写，但是可以被重载。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向对象的三大特征\"><a class=\"headerlink\" href=\"#面向对象的三大特征\"></a>面向对象的三大特征</h4>\n<ul>\n<li><strong>封装</strong>：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。</li>\n<li><strong>继承</strong>：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。</li>\n<li><strong>多态</strong>：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。</li>\n</ul>\n<h4 id=\"接口和抽象类有什么共同点和区别？\"><a class=\"headerlink\" href=\"#接口和抽象类有什么共同点和区别？\"></a>接口和抽象类有什么共同点和区别？</h4>\n<ul>\n<li><strong>共同点</strong>：\n<ul>\n<li>都不能被实例化。</li>\n<li>都可以包含抽象方法。</li>\n<li>都可以有默认的实现方法。</li>\n</ul>\n</li>\n<li><strong>区别</strong>：\n<ul>\n<li>接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。</li>\n<li>抽象类主要用于代码的复用，强调所属关系。</li>\n<li>一个类只能继承一个类，但是可以实现多个接口。</li>\n<li>接口中的成员变量只能是静态常量，不能被修改且必须有初始值。</li>\n<li>抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"深拷贝和浅拷贝的区别？什么是引用拷贝？\"><a class=\"headerlink\" href=\"#深拷贝和浅拷贝的区别？什么是引用拷贝？\"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h4>\n<ul>\n<li><strong>浅拷贝</strong>：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用<code>Object</code>的<code>clone()</code>方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。</li>\n<li><strong>深拷贝</strong>：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。</li>\n<li><strong>引用拷贝</strong>：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。</li>\n</ul>\n<h4 id=\"和-equals-的区别？\"><a class=\"headerlink\" href=\"#和-equals-的区别？\"></a>== 和 equals()的区别？</h4>\n<ul>\n<li>对于基本数据类型，<code>==</code> 比较的是值。</li>\n<li>对于引用数据类型，<code>==</code> 比较的是对象的内存地址。</li>\n<li><code>equals()</code>没有重写时，等价于<code>==</code>比较两个对象。</li>\n<li>被重写时，一般都重写<code>equals()</code>方法用来比较两个对象中的属性是否相等。</li>\n</ul>\n<h4 id=\"hashCode-有什么用？\"><a class=\"headerlink\" href=\"#hashCode-有什么用？\"></a>hashCode() 有什么用？</h4>\n<p><code>hashCode()</code>方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。</p>\n<h4 id=\"为什么重写-equals-时必须重写-hashCode-方法？\"><a class=\"headerlink\" href=\"#为什么重写-equals-时必须重写-hashCode-方法？\"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4>\n<h5 id=\"equals-和hashCode-的合同（约定）\"><a class=\"headerlink\" href=\"#equals-和hashCode-的合同（约定）\"></a><code>equals()</code>和<code>hashCode()</code>的合同（约定）</h5>\n<p>如果两个对象根据<code>equals()</code>方法是相等的，那么它们的<code>hashCode()</code>值必须相同。</p>\n<p>如果两个对象的<code>hashCode()</code>值相同，它们不一定是相等的（但它们有可能是相等的）。</p>\n<h4 id=\"String、StringBuffer、StringBuilder-的区别？\"><a class=\"headerlink\" href=\"#String、StringBuffer、StringBuilder-的区别？\"></a>String、StringBuffer、StringBuilder 的区别？</h4>\n<ul>\n<li><strong>String</strong>：不可变的，因为不可变，所以它是线程安全的。</li>\n<li><strong>StringBuffer</strong>：可变的，允许对字符串进行修改，线程安全，所有的方法都被<code>synchronized</code>修饰。</li>\n<li><strong>StringBuilder</strong>：可变的，但不是线程安全的，没有被<code>synchronized</code>修饰。由于没有同步机制，性能比<code>StringBuffer</code>更高，适合单线程环境下使用。</li>\n<li><strong>使用场景</strong>：\n<ul>\n<li>当字符串是固定不变的时候使用<code>String</code>。</li>\n<li>当需要对字符串进行大量修改且在多线程环境下使用<code>StringBuffer</code>。</li>\n<li>当需要对字符串进行大量修改且在单线程环境下使用<code>StringBuilder</code>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"字符串常量池的作用了解吗？\"><a class=\"headerlink\" href=\"#字符串常量池的作用了解吗？\"></a>字符串常量池的作用了解吗？</h4>\n<p>字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，<code>JVM</code>会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。</p>\n<h4 id=\"Exception-和-Error-有什么区别？\"><a class=\"headerlink\" href=\"#Exception-和-Error-有什么区别？\"></a>Exception 和 Error 有什么区别？</h4>\n<ul>\n<li><strong>Exception</strong>和<strong>Error</strong>都是<strong>Throwable</strong>的子类。</li>\n<li><code>Exception</code>是程序本身可以处理的异常，可以通过<code>catch</code>来捕获。<code>Exception</code>还可以分为<code>checked Exception</code>和<code>Unchecked Exception</code>。</li>\n<li><code>Error</code>是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。</li>\n</ul>\n<h4 id=\"Checked-Exception-和-Unchecked-Exception-有什么区别？\"><a class=\"headerlink\" href=\"#Checked-Exception-和-Unchecked-Exception-有什么区别？\"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4>\n<ul>\n<li><strong>Checked Exception</strong>必须被捕获或声明，否则编译器会报错。</li>\n<li><strong>Unchecked Exception</strong>也叫运行时异常，不强制要求处理，但最好捕获处理。</li>\n</ul>\n<h4 id=\"什么是泛型？有什么作用？\"><a class=\"headerlink\" href=\"#什么是泛型？有什么作用？\"></a>什么是泛型？有什么作用？</h4>\n<p>泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息</p>\n<h4 id=\"反射是什么？\"><a class=\"headerlink\" href=\"#反射是什么？\"></a>反射是什么？</h4>\n<p>反射是<code>Java</code>中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。</p>\n<h4 id=\"反射的优缺点？\"><a class=\"headerlink\" href=\"#反射的优缺点？\"></a>反射的优缺点？</h4>\n<ul>\n<li><strong>反射的优点</strong>：\n<ul>\n<li>动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。</li>\n<li>很多流行的<code>Java</code>框架如<code>Spring</code>都依赖反射来实现动态代理、依赖注入。</li>\n</ul>\n</li>\n<li><strong>反射的缺点</strong>：\n<ul>\n<li>反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。</li>\n<li>反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。</li>\n<li>使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。</li>\n<li>反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"何谓注解？\"><a class=\"headerlink\" href=\"#何谓注解？\"></a>何谓注解？</h4>\n<p>注解是<code>Java</code>中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如<code>@Override</code>注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。</p>\n<h4 id=\"什么是序列化？什么是反序列化？\"><a class=\"headerlink\" href=\"#什么是序列化？什么是反序列化？\"></a>什么是序列化？什么是反序列化？</h4>\n<ul>\n<li><strong>序列化</strong>：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。</li>\n<li><strong>反序列化</strong>：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。</li>\n</ul>\n",
            "tags": [
                "Java",
                "笔记"
            ]
        }
    ]
}