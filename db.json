{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/solitude/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/solitude/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/404.avif","path":"img/404.avif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/INFP-A.svg","path":"img/INFP-A.svg","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/JavaBasics.jpg","path":"img/JavaBasics.jpg","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/JavaCollection.png","path":"img/JavaCollection.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/VaultwardenBuild.png","path":"img/VaultwardenBuild.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/alistback.jpg","path":"img/alistback.jpg","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/avatar.avif","path":"img/avatar.avif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/black.gif","path":"img/black.gif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/cover.png","path":"img/cover.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/default.avif","path":"img/default.avif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/error_load.avif","path":"img/error_load.avif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/flower.gif","path":"img/flower.gif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/happy-sticker.avif","path":"img/happy-sticker.avif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/he.gif","path":"img/he.gif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/hour 2024-06-24 at 21.08.03.png","path":"img/hour 2024-06-24 at 21.08.03.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/java.svg","path":"img/java.svg","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/jinkesi.jpg","path":"img/jinkesi.jpg","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/loading.avif","path":"img/loading.avif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/map-dark.png","path":"img/map-dark.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/map-light.png","path":"img/map-light.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/mysqlbaguwen.png","path":"img/mysqlbaguwen.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/recent_c.avif","path":"img/recent_c.avif","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/springbaguwen.png","path":"img/springbaguwen.png","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/厚涂女孩 手绘画4K.jpeg","path":"img/厚涂女孩 手绘画4K.jpeg","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/music.js","path":"js/music.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/right_menu.js","path":"js/right_menu.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/right_menu.js.back","path":"js/right_menu.js.back","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/css/third_party/snackbar.min.css","path":"css/third_party/snackbar.min.css","modified":1,"renderable":1},{"_id":"themes/solitude/source/css/third_party/tianli_talk.styl","path":"css/third_party/tianli_talk.styl","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/pwa/browser.icns","path":"img/pwa/browser.icns","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/pwa/favicon.ico","path":"img/pwa/favicon.ico","modified":1,"renderable":1},{"_id":"themes/solitude/source/img/pwa/wu.ico","path":"img/pwa/wu.ico","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/covercolor/api.js","path":"js/covercolor/api.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/covercolor/local.js","path":"js/covercolor/local.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/search/local.js","path":"js/search/local.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/third_party/barrage.min.js","path":"js/third_party/barrage.min.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/third_party/efu_ai.min.js","path":"js/third_party/efu_ai.min.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/third_party/envelope.min.js","path":"js/third_party/envelope.min.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/third_party/universe.min.js","path":"js/third_party/universe.min.js","modified":1,"renderable":1},{"_id":"themes/solitude/source/js/third_party/waterfall.min.js","path":"js/third_party/waterfall.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"43a3f6faf52eb957710ac9368508181b13d55ca5","modified":1719416138066},{"_id":"source/_posts/Hexo备份.md","hash":"3509994858128fe0bc7bd23f5c160c94f71419c9","modified":1720693606189},{"_id":"source/_posts/Java基础八股文.md","hash":"10d9f8765ab1aaff1fedafc574a567763342930c","modified":1720189026441},{"_id":"source/_posts/.DS_Store","hash":"207236670eb49b13caad2b71cc74e5748a4dac97","modified":1719416143071},{"_id":"source/_posts/Java集合八股文.md","hash":"edcaf680b13e90b568012a1578dbdd741de2458c","modified":1720189037141},{"_id":"source/_data/about.yaml","hash":"0be5e5e0e36a3e250666706c58632cee94d152a1","modified":1719738832781},{"_id":"source/_posts/Linux安装MySQL.md","hash":"30d0f0a0ea20dac8920088de9ff5da60a33c79b4","modified":1720692994889},{"_id":"source/_posts/MyBatis八股文.md","hash":"b2799f88e515afb9b17551a97d99812a8814ff6a","modified":1720692971952},{"_id":"source/_posts/Myql八股文.md","hash":"34b52066d56ca7f0158f0dca0b88b01f6868a660","modified":1720431732272},{"_id":"source/_posts/RabbitMQ八股文.md","hash":"876c043bfb49e15cf93586833f6015e2cd06ee4b","modified":1720692958074},{"_id":"source/_posts/Redis八股文.md","hash":"688baae182302c7755584f108deeda041c53ca3a","modified":1720692853020},{"_id":"source/_posts/Spring八股文.md","hash":"ced9b202fb5f97bad58bf9d1695a7e0772487900","modified":1720189147155},{"_id":"source/_posts/Vaultwarden搭建.md","hash":"82c6a547da41c726b9299580ffb6685dccc6a17f","modified":1720692837858},{"_id":"source/_posts/使用AList定时备份服务器文件.md","hash":"3a5a5af02a3acbd960f8e95afef6b977706bd432","modified":1720172682747},{"_id":"source/_posts/好搭人.md","hash":"16fa63db957270d286d2277d3b408e256019e19a","modified":1720693676034},{"_id":"source/_posts/安装部署Hexo.md","hash":"b6ec73a1358033976109f0ee76b473f339173135","modified":1720693707118},{"_id":"source/_posts/定期清理Alist备份文件.md","hash":"dde4a6637ad26368fccc9c02c866f87db72b2749","modified":1720693697497},{"_id":"source/_posts/服务器安全设置.md","hash":"a255976ad692a20262a45e81435f44a1631c3a41","modified":1720693687835},{"_id":"source/_posts/混合.md","hash":"6e74e7109df0749147435689c9727ebb446cbcac","modified":1720415675719},{"_id":"source/_posts/脚本.md","hash":"ee48846c2437a52d384d44920a3f59275e262b72","modified":1720693661333},{"_id":"source/_posts/自动续签证书.md","hash":"cd3e6723bc5db95dbd70c5c0c153268dfffc4383","modified":1720693623063},{"_id":"source/_posts/项目讲解.md","hash":"7536d59132f1df84c77313df32b964ce92cd32e9","modified":1720693646987},{"_id":"source/about/index.md","hash":"fed00b9c89122caac554b3996b6fab369dedeb36","modified":1718702191510},{"_id":"source/message/index.md","hash":"28b2fef1886c8833aff0fe083ec6b21448b60f5a","modified":1718706589383},{"_id":"source/music/index.md","hash":"c2c5f941196f6491376a7502ab0edb49d688688c","modified":1719302310825},{"_id":"themes/solitude/package.json","hash":"fbd7cfc6491170eebe728da8b5b0e3b39a42233f","modified":1718524309977},{"_id":"themes/solitude/plugins.yml","hash":"b27234a324acb06548a7d5af684d386fab525e9b","modified":1718524309977},{"_id":"themes/solitude/_config.yml","hash":"08157bbf5f9f02a2c28a2e78c1074fcfa2395897","modified":1718524309955},{"_id":"themes/solitude/.DS_Store","hash":"95218d6870e8ef71e5c0ce5489f3318d3e280cce","modified":1719738538424},{"_id":"themes/solitude/languages/default.yml","hash":"b735a1cb8cf9cec32ea5b57fd9d1d1b48a04f395","modified":1718524309955},{"_id":"themes/solitude/layout/404.pug","hash":"259f637b940c519d0045414e6b193076cf125735","modified":1719382693684},{"_id":"themes/solitude/languages/en.yml","hash":"d1cbb92bc6356141b680142f055274643d907022","modified":1718524309955},{"_id":"themes/solitude/layout/.DS_Store","hash":"ad0b8db8a9337205d69866adec122b187f829ade","modified":1719425031365},{"_id":"themes/solitude/languages/zh-TW.yml","hash":"b5f1b044aa3c305a3d31ca776f88eed2793efd36","modified":1718524309955},{"_id":"themes/solitude/layout/index.pug","hash":"a190b82319ddbbcba7c6001238b3e82aaf72f350","modified":1718524309976},{"_id":"themes/solitude/layout/archive.pug","hash":"0630a92b8f16139c135aac1b14403a620a52654c","modified":1718524309956},{"_id":"themes/solitude/layout/page.pug","hash":"003b4acdd4cc47e8365cf296d788f977a0d4edc8","modified":1718524309976},{"_id":"themes/solitude/layout/category.pug","hash":"482f1971cf5221250b53c89a1cfb16317f6c9d59","modified":1718524309956},{"_id":"themes/solitude/layout/post.pug","hash":"b4cb9aa8c1200d8c2b9547ee2e11cd30edd22915","modified":1718524309977},{"_id":"themes/solitude/languages/zh-CN.yml","hash":"355642bde520375afad47eb34fc8114b8b28bec9","modified":1718546938639},{"_id":"themes/solitude/layout/tag.pug","hash":"21d19688b557dda1c9e26c488f7b3b00bbef8071","modified":1718524309977},{"_id":"themes/solitude/source/.DS_Store","hash":"d34b998d7dcc9719f916c49f45cee26f71b795e9","modified":1719738538425},{"_id":"themes/solitude/layout/includes/console.pug","hash":"fb12256843440a776eaaf5cd254042dd1f1284ae","modified":1718524309956},{"_id":"themes/solitude/scripts/.DS_Store","hash":"b0fe9d832d88d49a14b90b94ee49e48995dcb96a","modified":1718615982289},{"_id":"themes/solitude/layout/includes/footer.pug","hash":"8f3e2f50d961511dc36da4b54dce1193edcebe8d","modified":1718524309957},{"_id":"themes/solitude/layout/includes/.DS_Store","hash":"6453b025be548b4af3353bd7d6bed8fae2e7a068","modified":1719382730341},{"_id":"themes/solitude/layout/includes/head.pug","hash":"ed6afa31ade7d95e143268034108138bf2e939fd","modified":1718524309957},{"_id":"themes/solitude/layout/includes/header.pug","hash":"426fe2e61a12c77c317d11197a3ce7d7d8bb602d","modified":1718524309958},{"_id":"themes/solitude/scripts/event/cdn.js","hash":"c7c8b923d6b634ccf4e9db07ad0fc24001a05859","modified":1718524309978},{"_id":"themes/solitude/layout/includes/keyboard.pug","hash":"4958dd9232c790c5aa4156e0fdcd4cdf72bfc7b6","modified":1718524309958},{"_id":"themes/solitude/layout/includes/layout.pug","hash":"6fb4feec0a3fa2345631367532332ce25a838ec8","modified":1718524309959},{"_id":"themes/solitude/scripts/event/init.js","hash":"078f872a8fb0f373623bd1211ac5064e3d4c21fd","modified":1718524309978},{"_id":"themes/solitude/scripts/event/page.js","hash":"20cf3726cc7bb01b1cd58c85148ec1cd1de258c8","modified":1718524309978},{"_id":"themes/solitude/scripts/event/merge_config.js","hash":"da33d2393956a56c6ecd8d052458d5dd67bfbc5e","modified":1718524309978},{"_id":"themes/solitude/scripts/event/welcome.js","hash":"06752fe1fc9d5be212c236f68df3d2bc9379c02c","modified":1718524309979},{"_id":"themes/solitude/scripts/filter/comment.js","hash":"047365413fdc87b97be09de76cdbf090751be2b6","modified":1718524309979},{"_id":"themes/solitude/scripts/filter/checkThemeConfig.js","hash":"13d0e44048caedd9474729a16a72abe054367e57","modified":1718524309979},{"_id":"themes/solitude/scripts/filter/default.js","hash":"bfad3ab780b2cb3f9d43172a96d4ae81dab7f32d","modified":1718524309979},{"_id":"themes/solitude/scripts/filter/lazyload.js","hash":"5ad9d91958901e43d65f5aad12d5b617095bf74d","modified":1718524309980},{"_id":"themes/solitude/layout/includes/loading.pug","hash":"e2c7004a919d3c7c5e72d67818a66dfbebb3912e","modified":1718524309959},{"_id":"themes/solitude/scripts/filter/post_image.js","hash":"fd6cc64c6875d8f9ba9a8b0a9366adfbd6ca364d","modified":1718524309980},{"_id":"themes/solitude/scripts/filter/randomPosts.js","hash":"2d2976d905c0b78407e6a297fa9cd373cd60107e","modified":1718524309980},{"_id":"themes/solitude/scripts/helper/getArchiveLength.js","hash":"5b65fff0da05e6b3f5a33558fdb2ad5769ade2c6","modified":1718524309980},{"_id":"themes/solitude/scripts/helper/inject_head_js.js","hash":"04df621b0cac394f1d851856fc4d84dded4eeea4","modified":1718524309980},{"_id":"themes/solitude/scripts/helper/page.js","hash":"d0a5b107157ee05783b0a3f66f4996aef8281f54","modified":1718524309980},{"_id":"themes/solitude/scripts/helper/related_post.js","hash":"77d57e69ada5cfaab14a66914ebe58122ea29a31","modified":1718524309981},{"_id":"themes/solitude/scripts/helper/stylus.js","hash":"24fa5ba297f4eff006fa7a8d9a10ec58628a8c91","modified":1718524309981},{"_id":"themes/solitude/scripts/tags/bvideo.js","hash":"23b2ee01d3c8842b566b8a031c0b4e34dfbbba4c","modified":1718524309981},{"_id":"themes/solitude/scripts/tags/button.js","hash":"ceb4f6c59dd4bdb486b7becc8f103e3499cd20cd","modified":1718524309981},{"_id":"themes/solitude/scripts/tags/checkbox.js","hash":"e39ad4654c5f8fe7d7ddb8bf08405f473612cb9f","modified":1718524309981},{"_id":"themes/solitude/scripts/tags/fold.js","hash":"57e1e9d1e0ca4afbb2d61e130505e75ec7a41b2b","modified":1718524309981},{"_id":"themes/solitude/scripts/tags/gallery.js","hash":"4f24dc82873e3e27725bc7d52a50c13e273c4b27","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/image.js","hash":"4b33e20b3cc3bf86be1bb5c4ecba897d20fc8ef6","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/inline-image.js","hash":"9c83a721de318741ac46820e3a2161b2bdc04d4f","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/label.js","hash":"b018b96c43ccb62c307fec3694411c1adedd1a02","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/link.js","hash":"203b0b0de0942a3181362fdef09572e9da236e33","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/media.js","hash":"07a16f310cc41cb0c66396a508c7ed6ca651132e","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/mermaid.js","hash":"37a95d6c4392ff6c24ff757fbbc3cdf7853c2096","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/note.js","hash":"b5d5b15d8a5f95722abe46370e9b907276b8d739","modified":1718524309982},{"_id":"themes/solitude/scripts/tags/span.js","hash":"07881e3c8f81458422561612b85fb349a848dc5c","modified":1718524309983},{"_id":"themes/solitude/scripts/tags/tabs.js","hash":"21ea420331b4e0d39aec6dc387d6d1f40c5f8f39","modified":1718524309983},{"_id":"themes/solitude/layout/includes/rightmenu.pug","hash":"3ffe6efc73800d77752e7c8845705853580c2cbd","modified":1718547733085},{"_id":"themes/solitude/scripts/tags/timeline.js","hash":"1abd201ffd04ac45fff3e47ef6c38306f10a625e","modified":1718524309983},{"_id":"themes/solitude/layout/includes/sidebar.pug","hash":"375d6aa9cc7324638796a83fe5c877a2d006a1bf","modified":1718524309962},{"_id":"themes/solitude/source/css/.DS_Store","hash":"15bac2f3727460e424d7b8ecd30c9ab6165d3965","modified":1718798588182},{"_id":"themes/solitude/layout/includes/nav.pug","hash":"94bf062f4eff029f6b482e17ef425a06cd535ddf","modified":1718524309960},{"_id":"themes/solitude/source/css/index.styl","hash":"5468f0565df0b36e8377ee7ee545683ae83adbdf","modified":1718539765331},{"_id":"themes/solitude/source/css/var.styl","hash":"38822b1747021643fd9ddd23f09189c9e06f4d56","modified":1718524310001},{"_id":"themes/solitude/source/img/.DS_Store","hash":"d6de8c400ca2ac6f126493d1c8874d161fee542e","modified":1719738566724},{"_id":"themes/solitude/source/img/404.avif","hash":"c1457bb8020167d65f83aba7bc3dd1317595b62a","modified":1718524310001},{"_id":"themes/solitude/source/img/INFP-A.svg","hash":"dacb65e2b8804b4150f8664346955f9e1c205852","modified":1719387024934},{"_id":"themes/solitude/source/img/avatar.avif","hash":"3c63aa3309bc9d7959b4fdd5bed80f7535b4b25d","modified":1718524310001},{"_id":"themes/solitude/source/img/default.avif","hash":"3ea1493ebc8b3abc3c90aa1d200aeafc800e7143","modified":1718524310001},{"_id":"themes/solitude/source/img/error_load.avif","hash":"9e0796948e890e19e98709cf55dee0367afd69e7","modified":1718524310001},{"_id":"themes/solitude/source/img/happy-sticker.avif","hash":"3bded9b4bc40580f4d6d5f16170122d95873f741","modified":1718524310002},{"_id":"themes/solitude/source/img/java.svg","hash":"118f99a6ac36bc5c8f8841d4c7a2bfad6417ae6a","modified":1719400566122},{"_id":"themes/solitude/source/img/loading.avif","hash":"82c6e14e40975f9ae0acee8a30d2dc1f46c2831f","modified":1718524310003},{"_id":"themes/solitude/source/img/recent_c.avif","hash":"77e0f348d2e3c12ca17711be365ea5b28f35a2d9","modified":1718524310003},{"_id":"themes/solitude/source/js/.DS_Store","hash":"93bfbcab1cd8490fb68375a9b65c20a3825f8e80","modified":1718606071800},{"_id":"themes/solitude/source/js/right_menu.js","hash":"3b62c4d52c6e6979d53fcfa3e17585ca55b3243e","modified":1718546505790},{"_id":"themes/solitude/source/js/main.js","hash":"b05bb8644a41b4183c38c31bf179f4184b227c01","modified":1718542867489},{"_id":"themes/solitude/source/js/music.js","hash":"31248632c598d720607e0d54fe3b928ded5ed0a1","modified":1718524310004},{"_id":"themes/solitude/source/js/right_menu.js.back","hash":"42f9fb762c55cf6c13947eb71ac2fb3ac874df13","modified":1718524310005},{"_id":"themes/solitude/layout/includes/body/gadsense.pug","hash":"04749b45bb928a0a4aa02fb25d2f5ffd777d8fb4","modified":1718524309956},{"_id":"themes/solitude/source/js/tw_cn.js","hash":"3792da52fec1e85e5f99b45d91a0652cfde42715","modified":1718524310007},{"_id":"themes/solitude/layout/includes/body/mode.pug","hash":"a761f72d12a474edb4d23a5c743c0c3da54fcfcb","modified":1718524309956},{"_id":"themes/solitude/source/js/utils.js","hash":"9d41d45df4575b985d9888d39b7bfa12ae03f50e","modified":1718524310007},{"_id":"themes/solitude/layout/includes/head/opengraph.pug","hash":"43f1ba2b258c65146fe5bda25fcfb9c137e86a46","modified":1718524309957},{"_id":"themes/solitude/layout/includes/head/config.pug","hash":"00c5b2264fb40c881d7eb5be9ddeeeeb32cb18b6","modified":1718524309957},{"_id":"themes/solitude/layout/includes/head/page_config.pug","hash":"1e4f482cbb4622217fcf38d31c7a51f826a245b9","modified":1718524309957},{"_id":"themes/solitude/layout/includes/head/pwa.pug","hash":"701c387eb658273e5aca5b09ce06b5699f339f6f","modified":1718524309958},{"_id":"themes/solitude/layout/includes/mixins/articleSort.pug","hash":"c8cf4bd5828d0201e89e4b50c417ee96d8b4eb67","modified":1719382719882},{"_id":"themes/solitude/layout/includes/inject/body.pug","hash":"f0038b6e1f2159896f1ef8dd500c9738255c7f22","modified":1718524309958},{"_id":"themes/solitude/layout/includes/inject/head.pug","hash":"9c3f77c23b33bdacdc8473a14722b8f5dee51080","modified":1718524309958},{"_id":"themes/solitude/layout/includes/page/about.pug","hash":"97635d815b395ffad8d0eb4100bd1fb929541b0f","modified":1718524309960},{"_id":"themes/solitude/layout/includes/page/categories.pug","hash":"9db96fa0fc6f8b511515d2eccb2d8ad204e4a570","modified":1718524309960},{"_id":"themes/solitude/layout/includes/page/default.pug","hash":"0a04fe49003eb1ed2138e67113c927d6f76ba5d4","modified":1718524309960},{"_id":"themes/solitude/layout/includes/mixins/pagination.pug","hash":"705d359fa0c0de1cdfeca23c70addfe422ed75a6","modified":1718524309959},{"_id":"themes/solitude/layout/includes/page/equipment.pug","hash":"678623c2b6a26e6b6577490d33dd1d65d191b0fa","modified":1718524309960},{"_id":"themes/solitude/layout/includes/page/links.pug","hash":"8e4231d92c953ed2c2bfb3cd8a22ed57fd37f4e7","modified":1718524309960},{"_id":"themes/solitude/layout/includes/page/music.pug","hash":"6b6d8532359fc66ed3ce9524e22f72b72166bf7c","modified":1718524309961},{"_id":"themes/solitude/layout/includes/page/message.pug","hash":"9fc88429676b9a504239393e0f0d9a5534d1b267","modified":1718524309961},{"_id":"themes/solitude/layout/includes/page/recentcomment.pug","hash":"40d2253027e8b9e5f64647c7550ea844dc6267e0","modified":1718524309961},{"_id":"themes/solitude/layout/includes/page/says.pug","hash":"353ae95049435b1324249149e5828618cddfd5aa","modified":1718524309961},{"_id":"themes/solitude/layout/includes/page/tags.pug","hash":"b0b8e046f620b5de04d68ce0d8f9c4cd048b9fd8","modified":1718524309961},{"_id":"themes/solitude/layout/includes/page/tlink.pug","hash":"d203b8f68bd8f10d8a576da746e3c529d3beb08f","modified":1718524309962},{"_id":"themes/solitude/layout/includes/widgets/.DS_Store","hash":"364092835241d7aa9683cb1644cd2c62e85b7cf5","modified":1719382776904},{"_id":"themes/solitude/source/css/_comments/twikoo.styl","hash":"70b5df505baf9a426dadf030a2389792091a4173","modified":1718524309984},{"_id":"themes/solitude/layout/includes/widgets/randomlink.pug","hash":"0b85acc2b80d29cfb8f387dd03e58b2b4e4687c6","modified":1718524309972},{"_id":"themes/solitude/source/css/_comments/comment.styl","hash":"ddd1abf9b15159d258309dbd2356be9967ca560e","modified":1718524309984},{"_id":"themes/solitude/source/css/_global/animation.styl","hash":"a5db581319e2d5449da63f86111bacc0d22f73e5","modified":1718524309984},{"_id":"themes/solitude/source/css/_comments/valine.styl","hash":"b74621f4bb81f01d706a18ead8787ed2885fea26","modified":1718524309984},{"_id":"themes/solitude/source/css/_global/function.styl","hash":"47df2fbc5f7ce96256600760a42101dff87f6444","modified":1718524309985},{"_id":"themes/solitude/source/css/_global/index.styl","hash":"ad4d237274699cd01e75552f880abbe31ded888d","modified":1718524309985},{"_id":"themes/solitude/source/css/_highlight/color.styl","hash":"619c0e7592248b443849139825aa7905513dc2b9","modified":1718524309985},{"_id":"themes/solitude/source/css/_highlight/index.styl","hash":"2e70f7cd9d3ec9b4ddf5e39b73b6c4a677ebd6ac","modified":1718524309986},{"_id":"themes/solitude/source/css/_layout/article-sort.styl","hash":"17cd0b192e2e7a37cefef31d360856efe3279671","modified":1718524309987},{"_id":"themes/solitude/source/css/_layout/capsule.styl","hash":"e157d4747cda0b8bd454df47e4e03dd952ba1549","modified":1718524309988},{"_id":"themes/solitude/source/css/_layout/article-container.styl","hash":"5a80abab59313541586f2d1723c97b27d2afdb81","modified":1718524309987},{"_id":"themes/solitude/source/css/_layout/aside.styl","hash":"1cde501f84a95b222deebaf66ebd01c1d82f8c45","modified":1718524309988},{"_id":"themes/solitude/source/css/_layout/console.styl","hash":"e6ddde696f58e7f5964d49954217057a4ab8bd69","modified":1718524309988},{"_id":"themes/solitude/source/css/_layout/fullpage.styl","hash":"b0f0f361dee1ee0ea2de3372fb977e78c091de07","modified":1718524309989},{"_id":"themes/solitude/source/css/_layout/footer.styl","hash":"551120a4ef9329741019fa897303c3475ac01141","modified":1718524309989},{"_id":"themes/solitude/source/css/_layout/header.styl","hash":"67d082ce9f91a53b3bbeed57f2ac1ab0c4370fd0","modified":1718524309989},{"_id":"themes/solitude/source/css/_layout/keyboard.styl","hash":"01b81e8de4f449100257dba679d36e351ee98bf2","modified":1718524309990},{"_id":"themes/solitude/source/css/_layout/other.styl","hash":"844d16b1b1e53a38ea390bb4e376132d17105dcc","modified":1718524309990},{"_id":"themes/solitude/source/css/_layout/pagination.styl","hash":"b5f66655e8cad414c5feea55b6bbce7da53d7332","modified":1718524309990},{"_id":"themes/solitude/source/css/_layout/pace.styl","hash":"3f42bc6c0c4aad0c2e7304b748f5b91e51050678","modified":1718524309990},{"_id":"themes/solitude/source/css/_layout/recent-post.styl","hash":"86fe2b6830d65202c39f463121d5d0d9a107d752","modified":1718524309990},{"_id":"themes/solitude/source/css/_layout/rightmenu.styl","hash":"0fb403d5d0c1241a7217a251538202f4a70ccc7b","modified":1718524309990},{"_id":"themes/solitude/source/css/_mode/index.styl","hash":"a7848503e0aed2cb572136394e5e6743438c8526","modified":1718524309991},{"_id":"themes/solitude/source/css/_layout/sidebar.styl","hash":"dd9d0ac4ae11cf922bd8ba9cb6ea19fd0c9378f8","modified":1718524309991},{"_id":"themes/solitude/source/css/_layout/universe.styl","hash":"f5850f6be5159e90f0db067f9017dab4dbcf94e7","modified":1718524309991},{"_id":"themes/solitude/source/css/_page/category.styl","hash":"76e9aee0e74322caa0c2bf6bd752e7c552a994a7","modified":1718524309994},{"_id":"themes/solitude/source/css/_page/equipment.styl","hash":"a5468797c26d823df24d46a1b0d2b3d1b7bc1806","modified":1718524309995},{"_id":"themes/solitude/source/css/_page/.DS_Store","hash":"fe984da327ad4e3b76bac7ccc3511068b4fc74a0","modified":1718798588183},{"_id":"themes/solitude/source/css/_page/error.styl","hash":"3791295a503c323942f701e2707930a3a41bef7b","modified":1718524309995},{"_id":"themes/solitude/source/css/_page/index.styl","hash":"0f37a927fee868b9fea12f38e77ae2f4bf437d33","modified":1718524309995},{"_id":"themes/solitude/source/css/_page/google.styl","hash":"aff534685e24724e0b46009031c838f73ea8a552","modified":1718524309995},{"_id":"themes/solitude/source/css/_page/message.styl","hash":"54d60bc6d6fbb18d62018b06c3d28e038227800c","modified":1718524309996},{"_id":"themes/solitude/source/css/_page/links.styl","hash":"d448e5f89d8b2b038c22943eba7c94154ef77abb","modified":1718524309995},{"_id":"themes/solitude/source/css/_page/music.styl","hash":"0c2902b4522435135dbeb64557b3c6e32e070e6a","modified":1718524309996},{"_id":"themes/solitude/source/css/_page/other.styl","hash":"befd1aa9f6aa405513e198a560b14c9bb584e2bc","modified":1718524309996},{"_id":"themes/solitude/source/css/_page/recentcomment.styl","hash":"1d5344ebbb72338441a219e104e0670d625016a5","modified":1718524309996},{"_id":"themes/solitude/source/css/_page/says.styl","hash":"d8b5e5dde2f5e7477d8684e4b0aab426295f9ec6","modified":1718524309996},{"_id":"themes/solitude/source/css/_page/tag.styl","hash":"33352a6b4b1e5c20deccaa3a9fcf01c7d2b3286f","modified":1718524309996},{"_id":"themes/solitude/source/css/_post/ads.styl","hash":"11f79ab8daf53fc3886795bc06e4ad6991a07625","modified":1718524309997},{"_id":"themes/solitude/source/css/_post/commentBarrage.styl","hash":"2b6357972053ab1355ee17fd43a6a684621bfa87","modified":1718524309997},{"_id":"themes/solitude/source/css/_post/copyright.styl","hash":"b2afffab2be10b2c75991bf0e7db2e18fcf1ed4f","modified":1718524309997},{"_id":"themes/solitude/source/css/_post/meta.styl","hash":"a4799af783998868355368571877b226a28fdfa4","modified":1718524309997},{"_id":"themes/solitude/source/css/_post/index.styl","hash":"9f3b388b984cef920e4efc9c33c810d563d7c932","modified":1718524309997},{"_id":"themes/solitude/source/css/_post/pagination.styl","hash":"f805e982868225349d94fff4154971719004a1ba","modified":1718524309998},{"_id":"themes/solitude/source/css/_post/tools.styl","hash":"c5ac1d9fd0aa95bba645030f3bad2ed1d81ccfcb","modified":1718524309998},{"_id":"themes/solitude/source/css/_post/postAI.styl","hash":"01edbeb14cbb8492a375fedf2adc667b08e71fe9","modified":1718524309998},{"_id":"themes/solitude/source/css/_search/algolia-search.styl","hash":"3078cce2c4329669a5d42305274410cd1d6c580c","modified":1718524309998},{"_id":"themes/solitude/source/css/_post/relatedPost.styl","hash":"57c2dd05582a291da7a0ab52b00c128c8b535ea3","modified":1718524309998},{"_id":"themes/solitude/source/css/_search/local-search.styl","hash":"827abf80d7c6442249a163191d29404574ed0227","modified":1718524309998},{"_id":"themes/solitude/source/css/_tags/button.styl","hash":"7e89fe069a62b77ea13315dab6c5a66178294dc1","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/checkbox.styl","hash":"5c90bc01e1f6967b57d9a606faf8b3135f0eda96","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/fold.styl","hash":"a5a77e64d216d5bbc816d100ff7921aad0ede9fa","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/gallery.styl","hash":"0a6fbaa4e884ac92cbcf1e3eace8e384b839de61","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/index.styl","hash":"03fc61ba1d55010d42a9cff064ecb8f59a0efba5","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/link.styl","hash":"500c9a8e305fa46f0605af0313c065aae968abec","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/media.styl","hash":"05a249c807cd7760492a9ef5914b3e363d7d1028","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/mermaid.styl","hash":"2fcdfbf364232101f6a0fb4f7cd7180a99e63ec4","modified":1718524309999},{"_id":"themes/solitude/source/css/_tags/note.styl","hash":"17c9c830681547a471a89d6f74f755f99a7b8a7c","modified":1718524310000},{"_id":"themes/solitude/source/css/_tags/span.styl","hash":"162df35be25ac7de577b6693a7e51e39cf6adff8","modified":1718524310000},{"_id":"themes/solitude/source/css/_tags/tabs.styl","hash":"21922ed6e6963185df2221fa6f756ab092ee20f3","modified":1718524310000},{"_id":"themes/solitude/source/css/_tags/timeline.styl","hash":"6977aa9f3f69289b41b550be26fad05b87b931d4","modified":1718524310000},{"_id":"themes/solitude/source/img/pwa/.DS_Store","hash":"457245b13dcea873f15df10db5956a7a267e27f9","modified":1718798552489},{"_id":"themes/solitude/source/css/third_party/snackbar.min.css","hash":"859ff4766cb4feebb5f5d270de48a97a6dcc6e0e","modified":1718524310000},{"_id":"themes/solitude/source/css/third_party/tianli_talk.styl","hash":"4fc8a0a4b476f36973f4a44784e8a1dce4a6e517","modified":1718524310001},{"_id":"themes/solitude/source/img/pwa/favicon.ico","hash":"78ddc46cf820181fbbe5d4e05e06fc19dff1e26f","modified":1718798462581},{"_id":"themes/solitude/source/css/_tags/label.styl","hash":"ca9b4940f48f1b2e0bc0b35fb9e1b9353cc6cbb8","modified":1718524309999},{"_id":"themes/solitude/source/js/covercolor/api.js","hash":"31ed9a99ea2d8f0e8ec6a4fb42a811b26b5f4dfe","modified":1718524310004},{"_id":"themes/solitude/source/js/covercolor/local.js","hash":"5bbbaee5c8eefb9abd595494f80a2e8c6641f778","modified":1718524310004},{"_id":"themes/solitude/source/js/search/algolia.js","hash":"de84f4c95b02bd1c09b64ce1bc56f0d57a3c64d9","modified":1718524310005},{"_id":"themes/solitude/source/img/pwa/wu.ico","hash":"a42e5c6fb9ad2ca77fe654ccc83dfe11e3f2e91b","modified":1717562146000},{"_id":"themes/solitude/source/js/search/local.js","hash":"606751333812e85d8184b1be5724563b5d70d3dc","modified":1718524310005},{"_id":"themes/solitude/source/js/third_party/barrage.min.js","hash":"972bd559f05f5900ddb7a871a5d0407dfe8f1c9c","modified":1718524310006},{"_id":"themes/solitude/source/js/third_party/efu_ai.min.js","hash":"d3e50d090050516c80acc250a257a6523c259321","modified":1718524310006},{"_id":"themes/solitude/source/js/third_party/envelope.min.js","hash":"a2774f6a58734ce70447e172f0f65159464a3192","modified":1718524310006},{"_id":"themes/solitude/layout/includes/widgets/aside/aside.pug","hash":"1ef092ceced22dc7f900416036c4ba7d826fa707","modified":1718524309962},{"_id":"themes/solitude/source/js/third_party/universe.min.js","hash":"7fca64ea5e1c936f447d546cda56d1361be05927","modified":1718524310006},{"_id":"themes/solitude/layout/includes/widgets/aside/asideAdsense.pug","hash":"13dadcf053b9f8355b437e203b2bd0ae4f16f0f3","modified":1718524309962},{"_id":"themes/solitude/source/js/third_party/waterfall.min.js","hash":"ad7d449d9334c3d1c2299d01f421436e8b7a5068","modified":1718524310006},{"_id":"themes/solitude/layout/includes/widgets/aside/asideAllInfo.pug","hash":"909af56129391e3fb416912cc4c29f140d210b7a","modified":1718524309963},{"_id":"themes/solitude/layout/includes/widgets/aside/asideArchive.pug","hash":"7f74561a0503e8997e8fc556d25dff8e9b211e7c","modified":1718524309963},{"_id":"themes/solitude/layout/includes/widgets/aside/asideCustom.pug","hash":"793125e321909cec08b4434a3a6483213a3defe8","modified":1718524309963},{"_id":"themes/solitude/layout/includes/widgets/aside/asideFlipCard.pug","hash":"fe5960ceaa427d03f7a497df408a3d9c34a51520","modified":1718524309963},{"_id":"themes/solitude/layout/includes/widgets/aside/asideNewestPost.pug","hash":"e9a074eda9178345e2c6fddaa1cfacc1801a1c2d","modified":1719382770732},{"_id":"themes/solitude/layout/includes/widgets/aside/asideInfoCard.pug","hash":"1d10b5f38e85c9a3c1168e38e2c048fcc7a6205c","modified":1718524309964},{"_id":"themes/solitude/layout/includes/widgets/aside/asideNewstComments.pug","hash":"18eebe07bf7f57b8eee4bd36c14b59459b127dbd","modified":1718524309964},{"_id":"themes/solitude/layout/includes/widgets/home/banner.pug","hash":"be9f74e1850e915d9e977cd8bb0711c582288d19","modified":1718620370708},{"_id":"themes/solitude/layout/includes/widgets/aside/asideSwitch.pug","hash":"bf20d8a022184960f1154d6c43a4bb3a4434e1af","modified":1718524309964},{"_id":"themes/solitude/layout/includes/widgets/aside/asideTag.pug","hash":"09383aecaea8b588abe166bef4b7ecf49a8a6054","modified":1718524309964},{"_id":"themes/solitude/layout/includes/widgets/aside/asideWebInfo.pug","hash":"e0188bba2c25bc2b119d62323eb47c29a9a9f5df","modified":1718524309965},{"_id":"themes/solitude/layout/includes/widgets/aside/asideToc.pug","hash":"35b8992cbf6f0685bff40ac2038653235c84b609","modified":1718524309964},{"_id":"themes/solitude/layout/includes/widgets/home/bbTimeList.pug","hash":"77b80315629f5de6bc6c1c8ee0938f94283ce06e","modified":1718524309965},{"_id":"themes/solitude/layout/includes/widgets/home/carousel.pug","hash":"8178189eed3dfae888a9644fce6e4c587a0e4da1","modified":1718524309965},{"_id":"themes/solitude/layout/includes/widgets/home/categoryBar.pug","hash":"c3a23d4137075a83d33259caabb9e5d22fe5028f","modified":1718524309966},{"_id":"themes/solitude/layout/includes/widgets/home/hometop.pug","hash":"f22250f51b54213d465ffcdc582919176fc91056","modified":1718524309966},{"_id":"themes/solitude/layout/includes/widgets/home/topGroup.pug","hash":"1b599a29a215948cd0ad5cd91da696d4a600740e","modified":1719382790423},{"_id":"themes/solitude/layout/includes/widgets/home/postList.pug","hash":"b7f845f8942fe2613cf6a9e6f8681589885d1eb3","modified":1718524309966},{"_id":"themes/solitude/layout/includes/widgets/nav/group.pug","hash":"c76ece0bd14caf4d10ccee1971e8d2286717ed6e","modified":1718524309966},{"_id":"themes/solitude/layout/includes/widgets/page/banner.pug","hash":"11afbcffbbad7c0430e3d7bbfea5c5d0e5da2d08","modified":1718524309969},{"_id":"themes/solitude/layout/includes/widgets/nav/menu.pug","hash":"305453ea227ea47216abaf1c230955f51f30f5e4","modified":1718524309967},{"_id":"themes/solitude/layout/includes/widgets/post/award.pug","hash":"85573258d0d351063c15e0f0bf55768dd193bcb7","modified":1718524309971},{"_id":"themes/solitude/layout/includes/widgets/nav/right.pug","hash":"4c81fd0e35429cdb47b92eab02fe8ebadf25282a","modified":1718524309967},{"_id":"themes/solitude/layout/includes/widgets/post/copyright.pug","hash":"0ad7c6d3eb44661e7bd89dda5925ccb29a1028b8","modified":1718524309971},{"_id":"themes/solitude/layout/includes/widgets/post/post-ai.pug","hash":"d0d58cd1d62ae50c44017b0b35f0799ee2095cf8","modified":1718524309972},{"_id":"themes/solitude/layout/includes/widgets/post/postNav.pug","hash":"bffa746e80f81098628f93315a33f18d8d8a92e4","modified":1718524309972},{"_id":"themes/solitude/layout/includes/widgets/post/postMeta.pug","hash":"a47c35188d3661f54cf5fe0755cb02ad288f7a33","modified":1718524309972},{"_id":"themes/solitude/layout/includes/widgets/third-party/pjax.pug","hash":"0fb3c5f5f358d920d0ee9166c2598c5287acd0d4","modified":1718524309975},{"_id":"themes/solitude/layout/includes/widgets/third-party/music.pug","hash":"f563444a58088fe049a3132d633925d96bca9446","modified":1718524309974},{"_id":"themes/solitude/layout/includes/widgets/third-party/tianli-talk.pug","hash":"dcaef3c7b1566afef2d51d5aa8812c79428250c7","modified":1718524309976},{"_id":"themes/solitude/layout/includes/widgets/post/wave.pug","hash":"2830503992561bac02597081ddf3aaeeb6381e91","modified":1718524309972},{"_id":"themes/solitude/source/css/_highlight/highlight/diff.styl","hash":"a53389f9df4713a9adf7ded8f7c005698b0fb863","modified":1718524309985},{"_id":"themes/solitude/source/css/_highlight/highlight/index.styl","hash":"f7ddbdb01a88acf7b634db441a626b8701ef6635","modified":1718524309986},{"_id":"themes/solitude/source/css/_highlight/prismjs/index.styl","hash":"ba0b945faa473b0bce83761f15027becded9b410","modified":1718524309986},{"_id":"themes/solitude/source/css/_highlight/prismjs/diff.styl","hash":"87f7b99b5889d8736bcfad94afdf155326d29b77","modified":1718524309986},{"_id":"themes/solitude/source/css/_page/_about/about.styl","hash":"d630cf202a85b14b0bbe4643bf0d6463d11af8ad","modified":1718524309991},{"_id":"themes/solitude/source/css/_highlight/prismjs/line-number.styl","hash":"616b37b462b69b81a99e3a9747017b4e9bb4dc34","modified":1718524309986},{"_id":"themes/solitude/source/css/_highlight/theme/mac.styl","hash":"5fca444d5a1ac8447a43c5b290163d6d3a78f3de","modified":1718524309987},{"_id":"themes/solitude/source/css/_page/_about/author.styl","hash":"055010b9c7441875d9e94fc7884f03803867e062","modified":1718524309991},{"_id":"themes/solitude/source/css/_page/_about/buff.styl","hash":"1ea768328339e165ca4ea667877d04091a91d5b1","modified":1718524309992},{"_id":"themes/solitude/source/css/_highlight/theme/default.styl","hash":"e9672bff24cfbeedb52ae4bcb79d2ec45abe9bb1","modified":1718524309987},{"_id":"themes/solitude/source/css/_page/_about/careers.styl","hash":"0da567d1a2a97889c3051f8fbb54385cb0971b66","modified":1718524309992},{"_id":"themes/solitude/source/css/_page/_about/game.styl","hash":"fc97e9f95ad8cc44b87d78fe11b96fd7bf519615","modified":1718524309992},{"_id":"themes/solitude/source/css/_page/_about/maxim.styl","hash":"60072a9aac27c3f385fd138f702858851d590eab","modified":1718524309992},{"_id":"themes/solitude/source/css/_page/_about/myphoto.styl","hash":"ed8d96ec901f6dca24e9e6d9796fb70364442dbb","modified":1718524309992},{"_id":"themes/solitude/source/css/_page/_about/oneself.styl","hash":"c3a7a2f47eeab4caa9bf7e4947ab47679396f74b","modified":1718524309993},{"_id":"themes/solitude/source/css/_page/_about/skills.styl","hash":"b0ff84a1472ab5aa90a3904e5e235c88dfa91cbd","modified":1718524309993},{"_id":"themes/solitude/source/css/_page/_about/contentinfo.styl","hash":"5869a4730718093a78cc002a19da74d67b5b2bb5","modified":1718524309992},{"_id":"themes/solitude/source/css/_page/_about/like.styl","hash":"ecea66672a980eb7ac04e3cff6b0676955ea54b9","modified":1718524309992},{"_id":"themes/solitude/source/css/_page/_about/personalities.styl","hash":"226247cabe4f85325dd8f4efb10fc877aee4045b","modified":1718524309993},{"_id":"themes/solitude/source/css/_page/_about/reward.styl","hash":"5b1650fa77ca2acce4b519df7dcb9a38a434bcd1","modified":1718524309993},{"_id":"themes/solitude/source/css/_page/_about/statistic.styl","hash":"37f4f0ed374d4fa90928f62a352a3b5a1ed9b444","modified":1718524309993},{"_id":"themes/solitude/source/css/_page/_about/tenyear.styl","hash":"f038c1206f57b39e15f8e9e7be2959f3937263d6","modified":1718524309993},{"_id":"themes/solitude/source/css/_page/_home/carousel.styl","hash":"e17765d82a907cf517c1a2e0d0c15c00496e2186","modified":1718524309994},{"_id":"themes/solitude/source/css/_page/_home/home-top.styl","hash":"799ea18cc6fe3f95a8424e2816afaa7272e3edbc","modified":1718798616419},{"_id":"themes/solitude/source/css/_page/_gallery/index.styl","hash":"ebf6771a60e01aa5feeb97f975cbe34d0d2ee02f","modified":1718524309993},{"_id":"themes/solitude/source/css/_page/_home/category-bar.styl","hash":"0f092244f3e3efec7e7a4bd5d3088860f822b6c6","modified":1718524309994},{"_id":"themes/solitude/layout/includes/widgets/page/about/authorinfo.pug","hash":"97dd827681a8c6627b4bd3361cdcdc6319bf2e5a","modified":1718524309967},{"_id":"themes/solitude/layout/includes/widgets/page/about/contentinfo.pug","hash":"a26e1bb9ab2c9a93a311a75e8c3da09929615eb1","modified":1718524309967},{"_id":"themes/solitude/source/css/_page/_home/home.styl","hash":"e6736b6a8d29f82e5c82c36a83308aa606577ed1","modified":1718524309994},{"_id":"themes/solitude/layout/includes/widgets/page/about/hobbies.pug","hash":"60f0a4ba68ccc173c3715c54a6d64cb745fd0529","modified":1718524309968},{"_id":"themes/solitude/layout/includes/widgets/page/about/award.pug","hash":"4395e82859e3cbdbcbfd7d07f7453b7e123d97c4","modified":1718524309967},{"_id":"themes/solitude/layout/includes/widgets/page/about/motto.pug","hash":"bb5201e7e8b6c65c21bc3e0114460698e76ceace","modified":1718524309968},{"_id":"themes/solitude/layout/includes/widgets/page/about/other.pug","hash":"4fd3c56ddbfddb2eca43fdea54610f73ce25358c","modified":1718524309968},{"_id":"themes/solitude/layout/includes/widgets/page/about/personalities.pug","hash":"73500d7b11534fe3f15156f5d01b919d3242c4a1","modified":1718524309968},{"_id":"themes/solitude/layout/includes/widgets/page/about/skillsinfo.pug","hash":"bd48d670a4f2248109448d236c51fe3e49c054ec","modified":1718524309968},{"_id":"themes/solitude/layout/includes/widgets/page/about/tenyear.pug","hash":"11b26af1240e418f61041159a24ed2d640ec8609","modified":1718524309969},{"_id":"themes/solitude/layout/includes/widgets/page/equipment/content.pug","hash":"ec96b6a7a7ce2cf81133fe174520ffebad3648da","modified":1718524309969},{"_id":"themes/solitude/layout/includes/widgets/page/links/banner.pug","hash":"ec1ceec1fcf6775d9d37d0531fa32a498d973501","modified":1718524309969},{"_id":"themes/solitude/layout/includes/widgets/page/links/linksCard.pug","hash":"25110a9de08c07aedb69b8348345a4ecb43e18d5","modified":1718524309969},{"_id":"themes/solitude/layout/includes/widgets/page/links/linksDiscn.pug","hash":"96050862edd7bd5a63cdbfadd9fd86fa2d7fb2ac","modified":1718524309969},{"_id":"themes/solitude/layout/includes/widgets/page/message/artalk.pug","hash":"3efe88873aaed677238fc0b9de6cf6d646cb7266","modified":1718524309970},{"_id":"themes/solitude/layout/includes/widgets/page/message/content.pug","hash":"5c2dd1f045a54ebd4e14a05fffccf583f4f7e0ff","modified":1718524309970},{"_id":"themes/solitude/layout/includes/widgets/page/message/js.pug","hash":"9e8aa8aaf34863e3d95f3e62fd7519c64c7c0c73","modified":1718524309970},{"_id":"themes/solitude/layout/includes/widgets/page/message/twikoo.pug","hash":"f21212730130ef2f784a300388757443f4b4f19f","modified":1718524309970},{"_id":"themes/solitude/layout/includes/widgets/page/message/valine.pug","hash":"545b5594b94836260e724f75efab3939a71cc664","modified":1718524309970},{"_id":"themes/solitude/layout/includes/widgets/page/message/waline.pug","hash":"4152a5fb01b6225339ab698c7dc45f61669abd28","modified":1718524309970},{"_id":"themes/solitude/layout/includes/widgets/page/recentcomment/twikoo.pug","hash":"fa826e804e9ff2f0bae2086c5d99b989b3c50d47","modified":1718524309971},{"_id":"themes/solitude/layout/includes/widgets/page/recentcomment/valine.pug","hash":"dd207afe81923b3c6490b84048872670c7889477","modified":1718524309971},{"_id":"themes/solitude/layout/includes/widgets/third-party/comments/artalk.pug","hash":"4ae9e7427e13ce11b73418992c582581922b500f","modified":1718524309972},{"_id":"themes/solitude/layout/includes/widgets/third-party/comments/giscus.pug","hash":"5e1814856039bc9c5a8091633a3c3ac2ccefc5b4","modified":1718524309973},{"_id":"themes/solitude/layout/includes/widgets/page/links/linksItem.pug","hash":"8b668b8a264524cd46bfcb9c0a009eec1ad130a0","modified":1718524309970},{"_id":"themes/solitude/layout/includes/widgets/third-party/comments/js.pug","hash":"e4d63a124c6cf6d41732512bc29031ee817ed589","modified":1718524309973},{"_id":"themes/solitude/layout/includes/widgets/third-party/comments/twikoo.pug","hash":"ecbf0abb3b90decd48f5038de4a326c741a71b42","modified":1718524309973},{"_id":"themes/solitude/layout/includes/widgets/page/recentcomment/artalk.pug","hash":"fc75974064566d67fc365d2dc74eb486c6c85973","modified":1718524309971},{"_id":"themes/solitude/layout/includes/widgets/third-party/comments/waline.pug","hash":"41469e4acdca5aa149561294f5daeb6ccc4b2d49","modified":1718524309974},{"_id":"themes/solitude/layout/includes/widgets/third-party/news-comment/artalk.pug","hash":"efa89de71c67ddcf9c5b727734c7d0391d3fe32a","modified":1718524309974},{"_id":"themes/solitude/layout/includes/widgets/third-party/news-comment/newest-comment.pug","hash":"7f07dc5de630f687a8e1edeaa0a26672496030ad","modified":1718524309974},{"_id":"themes/solitude/layout/includes/widgets/third-party/news-comment/twikoo.pug","hash":"a1ce1e421a738d0f2d989ca1920c2d69d986aa8a","modified":1718524309975},{"_id":"themes/solitude/layout/includes/widgets/third-party/news-comment/valine.pug","hash":"6a98a786a1947702954932e9b3ef1847f53cfb01","modified":1718524309975},{"_id":"themes/solitude/layout/includes/widgets/third-party/news-comment/waline.pug","hash":"8c5c7ead0892efeabbbfaf8550c4a4c1b4252edd","modified":1718524309975},{"_id":"themes/solitude/layout/includes/widgets/third-party/search/algolia-search.pug","hash":"e51dbe9041219920d7e68dfa76fb1a3e4ce1f5d3","modified":1718524309975},{"_id":"themes/solitude/layout/includes/widgets/third-party/search/local-search.pug","hash":"17bd7c2f07d84bc6cbc1dadd3a09523c309816d5","modified":1718524309976},{"_id":"themes/solitude/layout/includes/widgets/page/recentcomment/waline.pug","hash":"39b9a7df8bd58056db7832e677cb0a56ec69e93f","modified":1718524309971},{"_id":"themes/solitude/layout/includes/widgets/third-party/search/index.pug","hash":"ed1cba51440757e7a38993e8d5c08932c60736d9","modified":1718524309976},{"_id":"themes/solitude/layout/includes/widgets/third-party/comments/comment.pug","hash":"7e80c417d1a9041033b8c5cab3929740af36a7f8","modified":1718524309973},{"_id":"themes/solitude/layout/includes/widgets/third-party/comments/valine.pug","hash":"2e4a2d355d8b859b649822e45e45dd9c8fdc30a4","modified":1718524309974},{"_id":"themes/solitude/source/img/cover.png","hash":"9545356c17cfbb8438bb46a0a5bfd524e0e14451","modified":1718700060190},{"_id":"themes/solitude/source/img/avatar.jpg","hash":"a29ae1eb222e631c1e131df146751c90c1074c6c","modified":1718527516061},{"_id":"themes/solitude/source/img/flower.gif","hash":"7032c79c5e077609dde5619c5946bd96873994d8","modified":1718524310002},{"_id":"themes/solitude/source/img/VaultwardenBuild.png","hash":"c5a8a5221d940a07a3e07be2d2cecc0b53cb12f8","modified":1719225343745},{"_id":"themes/solitude/source/img/mysqlbaguwen.png","hash":"c5a8a5221d940a07a3e07be2d2cecc0b53cb12f8","modified":1719111103096},{"_id":"themes/solitude/source/img/jinkesi.jpg","hash":"9ef8a38a574c3ee9aa3ea2772a5f572778cf1b75","modified":1717430059000},{"_id":"themes/solitude/source/img/black.gif","hash":"8005f80396fa049f3efc0fde67c998e75cccc285","modified":1718625754364},{"_id":"themes/solitude/source/img/hour 2024-06-24 at 21.08.03.png","hash":"6829f5f944f6367333578938565e48e8f0c03ea6","modified":1719234484599},{"_id":"themes/solitude/source/img/map-dark.png","hash":"236bca7899c7515caaf8b28ce4e746d47a1e6045","modified":1718702554889},{"_id":"themes/solitude/source/img/pwa/browser.icns","hash":"295ecfc7fa2200fabc4e2b7f24c1424873ad1fbe","modified":1718367720372},{"_id":"themes/solitude/source/img/map-light.png","hash":"50b42abcd709f548f56015acf6582a2b3be445c4","modified":1718702457882},{"_id":"themes/solitude/source/img/alistback.jpg","hash":"ed5d7f4beda73835001081aaad90221074c87154","modified":1719026505012},{"_id":"themes/solitude/source/img/he.gif","hash":"af68a7f51bb1e5d4caf59c8af3eea85af329a09d","modified":1718622527000},{"_id":"themes/solitude/source/img/厚涂女孩 手绘画4K.jpeg","hash":"2330a51950910d70b0bb0d8dc2acc2e31d32a885","modified":1719425177093},{"_id":"themes/solitude/source/img/JavaCollection.png","hash":"fa4de85a748a2944caaa42c5359d6ae89a569c81","modified":1719046443656},{"_id":"themes/solitude/source/img/JavaBasics.jpg","hash":"3b15d3578a4babd482332c855e317e9f0e665271","modified":1718973768948},{"_id":"themes/solitude/source/img/springbaguwen.png","hash":"1190612199e75d60753d00647cb04a4baa347975","modified":1719111231981},{"_id":"public/search.xml","hash":"bba58d1f74ed5d1c5a95952ab5abc820be1a070f","modified":1720693717996},{"_id":"public/404.html","hash":"74ea5de9106186fbebed949f82a390977c2fe4de","modified":1720693717996},{"_id":"public/about/index.html","hash":"ce1edfbf1ae3ae7702b67770bfbc7835736e94b9","modified":1720693717996},{"_id":"public/message/index.html","hash":"e2b1395f5a12720fcd5f363483c2bdc6e46f43d1","modified":1720693717996},{"_id":"public/music/index.html","hash":"ce4271ee83b715e9766e3e785f2f22e4a3aed67b","modified":1720693717996},{"_id":"public/2024/07/08/混合/index.html","hash":"dab581ea002d404c210591a9c8c96fabb267b224","modified":1720693717996},{"_id":"public/2024/07/06/好搭人/index.html","hash":"94223b7dff8b024803c7a3ae3db95f5bc895d3d6","modified":1720693717996},{"_id":"public/2024/07/02/定期清理Alist备份文件/index.html","hash":"e71a8eaeef52141419584d3e606a4422a45a11b1","modified":1720693717996},{"_id":"public/2024/06/27/项目讲解/index.html","hash":"1614de9811c49966e5b332ea7b8d43d264b6cf84","modified":1720693717996},{"_id":"public/2024/06/26/RabbitMQ八股文/index.html","hash":"5260374c5806e6490ae55cc28831351484d45dce","modified":1720693717996},{"_id":"public/2024/06/26/Redis八股文/index.html","hash":"e80fbdb8885e87d2b95a440ee65a6d89635489ac","modified":1720693717996},{"_id":"public/2024/06/26/MyBatis八股文/index.html","hash":"06042b403fd3c00fbd22942884e4b314aa861745","modified":1720693717996},{"_id":"public/2024/06/26/脚本/index.html","hash":"28bb07f9741cbc42e4d42fdda2b44b79663e672d","modified":1720693717996},{"_id":"public/2024/06/25/Linux安装MySQL/index.html","hash":"a642dd91b8adc7fc072da83505ee0ffb1bf3e825","modified":1720693717996},{"_id":"public/2024/06/24/自动续签证书/index.html","hash":"91674846a2d72020f43bb3e817086095ce204ff4","modified":1720693717996},{"_id":"public/2024/06/24/服务器安全设置/index.html","hash":"14d5ee96c966b2c7a265e4ea62fbeceb159758d2","modified":1720693717996},{"_id":"public/2024/06/24/Vaultwarden搭建/index.html","hash":"75aab1df00c0867e0f212917158c2ad6259fa794","modified":1720693717996},{"_id":"public/2024/06/22/Spring八股文/index.html","hash":"b7b9948e807eb6519baf0c3341367bdaabd1e638","modified":1720693717996},{"_id":"public/2024/06/22/Myql八股文/index.html","hash":"ed0c62849cd384398fa459c4dbd99f5796a080f7","modified":1720693717996},{"_id":"public/2024/06/22/Java集合八股文/index.html","hash":"1f92a232fae24c2e5d67fd1a4f2a777ed85dd596","modified":1720693717996},{"_id":"public/2024/06/21/Java基础八股文/index.html","hash":"e3ca3d273f57ed5b2b0f8d5fb12d2a5d7b151b6d","modified":1720693717996},{"_id":"public/2024/06/18/使用AList定时备份服务器文件/index.html","hash":"742f6f1107c2907f7cc0460f26b5f140e79a1ebc","modified":1720693717996},{"_id":"public/2024/06/16/Hexo备份/index.html","hash":"f100c1e61cc8970f2e87d728983a4717cd7b9105","modified":1720693717996},{"_id":"public/2024/06/16/安装部署Hexo/index.html","hash":"c6f496abb9efe3a9ccec821763f2aa85991b0ce0","modified":1720693717996},{"_id":"public/archives/index.html","hash":"efbd6e6ca73573e8d0b44321f5764646a01d2aad","modified":1720693717996},{"_id":"public/archives/page/2/index.html","hash":"78e81117846bcbbed4453854a9b2382517a4efc0","modified":1720693717996},{"_id":"public/archives/2024/index.html","hash":"6b29ae3bce9a73c28906717b57d36a82ebda72af","modified":1720693717996},{"_id":"public/archives/2024/page/2/index.html","hash":"0fca95d08862757ee8ac6e25e702349b92aa9f8e","modified":1720693717996},{"_id":"public/archives/2024/06/index.html","hash":"69472815c48ddbf87b2ad4600178514afac8258a","modified":1720693717996},{"_id":"public/archives/2024/06/page/2/index.html","hash":"04c564ae69279b6c096a202e654cc5cef053c6fb","modified":1720693717996},{"_id":"public/archives/2024/07/index.html","hash":"0d82de7ec18478f0532bbbae622fc5d260dfc777","modified":1720693717996},{"_id":"public/categories/博客/index.html","hash":"732c667c6f2c00b52d8afa785864845ee6567bac","modified":1720693717996},{"_id":"public/categories/Java/index.html","hash":"dfc5b25a132b36aed2628fd48f757b7f691d600d","modified":1720693717996},{"_id":"public/categories/Linux/index.html","hash":"3f46a5a89c817de420dfbbe0b4456d1bc9f343fe","modified":1720693717996},{"_id":"public/categories/MySQL/index.html","hash":"f0ecb5b123bc784a2f6c911dd83774d778f4ae31","modified":1720693717996},{"_id":"public/categories/Linux/MySQL/index.html","hash":"f0085fa32d7330107bf9de5aa4723d529a64d17d","modified":1720693717996},{"_id":"public/categories/Mac/index.html","hash":"a776d1f813a6b2746a1fd1fa205a231a33543e25","modified":1720693717996},{"_id":"public/index.html","hash":"8dbe202220476c399dc5fcaea7e5aa4423a14c16","modified":1720693717996},{"_id":"public/page/2/index.html","hash":"8dfeae7a3660a6a4fab9e01b156ff93530034b47","modified":1720693717996},{"_id":"public/tags/Blog/index.html","hash":"58738308de249edf1f841bec410e0156344c49ab","modified":1720693717996},{"_id":"public/tags/Java/index.html","hash":"229427d9787505cd3ae16ffa07dae135a17d7aa2","modified":1720693717996},{"_id":"public/tags/笔记/index.html","hash":"ef9f0c212988c797b31ee35357b84d4dfe6aea86","modified":1720693717996},{"_id":"public/tags/MySQL/index.html","hash":"cafb996a2a214d29ae9c7f2910d775a30b3c42ef","modified":1720693717996},{"_id":"public/tags/Linux/index.html","hash":"1ba2a4ff97556380fa734cc7a9dd15dcea5cf29a","modified":1720693717996},{"_id":"public/tags/MyBatis/index.html","hash":"3e097675f9ceb68cc6b9f0029b3b395491f7e2bd","modified":1720693717996},{"_id":"public/tags/总结/index.html","hash":"a64f9188c42c7f3803ec847ac990596d2aca0545","modified":1720693717996},{"_id":"public/tags/RabbitMQ/index.html","hash":"eca923b81bad6bf72d07cecf15d4ed2991eb7fa0","modified":1720693717996},{"_id":"public/tags/Redis/index.html","hash":"6370821ad5156ac78119f98552cadf43a220590b","modified":1720693717996},{"_id":"public/tags/Alist/index.html","hash":"d036b539781b5a1cd5c4def9615686d39de9a1b9","modified":1720693717996},{"_id":"public/tags/Spring/index.html","hash":"c5d380af80c86dce2f5096dec9ab96d3f8052d39","modified":1720693717996},{"_id":"public/tags/SSL/index.html","hash":"2b2dab738bbfef62fdadf87046d351ccc6d7d04c","modified":1720693717996},{"_id":"public/tags/Mac/index.html","hash":"a6c88b2a83ca9e041ea9242df457487bd0a8c611","modified":1720693717996},{"_id":"public/tags/域名/index.html","hash":"a4e6e35f3f9566ad39dcc269f0f58721686f8392","modified":1720693717996},{"_id":"public/tags/index.html","hash":"e2d1477dee5ec0668a9bf3b414709f1f01859556","modified":1720693717996},{"_id":"public/categories/index.html","hash":"81673d1bf6d63f8f05601b7d638ffb63c440d424","modified":1720693717996},{"_id":"public/img/INFP-A.svg","hash":"dacb65e2b8804b4150f8664346955f9e1c205852","modified":1720693717996},{"_id":"public/img/404.avif","hash":"c1457bb8020167d65f83aba7bc3dd1317595b62a","modified":1720693717996},{"_id":"public/img/avatar.avif","hash":"3c63aa3309bc9d7959b4fdd5bed80f7535b4b25d","modified":1720693717996},{"_id":"public/img/error_load.avif","hash":"9e0796948e890e19e98709cf55dee0367afd69e7","modified":1720693717996},{"_id":"public/img/default.avif","hash":"3ea1493ebc8b3abc3c90aa1d200aeafc800e7143","modified":1720693717996},{"_id":"public/img/happy-sticker.avif","hash":"3bded9b4bc40580f4d6d5f16170122d95873f741","modified":1720693717996},{"_id":"public/img/java.svg","hash":"118f99a6ac36bc5c8f8841d4c7a2bfad6417ae6a","modified":1720693717996},{"_id":"public/img/loading.avif","hash":"82c6e14e40975f9ae0acee8a30d2dc1f46c2831f","modified":1720693717996},{"_id":"public/img/recent_c.avif","hash":"77e0f348d2e3c12ca17711be365ea5b28f35a2d9","modified":1720693717996},{"_id":"public/js/right_menu.js.back","hash":"42f9fb762c55cf6c13947eb71ac2fb3ac874df13","modified":1720693717996},{"_id":"public/img/pwa/favicon.ico","hash":"78ddc46cf820181fbbe5d4e05e06fc19dff1e26f","modified":1720693717996},{"_id":"public/img/pwa/wu.ico","hash":"a42e5c6fb9ad2ca77fe654ccc83dfe11e3f2e91b","modified":1720693717996},{"_id":"public/lib/hbe.js","hash":"fb05fcd82bb28d3b2887d388cabea7f9b1a318eb","modified":1720693717996},{"_id":"public/css/hbe.style.css","hash":"72959894400fd5c350106cb558c39fa51f722cbd","modified":1720693717996},{"_id":"public/img/avatar.jpg","hash":"a29ae1eb222e631c1e131df146751c90c1074c6c","modified":1720693717996},{"_id":"public/img/cover.png","hash":"9545356c17cfbb8438bb46a0a5bfd524e0e14451","modified":1720693717996},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1720693717996},{"_id":"public/js/music.js","hash":"31248632c598d720607e0d54fe3b928ded5ed0a1","modified":1720693717996},{"_id":"public/js/right_menu.js","hash":"3b62c4d52c6e6979d53fcfa3e17585ca55b3243e","modified":1720693717996},{"_id":"public/js/utils.js","hash":"9d41d45df4575b985d9888d39b7bfa12ae03f50e","modified":1720693717996},{"_id":"public/css/third_party/snackbar.min.css","hash":"859ff4766cb4feebb5f5d270de48a97a6dcc6e0e","modified":1720693717996},{"_id":"public/css/third_party/tianli_talk.css","hash":"156448ced3ee5cbbba24f952bf8912af4c6e62c3","modified":1720693717996},{"_id":"public/js/covercolor/api.js","hash":"31ed9a99ea2d8f0e8ec6a4fb42a811b26b5f4dfe","modified":1720693717996},{"_id":"public/js/covercolor/local.js","hash":"5bbbaee5c8eefb9abd595494f80a2e8c6641f778","modified":1720693717996},{"_id":"public/js/search/algolia.js","hash":"de84f4c95b02bd1c09b64ce1bc56f0d57a3c64d9","modified":1720693717996},{"_id":"public/js/search/local.js","hash":"606751333812e85d8184b1be5724563b5d70d3dc","modified":1720693717996},{"_id":"public/js/third_party/barrage.min.js","hash":"972bd559f05f5900ddb7a871a5d0407dfe8f1c9c","modified":1720693717996},{"_id":"public/js/third_party/efu_ai.min.js","hash":"d3e50d090050516c80acc250a257a6523c259321","modified":1720693717996},{"_id":"public/js/third_party/envelope.min.js","hash":"a2774f6a58734ce70447e172f0f65159464a3192","modified":1720693717996},{"_id":"public/js/third_party/universe.min.js","hash":"7fca64ea5e1c936f447d546cda56d1361be05927","modified":1720693717996},{"_id":"public/js/third_party/waterfall.min.js","hash":"ad7d449d9334c3d1c2299d01f421436e8b7a5068","modified":1720693717996},{"_id":"public/css/index.css","hash":"adac892785a7097a556762f3bc4384a0a2c32430","modified":1720693717996},{"_id":"public/js/main.js","hash":"b05bb8644a41b4183c38c31bf179f4184b227c01","modified":1720693717996},{"_id":"public/js/tw_cn.js","hash":"3792da52fec1e85e5f99b45d91a0652cfde42715","modified":1720693717996},{"_id":"public/img/flower.gif","hash":"7032c79c5e077609dde5619c5946bd96873994d8","modified":1720693717996},{"_id":"public/img/VaultwardenBuild.png","hash":"c5a8a5221d940a07a3e07be2d2cecc0b53cb12f8","modified":1720693717996},{"_id":"public/img/mysqlbaguwen.png","hash":"c5a8a5221d940a07a3e07be2d2cecc0b53cb12f8","modified":1720693717996},{"_id":"public/img/jinkesi.jpg","hash":"9ef8a38a574c3ee9aa3ea2772a5f572778cf1b75","modified":1720693717996},{"_id":"public/img/black.gif","hash":"8005f80396fa049f3efc0fde67c998e75cccc285","modified":1720693717996},{"_id":"public/img/hour 2024-06-24 at 21.08.03.png","hash":"6829f5f944f6367333578938565e48e8f0c03ea6","modified":1720693717996},{"_id":"public/img/pwa/browser.icns","hash":"295ecfc7fa2200fabc4e2b7f24c1424873ad1fbe","modified":1720693717996},{"_id":"public/img/map-dark.png","hash":"236bca7899c7515caaf8b28ce4e746d47a1e6045","modified":1720693717996},{"_id":"public/img/map-light.png","hash":"50b42abcd709f548f56015acf6582a2b3be445c4","modified":1720693717996},{"_id":"public/img/alistback.jpg","hash":"ed5d7f4beda73835001081aaad90221074c87154","modified":1720693717996},{"_id":"public/img/he.gif","hash":"af68a7f51bb1e5d4caf59c8af3eea85af329a09d","modified":1720693717996},{"_id":"public/img/厚涂女孩 手绘画4K.jpeg","hash":"2330a51950910d70b0bb0d8dc2acc2e31d32a885","modified":1720693717996},{"_id":"public/img/JavaCollection.png","hash":"fa4de85a748a2944caaa42c5359d6ae89a569c81","modified":1720693717996},{"_id":"public/img/JavaBasics.jpg","hash":"3b15d3578a4babd482332c855e317e9f0e665271","modified":1720693717996},{"_id":"public/img/springbaguwen.png","hash":"1190612199e75d60753d00647cb04a4baa347975","modified":1720693717996}],"Category":[{"name":"博客","_id":"clyh4m2gj0004tuj86xny52tn"},{"name":"Java","_id":"clyh4m2go000atuj8dewo6g2z"},{"name":"Linux","_id":"clyh4m2gr000gtuj819i59vsc"},{"name":"MySQL","_id":"clyh4m2gw000ttuj85mgm0kpt"},{"name":"MySQL","parent":"clyh4m2gr000gtuj819i59vsc","_id":"clyh4m2gy0011tuj8h6s70s8h"},{"name":"Mac","_id":"clyh4m2h2001htuj8aq3nbygz"}],"Data":[{"_id":"about","data":{"authorinfo":{"leftTags":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手"],"rightTags":["脚踏实地行动派 🏃","团队小组发动机 🧱","壮汉人狠话不多 💢"],"image":"/img/avatar.jpg"},"title":"关于本站","contentinfo":{"sup":"你好，很高兴认识你👋","name":"我叫Aix","title":"Java工程师、独立开发者、心学","tip":"追求","slogan":"源于<br>热爱而去创造","mask":["优秀的产品","出色的设计","高效的编程","人性化的用户体验"]},"skills":{"title":"技能","subtitle":"开启创造力","tags":[{"title":"HTML","icon":"https://npm.elemecdn.com/wleelw-blog-abs@1.0.0/img/icon/HTML.png","color":"#e9572b"},{"title":"Javascript","icon":"https://npm.elemecdn.com/wleelw-blog-abs@1.0.0/img/icon/JS.png","color":"#f7cb4f"},{"title":"Java","icon":"https://profilinator.rishav.dev/skills-assets/java-original-wordmark.svg","color":"#ffffff"},{"title":"Linux","icon":"https://profilinator.rishav.dev/skills-assets/linux-original.svg","color":"#ffffff"},{"title":"Spring","icon":"https://profilinator.rishav.dev/skills-assets/springio-icon.svg","color":"#ffffff"},{"title":"VUE","icon":"https://profilinator.rishav.dev/skills-assets/vuejs-original-wordmark.svg","color":"‘#ffffff'"},{"title":"Git","icon":"https://npm.elemecdn.com/wleelw-blog-abs@1.0.0/img/icon/git.png","color":"#df5b40"},{"title":"Docker","icon":"https://7.isyangs.cn/34/65f2e45462045-34.png","color":"#57b6e6"},{"title":"Visual Studio","icon":"https://npm.elemecdn.com/wleelw-blog-abs@1.0.0/img/icon/vs-logo.svg","color":"#ffffff"}]},"careers":{"title":"生涯","subtitle":"无限进步","items":[{"school":"软件工程","major":"学习","color":"#357ef5"}],"image":"https://7.isyangs.cn/1/65eb2d10ba24d-1.png"},"personalities":{"tips":"性格","title":"调停者","color":"#56a178","type":"INFP-A","image":"/img/INFP-A.svg","link":"https://www.16personalities.com/","linkText":"16personalities","typeLink":"https://www.16personalities.com/ch/infp-%E4%BA%BA%E6%A0%BC","typeName":"调停者","myphoto":"https://alist.lushiwu.top/d/OneDrive/Cloud/粉色长发蒙眼少女3440x1440带鱼屏.jpg"},"motto":{"title":"座右铭","prefix":"破釜沉舟，","content":"砥砺前行。"},"expertise":{"title":"特长","prefix":"睡觉","specialist":"专家","content":"学习能力","level":"MAX"},"tj":{"provider":null,"url":"https://v6-widget.51.la/v6/3F15j2vtdTo7PPcN/quote.js","img":"https://7.isyangs.cn/1/65eb2e9109826-1.png"},"oneself":{"location":"中国，湖北省","birthYear":"2001","university":"武汉东湖学院","major":"软件工程","occupation":"Java工程师","map":{"light":"/img/map-light.png","dark":"/img/map-dark.png"}},"cause":{"tip":"心学","title":"内心修养与幸福追求","content":"<p>心学，作为中国哲学中的一股重要力量，不仅在历史上影响深远，其理念在当今社会仍然具有重要的现实意义。心学强调通过内心的修养和自我反省来追求智慧与幸福，这种思想可以帮助我们在现代生活中找到内在的平静与真正的满足。</p>\n<h2>内心修养的核心思想</h2> <p>心学的核心思想在于内心的修养。王阳明提出“致良知”，即通过自我反省和内省，发现和培养内心本具的良知。这种良知并不是外界教导的结果，而是内心固有的智慧和道德。通过不断的自我反省，我们可以更清晰地认识自己，发现内心的真实需求，从而避免被外界的纷扰所迷惑。</p> <p>在现代社会中，我们往往被各种外在的欲望所驱使，追求物质的丰裕和名利的满足。然而，这些外在的追求常常让我们感到空虚和不安。心学告诉我们，真正的幸福和智慧来源于内心的宁静和自我认识。通过内心的修养，我们可以找到生命的真正意义，获得内在的满足。</p>\n<h2>真诚待人的重要性</h2> <p>心学强调真诚待人，认为人与人之间的信任和理解是建立在真诚的基础上的。在心学的视角下，真诚不仅是道德的要求，更是内心修养的重要部分。通过真诚待人，我们能够建立更加稳固和谐的人际关系，营造一个充满信任和理解的社会环境。</p> <p>在实际生活中，真诚待人意味着我们要以开放的心态对待他人，尊重他人的感受和观点，不带偏见和伪装。这样，我们才能真正理解他人，与他人建立深厚的情感纽带。真诚待人不仅能让我们赢得他人的信任和尊重，也能让我们的内心更加坦荡和充实。</p>\n<h2>面对挑战的智慧</h2> <p>人生充满了各种挑战和挫折，而心学提供了面对这些困难的智慧。王阳明提倡“知行合一”，即通过实际行动来验证和实现内心的智慧。面对困难时，我们需要保持内心的坚韧和信念，不被外界的挫折所打倒。</p> <p>心学认为，每一次挫折都是成长的机会，通过反省和内省，我们可以从中汲取教训和智慧。挫折和挑战不仅让我们更加坚强，也让我们更加深入地理解生命的本质和意义。在挫折中保持内心的平静和信念，我们才能在逆境中找到前进的方向，走向更高的自我实现。</p>\n<h2>简约生活的倡导</h2> <p>心学倡导简约生活，认为内心的富足远比物质的丰裕重要。在现代社会中，我们常常被物质的欲望所困扰，追求更多的财富和地位。然而，这些外在的追求并不能带来真正的幸福，反而让我们感到更加焦虑和不安。</p> <p>通过简约的生活方式，我们可以摆脱对物质的依赖，追求内心的平静和满足。简约生活并不是拒绝物质，而是通过合理的选择和控制，找到内心的平衡和富足。通过减少不必要的欲望和追求，我们可以专注于内心的成长和修养，获得真正的幸福和满足。</p>\n<h2>结论</h2> <p>心学的思想，不仅是古代哲人的智慧，也是我们现代生活中的指引。通过内心的修养、真诚待人、面对挑战和简约生活，我们可以找到生命的真正意义和内在的平静。心学告诉我们，幸福和智慧并不在外界的纷扰之中，而在于我们内心的修养和成长。让我们以心学为指引，走向更加充实和幸福的人生。</p>"},"tenyear":{"tips":"三年之约","title":"一个人的寂寞，一群人的狂欢。","start":"2024年06月15日","end":"2027年06月15日"}}}],"Page":[{"title":"关于本站","date":"2023-10-31T14:24:22.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于本站\ndate: 2023-10-31 22:24:22\ntype: about\n---\n","updated":"2024-06-18T09:16:31.510Z","path":"about/index.html","comments":1,"layout":"page","_id":"clyh4m2gc0000tuj85tmtf2w3","content":"","excerpt":"关于本站","more":"","cover":"/img/default.avif","toc":false,"comment":true},{"title":"留言板","date":"2020-12-31T16:00:00.000Z","type":"message","_content":"","source":"message/index.md","raw":"---\ntitle: 留言板\ndate: 2021-01-01 00:00:00\ntype: message\n---\n","updated":"2024-06-18T10:29:49.383Z","path":"message/index.html","comments":1,"layout":"page","_id":"clyh4m2gi0002tuj8eu2p72pg","content":"","excerpt":"留言板","more":"","cover":"/img/default.avif","toc":false,"comment":true},{"title":"音乐馆","date":"2023-12-11T13:36:08.000Z","type":"music","comment":false,"_content":"","source":"music/index.md","raw":"---\ntitle: 音乐馆\ndate: 2023-12-11 21:36:08\ntype: music\ncomment: false\n---\n","updated":"2024-06-25T07:58:30.825Z","path":"music/index.html","comments":1,"layout":"page","_id":"clyh4m2gl0006tuj8a4ttd067","content":"","excerpt":"音乐馆","more":"","cover":"/img/default.avif","toc":false}],"Post":[{"title":"Hexo备份","date":"2024-06-16T11:19:00.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/hexo.png","_content":"# 使用 Hexo 和 GitHub 实现多平台工作和数据备份\n\n## 目标\n\n- **`master` 分支**：保存 Hexo 生成的静态文件，用于部署到 GitHub Pages。\n- **`hexo` 分支**：保存 Hexo 源文件，便于本地编辑和备份，并设置为默认分支。\n\n## 为什么要这样做？\n\n使用两个分支的目的是将生成的静态文件和源文件分开管理，以便在多个设备上编辑博客，同时保持数据的安全备份。`hexo` 分支保存源文件，方便我们在不同平台进行编辑；`master` 分支保存静态文件，用于发布到 GitHub Pages。\n\n## 操作步骤\n\n### 1. 初始化 Hexo 项目\n\n首先，在本地初始化你的 Hexo 项目。这一步会创建一个新的 Hexo 项目，并安装所需的依赖。\n\n```bash\nhexo init my-blog\ncd my-blog\nnpm install\n```\n\n### 2. 初始化 Git 仓库\n\n在 Hexo 项目目录中初始化 Git 仓库，以便我们可以将项目推送到 GitHub。\n\n```bash\ngit init\n```\n\n### 3. 创建 hexo 分支\n\n创建一个新的分支 `hexo`，用于保存 Hexo 的源文件。默认情况下，我们会在这个分支上进行编辑和管理。\n\n```bash\ngit checkout -b hexo\n```\n\n### 4. 推送 hexo 分支到 GitHub\n\n将 `hexo` 分支推送到 GitHub，并设置为默认分支。这样可以确保我们的源文件在 GitHub 上有备份，并且可以在多个设备上同步编辑。\n\n```bash\ngit remote add origin https://github.com/yourusername/yourrepo.git\ngit add .\ngit commit -m \"Initial commit with Hexo source files\"\ngit push -u origin hexo\n```\n\n然后，在 GitHub 仓库设置中，将 `hexo` 分支设置为默认分支：\n1. 打开你的 GitHub 仓库。\n2. 点击 \"Settings\"。\n3. 在左侧菜单中点击 \"Branches\"。\n4. 在 \"Default branch\" 下拉菜单中选择 `hexo`，然后点击 \"Update\"。\n\n### 5. 创建 master 分支\n\n切换到 `master` 分支，并将其用于保存 Hexo 生成的静态文件。这个分支将用于部署到 GitHub Pages。\n\n```bash\ngit checkout --orphan master\n```\n\n删除所有文件，因为 `master` 分支只需要保存生成的静态文件。\n\n```bash\ngit rm -rf .\n```\n\n创建一个空的 README 文件并提交，以初始化 `master` 分支。\n\n```bash\necho \"# My Blog\" > README.md\ngit add README.md\ngit commit -m \"Initial commit for master branch\"\ngit push -u origin master\n```\n\n### 6. 配置 Hexo 部署\n\n在 Hexo 项目根目录下的 `_config.yml` 文件中配置部署设置，使 Hexo 能将生成的静态文件推送到 `master` 分支。\n\n```yaml\ndeploy:\n  type: git\n  repo: https://github.com/yourusername/yourrepo.git\n  branch: master\n```\n\n安装 Hexo 部署插件 `hexo-deployer-git`，使 Hexo 能通过 Git 进行部署。\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n### 7. 生成和部署静态文件\n\n运行以下命令生成静态文件并部署到 `master` 分支：\n\n```bash\nhexo clean\nhexo generate\nhexo deploy\n```\n\n- `hexo clean`：清理生成的文件。\n- `hexo generate`：生成静态文件。\n- `hexo deploy`：将生成的静态文件部署到 GitHub 上的 `master` 分支。\n\n### 8. 推送 Hexo 源文件到 hexo 分支\n\n每次更新 Hexo 源文件后，将它们推送到 `hexo` 分支，以确保源文件有备份。\n\n```bash\ngit add .\ngit commit -m \"Update Hexo source files\"\ngit push origin hexo\n```\n\n## 验证配置\n\n1. **确认 `hexo` 分支为默认分支**：保存 Hexo 源文件，并便于多平台编辑。\n2. **确认 `master` 分支保存生成的静态文件**：用于部署到 GitHub Pages，并确保网站正常访问。\n","source":"_posts/Hexo备份.md","raw":"---\ntitle: Hexo备份\ndate: 2024-06-16 19:19:00\ntags: Blog\ncategories: 博客\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/hexo.png\n---\n# 使用 Hexo 和 GitHub 实现多平台工作和数据备份\n\n## 目标\n\n- **`master` 分支**：保存 Hexo 生成的静态文件，用于部署到 GitHub Pages。\n- **`hexo` 分支**：保存 Hexo 源文件，便于本地编辑和备份，并设置为默认分支。\n\n## 为什么要这样做？\n\n使用两个分支的目的是将生成的静态文件和源文件分开管理，以便在多个设备上编辑博客，同时保持数据的安全备份。`hexo` 分支保存源文件，方便我们在不同平台进行编辑；`master` 分支保存静态文件，用于发布到 GitHub Pages。\n\n## 操作步骤\n\n### 1. 初始化 Hexo 项目\n\n首先，在本地初始化你的 Hexo 项目。这一步会创建一个新的 Hexo 项目，并安装所需的依赖。\n\n```bash\nhexo init my-blog\ncd my-blog\nnpm install\n```\n\n### 2. 初始化 Git 仓库\n\n在 Hexo 项目目录中初始化 Git 仓库，以便我们可以将项目推送到 GitHub。\n\n```bash\ngit init\n```\n\n### 3. 创建 hexo 分支\n\n创建一个新的分支 `hexo`，用于保存 Hexo 的源文件。默认情况下，我们会在这个分支上进行编辑和管理。\n\n```bash\ngit checkout -b hexo\n```\n\n### 4. 推送 hexo 分支到 GitHub\n\n将 `hexo` 分支推送到 GitHub，并设置为默认分支。这样可以确保我们的源文件在 GitHub 上有备份，并且可以在多个设备上同步编辑。\n\n```bash\ngit remote add origin https://github.com/yourusername/yourrepo.git\ngit add .\ngit commit -m \"Initial commit with Hexo source files\"\ngit push -u origin hexo\n```\n\n然后，在 GitHub 仓库设置中，将 `hexo` 分支设置为默认分支：\n1. 打开你的 GitHub 仓库。\n2. 点击 \"Settings\"。\n3. 在左侧菜单中点击 \"Branches\"。\n4. 在 \"Default branch\" 下拉菜单中选择 `hexo`，然后点击 \"Update\"。\n\n### 5. 创建 master 分支\n\n切换到 `master` 分支，并将其用于保存 Hexo 生成的静态文件。这个分支将用于部署到 GitHub Pages。\n\n```bash\ngit checkout --orphan master\n```\n\n删除所有文件，因为 `master` 分支只需要保存生成的静态文件。\n\n```bash\ngit rm -rf .\n```\n\n创建一个空的 README 文件并提交，以初始化 `master` 分支。\n\n```bash\necho \"# My Blog\" > README.md\ngit add README.md\ngit commit -m \"Initial commit for master branch\"\ngit push -u origin master\n```\n\n### 6. 配置 Hexo 部署\n\n在 Hexo 项目根目录下的 `_config.yml` 文件中配置部署设置，使 Hexo 能将生成的静态文件推送到 `master` 分支。\n\n```yaml\ndeploy:\n  type: git\n  repo: https://github.com/yourusername/yourrepo.git\n  branch: master\n```\n\n安装 Hexo 部署插件 `hexo-deployer-git`，使 Hexo 能通过 Git 进行部署。\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n### 7. 生成和部署静态文件\n\n运行以下命令生成静态文件并部署到 `master` 分支：\n\n```bash\nhexo clean\nhexo generate\nhexo deploy\n```\n\n- `hexo clean`：清理生成的文件。\n- `hexo generate`：生成静态文件。\n- `hexo deploy`：将生成的静态文件部署到 GitHub 上的 `master` 分支。\n\n### 8. 推送 Hexo 源文件到 hexo 分支\n\n每次更新 Hexo 源文件后，将它们推送到 `hexo` 分支，以确保源文件有备份。\n\n```bash\ngit add .\ngit commit -m \"Update Hexo source files\"\ngit push origin hexo\n```\n\n## 验证配置\n\n1. **确认 `hexo` 分支为默认分支**：保存 Hexo 源文件，并便于多平台编辑。\n2. **确认 `master` 分支保存生成的静态文件**：用于部署到 GitHub Pages，并确保网站正常访问。\n","slug":"Hexo备份","published":1,"updated":"2024-07-11T10:26:46.189Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gf0001tuj89p3f9yif","content":"<h1 id=\"使用-Hexo-和-GitHub-实现多平台工作和数据备份\"><a class=\"headerlink\" href=\"#使用-Hexo-和-GitHub-实现多平台工作和数据备份\"></a>使用 Hexo 和 GitHub 实现多平台工作和数据备份</h1>\n<h2 id=\"目标\"><a class=\"headerlink\" href=\"#目标\"></a>目标</h2>\n<ul>\n<li><strong><code>master</code> 分支</strong>：保存 Hexo 生成的静态文件，用于部署到 GitHub Pages。</li>\n<li><strong><code>hexo</code> 分支</strong>：保存 Hexo 源文件，便于本地编辑和备份，并设置为默认分支。</li>\n</ul>\n<h2 id=\"为什么要这样做？\"><a class=\"headerlink\" href=\"#为什么要这样做？\"></a>为什么要这样做？</h2>\n<p>使用两个分支的目的是将生成的静态文件和源文件分开管理，以便在多个设备上编辑博客，同时保持数据的安全备份。<code>hexo</code> 分支保存源文件，方便我们在不同平台进行编辑；<code>master</code> 分支保存静态文件，用于发布到 GitHub Pages。</p>\n<h2 id=\"操作步骤\"><a class=\"headerlink\" href=\"#操作步骤\"></a>操作步骤</h2>\n<h3 id=\"1-初始化-Hexo-项目\"><a class=\"headerlink\" href=\"#1-初始化-Hexo-项目\"></a>1. 初始化 Hexo 项目</h3>\n<p>首先，在本地初始化你的 Hexo 项目。这一步会创建一个新的 Hexo 项目，并安装所需的依赖。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo init my-blog\n<span class=\"token builtin class-name\">cd</span> my-blog\n<span class=\"token function\">npm</span> <span class=\"token function\">install</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"2-初始化-Git-仓库\"><a class=\"headerlink\" href=\"#2-初始化-Git-仓库\"></a>2. 初始化 Git 仓库</h3>\n<p>在 Hexo 项目目录中初始化 Git 仓库，以便我们可以将项目推送到 GitHub。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> init<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"3-创建-hexo-分支\"><a class=\"headerlink\" href=\"#3-创建-hexo-分支\"></a>3. 创建 hexo 分支</h3>\n<p>创建一个新的分支 <code>hexo</code>，用于保存 Hexo 的源文件。默认情况下，我们会在这个分支上进行编辑和管理。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout <span class=\"token parameter variable\">-b</span> hexo<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"4-推送-hexo-分支到-GitHub\"><a class=\"headerlink\" href=\"#4-推送-hexo-分支到-GitHub\"></a>4. 推送 hexo 分支到 GitHub</h3>\n<p>将 <code>hexo</code> 分支推送到 GitHub，并设置为默认分支。这样可以确保我们的源文件在 GitHub 上有备份，并且可以在多个设备上同步编辑。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> remote <span class=\"token function\">add</span> origin https://github.com/yourusername/yourrepo.git\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"Initial commit with Hexo source files\"</span>\n<span class=\"token function\">git</span> push <span class=\"token parameter variable\">-u</span> origin hexo<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，在 GitHub 仓库设置中，将 <code>hexo</code> 分支设置为默认分支：</p>\n<ol>\n<li>打开你的 GitHub 仓库。</li>\n<li>点击 “Settings”。</li>\n<li>在左侧菜单中点击 “Branches”。</li>\n<li>在 “Default branch” 下拉菜单中选择 <code>hexo</code>，然后点击 “Update”。</li>\n</ol>\n<h3 id=\"5-创建-master-分支\"><a class=\"headerlink\" href=\"#5-创建-master-分支\"></a>5. 创建 master 分支</h3>\n<p>切换到 <code>master</code> 分支，并将其用于保存 Hexo 生成的静态文件。这个分支将用于部署到 GitHub Pages。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout <span class=\"token parameter variable\">--orphan</span> master<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>删除所有文件，因为 <code>master</code> 分支只需要保存生成的静态文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> <span class=\"token builtin class-name\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>创建一个空的 README 文件并提交，以初始化 <code>master</code> 分支。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"# My Blog\"</span> <span class=\"token operator\">></span> README.md\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> README.md\n<span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"Initial commit for master branch\"</span>\n<span class=\"token function\">git</span> push <span class=\"token parameter variable\">-u</span> origin master<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"6-配置-Hexo-部署\"><a class=\"headerlink\" href=\"#6-配置-Hexo-部署\"></a>6. 配置 Hexo 部署</h3>\n<p>在 Hexo 项目根目录下的 <code>_config.yml</code> 文件中配置部署设置，使 Hexo 能将生成的静态文件推送到 <code>master</code> 分支。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> git\n  <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//github.com/yourusername/yourrepo.git\n  <span class=\"token key atrule\">branch</span><span class=\"token punctuation\">:</span> master<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>安装 Hexo 部署插件 <code>hexo-deployer-git</code>，使 Hexo 能通过 Git 进行部署。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> hexo-deployer-git <span class=\"token parameter variable\">--save</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"7-生成和部署静态文件\"><a class=\"headerlink\" href=\"#7-生成和部署静态文件\"></a>7. 生成和部署静态文件</h3>\n<p>运行以下命令生成静态文件并部署到 <code>master</code> 分支：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo clean\nhexo generate\nhexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><code>hexo clean</code>：清理生成的文件。</li>\n<li><code>hexo generate</code>：生成静态文件。</li>\n<li><code>hexo deploy</code>：将生成的静态文件部署到 GitHub 上的 <code>master</code> 分支。</li>\n</ul>\n<h3 id=\"8-推送-Hexo-源文件到-hexo-分支\"><a class=\"headerlink\" href=\"#8-推送-Hexo-源文件到-hexo-分支\"></a>8. 推送 Hexo 源文件到 hexo 分支</h3>\n<p>每次更新 Hexo 源文件后，将它们推送到 <code>hexo</code> 分支，以确保源文件有备份。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"Update Hexo source files\"</span>\n<span class=\"token function\">git</span> push origin hexo<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"验证配置\"><a class=\"headerlink\" href=\"#验证配置\"></a>验证配置</h2>\n<ol>\n<li><strong>确认 <code>hexo</code> 分支为默认分支</strong>：保存 Hexo 源文件，并便于多平台编辑。</li>\n<li><strong>确认 <code>master</code> 分支保存生成的静态文件</strong>：用于部署到 GitHub Pages，并确保网站正常访问。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"使用-Hexo-和-GitHub-实现多平台工作和数据备份\"><a class=\"headerlink\" href=\"#使用-Hexo-和-GitHub-实现多平台工作和数据备份\"></a>使用 Hexo 和 GitHub 实现多平台工作和数据备份</h1>\n<h2 id=\"目标\"><a class=\"headerlink\" href=\"#目标\"></a>目标</h2>\n<ul>\n<li><strong><code>master</code> 分支</strong>：保存 Hexo 生成的静态文件，用于部署到 GitHub Pages。</li>\n<li><strong><code>hexo</code> 分支</strong>：保存 Hexo 源文件，便于本地编辑和备份，并设置为默认分支。</li>\n</ul>\n<h2 id=\"为什么要这样做？\"><a class=\"headerlink\" href=\"#为什么要这样做？\"></a>为什么要这样做？</h2>\n<p>使用两个分支的目的是将生成的静态文件和源文件分开管理，以便在多个设备上编辑博客，同时保持数据的安全备份。<code>hexo</code> 分支保存源文件，方便我们在不同平台进行编辑；<code>master</code> 分支保存静态文件，用于发布到 GitHub Pages。</p>\n<h2 id=\"操作步骤\"><a class=\"headerlink\" href=\"#操作步骤\"></a>操作步骤</h2>\n<h3 id=\"1-初始化-Hexo-项目\"><a class=\"headerlink\" href=\"#1-初始化-Hexo-项目\"></a>1. 初始化 Hexo 项目</h3>\n<p>首先，在本地初始化你的 Hexo 项目。这一步会创建一个新的 Hexo 项目，并安装所需的依赖。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo init my-blog\n<span class=\"token builtin class-name\">cd</span> my-blog\n<span class=\"token function\">npm</span> <span class=\"token function\">install</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"2-初始化-Git-仓库\"><a class=\"headerlink\" href=\"#2-初始化-Git-仓库\"></a>2. 初始化 Git 仓库</h3>\n<p>在 Hexo 项目目录中初始化 Git 仓库，以便我们可以将项目推送到 GitHub。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> init<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"3-创建-hexo-分支\"><a class=\"headerlink\" href=\"#3-创建-hexo-分支\"></a>3. 创建 hexo 分支</h3>\n<p>创建一个新的分支 <code>hexo</code>，用于保存 Hexo 的源文件。默认情况下，我们会在这个分支上进行编辑和管理。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout <span class=\"token parameter variable\">-b</span> hexo<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"4-推送-hexo-分支到-GitHub\"><a class=\"headerlink\" href=\"#4-推送-hexo-分支到-GitHub\"></a>4. 推送 hexo 分支到 GitHub</h3>\n<p>将 <code>hexo</code> 分支推送到 GitHub，并设置为默认分支。这样可以确保我们的源文件在 GitHub 上有备份，并且可以在多个设备上同步编辑。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> remote <span class=\"token function\">add</span> origin https://github.com/yourusername/yourrepo.git\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"Initial commit with Hexo source files\"</span>\n<span class=\"token function\">git</span> push <span class=\"token parameter variable\">-u</span> origin hexo<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，在 GitHub 仓库设置中，将 <code>hexo</code> 分支设置为默认分支：</p>\n<ol>\n<li>打开你的 GitHub 仓库。</li>\n<li>点击 “Settings”。</li>\n<li>在左侧菜单中点击 “Branches”。</li>\n<li>在 “Default branch” 下拉菜单中选择 <code>hexo</code>，然后点击 “Update”。</li>\n</ol>\n<h3 id=\"5-创建-master-分支\"><a class=\"headerlink\" href=\"#5-创建-master-分支\"></a>5. 创建 master 分支</h3>\n<p>切换到 <code>master</code> 分支，并将其用于保存 Hexo 生成的静态文件。这个分支将用于部署到 GitHub Pages。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout <span class=\"token parameter variable\">--orphan</span> master<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>删除所有文件，因为 <code>master</code> 分支只需要保存生成的静态文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> <span class=\"token builtin class-name\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>创建一个空的 README 文件并提交，以初始化 <code>master</code> 分支。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"# My Blog\"</span> <span class=\"token operator\">></span> README.md\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> README.md\n<span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"Initial commit for master branch\"</span>\n<span class=\"token function\">git</span> push <span class=\"token parameter variable\">-u</span> origin master<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"6-配置-Hexo-部署\"><a class=\"headerlink\" href=\"#6-配置-Hexo-部署\"></a>6. 配置 Hexo 部署</h3>\n<p>在 Hexo 项目根目录下的 <code>_config.yml</code> 文件中配置部署设置，使 Hexo 能将生成的静态文件推送到 <code>master</code> 分支。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> git\n  <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//github.com/yourusername/yourrepo.git\n  <span class=\"token key atrule\">branch</span><span class=\"token punctuation\">:</span> master<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>安装 Hexo 部署插件 <code>hexo-deployer-git</code>，使 Hexo 能通过 Git 进行部署。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> hexo-deployer-git <span class=\"token parameter variable\">--save</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"7-生成和部署静态文件\"><a class=\"headerlink\" href=\"#7-生成和部署静态文件\"></a>7. 生成和部署静态文件</h3>\n<p>运行以下命令生成静态文件并部署到 <code>master</code> 分支：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo clean\nhexo generate\nhexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><code>hexo clean</code>：清理生成的文件。</li>\n<li><code>hexo generate</code>：生成静态文件。</li>\n<li><code>hexo deploy</code>：将生成的静态文件部署到 GitHub 上的 <code>master</code> 分支。</li>\n</ul>\n<h3 id=\"8-推送-Hexo-源文件到-hexo-分支\"><a class=\"headerlink\" href=\"#8-推送-Hexo-源文件到-hexo-分支\"></a>8. 推送 Hexo 源文件到 hexo 分支</h3>\n<p>每次更新 Hexo 源文件后，将它们推送到 <code>hexo</code> 分支，以确保源文件有备份。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"Update Hexo source files\"</span>\n<span class=\"token function\">git</span> push origin hexo<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"验证配置\"><a class=\"headerlink\" href=\"#验证配置\"></a>验证配置</h2>\n<ol>\n<li><strong>确认 <code>hexo</code> 分支为默认分支</strong>：保存 Hexo 源文件，并便于多平台编辑。</li>\n<li><strong>确认 <code>master</code> 分支保存生成的静态文件</strong>：用于部署到 GitHub Pages，并确保网站正常访问。</li>\n</ol>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"Java基础总结","date":"2024-06-21T12:41:04.000Z","cover":"/img/JavaBasics.jpg","recommend":true,"_content":"#### 对象相等和引用相等的区别\n- **对象相等**：比较的是内存中存放的内容是否相等。\n- **引用相等**：比较的是它们指向的内存地址是否相等。\n\n#### 如果一个类没有声明构造方法，该程序能正确执行吗？\n- 如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。\n- 如果添加了类的构造方法，无论是否有参，`Java`都不会添加默认不带参数的构造方法。\n\n#### 构造方法有哪些特点？是否可被重写？\n- **构造方法的特点**：\n  - 名字与类名相同。\n  - 没有返回值。\n  - 生成类的对象时自动执行，无需调用。\n    构造方法不能被重写，但是可以被重载。\n\n#### 面向对象的三大特征\n- **封装**：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。\n- **继承**：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。\n- **多态**：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。\n\n#### 接口和抽象类有什么共同点和区别？\n- **共同点**：\n  - 都不能被实例化。\n  - 都可以包含抽象方法。\n  - 都可以有默认的实现方法。\n- **区别**：\n  - 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。\n  - 抽象类主要用于代码的复用，强调所属关系。\n  - 一个类只能继承一个类，但是可以实现多个接口。\n  - 接口中的成员变量只能是静态常量，不能被修改且必须有初始值。\n  - 抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。\n\n#### 深拷贝和浅拷贝的区别？什么是引用拷贝？\n- **浅拷贝**：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用`Object`的`clone()`方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。\n- **深拷贝**：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。\n- **引用拷贝**：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。\n\n#### == 和 equals()的区别？\n- 对于基本数据类型，`==` 比较的是值。\n- 对于引用数据类型，`==` 比较的是对象的内存地址。\n- `equals()`没有重写时，等价于`==`比较两个对象。\n- 被重写时，一般都重写`equals()`方法用来比较两个对象中的属性是否相等。\n\n#### hashCode() 有什么用？\n`hashCode()`方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。\n\n#### 为什么重写 equals() 时必须重写 hashCode() 方法？\n\n##### `equals()`和`hashCode()`的合同（约定）\n\n如果两个对象根据`equals()`方法是相等的，那么它们的`hashCode()`值必须相同。\n\n如果两个对象的`hashCode()`值相同，它们不一定是相等的（但它们有可能是相等的）。\n\n#### String、StringBuffer、StringBuilder 的区别？\n- **String**：不可变的，因为不可变，所以它是线程安全的。\n- **StringBuffer**：可变的，允许对字符串进行修改，线程安全，所有的方法都被`synchronized`修饰。\n- **StringBuilder**：可变的，但不是线程安全的，没有被`synchronized`修饰。由于没有同步机制，性能比`StringBuffer`更高，适合单线程环境下使用。\n- **使用场景**：\n  - 当字符串是固定不变的时候使用`String`。\n  - 当需要对字符串进行大量修改且在多线程环境下使用`StringBuffer`。\n  - 当需要对字符串进行大量修改且在单线程环境下使用`StringBuilder`。\n\n#### 字符串常量池的作用了解吗？\n字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，`JVM`会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。\n\n#### Exception 和 Error 有什么区别？\n- **Exception**和**Error**都是**Throwable**的子类。\n- `Exception`是程序本身可以处理的异常，可以通过`catch`来捕获。`Exception`还可以分为`checked Exception`和`Unchecked Exception`。\n- `Error`是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。\n\n#### Checked Exception 和 Unchecked Exception 有什么区别？\n- **Checked Exception**必须被捕获或声明，否则编译器会报错。\n- **Unchecked Exception**也叫运行时异常，不强制要求处理，但最好捕获处理。\n\n#### 什么是泛型？有什么作用？\n泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息\n\n#### 反射是什么？\n反射是`Java`中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。\n\n#### 反射的优缺点？\n- **反射的优点**：\n  - 动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。\n  - 很多流行的`Java`框架如`Spring`都依赖反射来实现动态代理、依赖注入。\n- **反射的缺点**：\n  - 反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。\n  - 反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。\n  - 使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。\n  - 反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。\n\n#### 何谓注解？\n注解是`Java`中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如`@Override`注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。\n\n#### 什么是序列化？什么是反序列化？\n- **序列化**：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。\n- **反序列化**：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。\n\n","source":"_posts/Java基础八股文.md","raw":"---\ntitle: Java基础总结\ndate: 2024-06-21 20:41:04\ntags: \n    - Java\n    - 笔记\ncategories: Java\ncover: /img/JavaBasics.jpg\nrecommend: true\n---\n#### 对象相等和引用相等的区别\n- **对象相等**：比较的是内存中存放的内容是否相等。\n- **引用相等**：比较的是它们指向的内存地址是否相等。\n\n#### 如果一个类没有声明构造方法，该程序能正确执行吗？\n- 如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。\n- 如果添加了类的构造方法，无论是否有参，`Java`都不会添加默认不带参数的构造方法。\n\n#### 构造方法有哪些特点？是否可被重写？\n- **构造方法的特点**：\n  - 名字与类名相同。\n  - 没有返回值。\n  - 生成类的对象时自动执行，无需调用。\n    构造方法不能被重写，但是可以被重载。\n\n#### 面向对象的三大特征\n- **封装**：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。\n- **继承**：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。\n- **多态**：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。\n\n#### 接口和抽象类有什么共同点和区别？\n- **共同点**：\n  - 都不能被实例化。\n  - 都可以包含抽象方法。\n  - 都可以有默认的实现方法。\n- **区别**：\n  - 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。\n  - 抽象类主要用于代码的复用，强调所属关系。\n  - 一个类只能继承一个类，但是可以实现多个接口。\n  - 接口中的成员变量只能是静态常量，不能被修改且必须有初始值。\n  - 抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。\n\n#### 深拷贝和浅拷贝的区别？什么是引用拷贝？\n- **浅拷贝**：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用`Object`的`clone()`方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。\n- **深拷贝**：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。\n- **引用拷贝**：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。\n\n#### == 和 equals()的区别？\n- 对于基本数据类型，`==` 比较的是值。\n- 对于引用数据类型，`==` 比较的是对象的内存地址。\n- `equals()`没有重写时，等价于`==`比较两个对象。\n- 被重写时，一般都重写`equals()`方法用来比较两个对象中的属性是否相等。\n\n#### hashCode() 有什么用？\n`hashCode()`方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。\n\n#### 为什么重写 equals() 时必须重写 hashCode() 方法？\n\n##### `equals()`和`hashCode()`的合同（约定）\n\n如果两个对象根据`equals()`方法是相等的，那么它们的`hashCode()`值必须相同。\n\n如果两个对象的`hashCode()`值相同，它们不一定是相等的（但它们有可能是相等的）。\n\n#### String、StringBuffer、StringBuilder 的区别？\n- **String**：不可变的，因为不可变，所以它是线程安全的。\n- **StringBuffer**：可变的，允许对字符串进行修改，线程安全，所有的方法都被`synchronized`修饰。\n- **StringBuilder**：可变的，但不是线程安全的，没有被`synchronized`修饰。由于没有同步机制，性能比`StringBuffer`更高，适合单线程环境下使用。\n- **使用场景**：\n  - 当字符串是固定不变的时候使用`String`。\n  - 当需要对字符串进行大量修改且在多线程环境下使用`StringBuffer`。\n  - 当需要对字符串进行大量修改且在单线程环境下使用`StringBuilder`。\n\n#### 字符串常量池的作用了解吗？\n字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，`JVM`会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。\n\n#### Exception 和 Error 有什么区别？\n- **Exception**和**Error**都是**Throwable**的子类。\n- `Exception`是程序本身可以处理的异常，可以通过`catch`来捕获。`Exception`还可以分为`checked Exception`和`Unchecked Exception`。\n- `Error`是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。\n\n#### Checked Exception 和 Unchecked Exception 有什么区别？\n- **Checked Exception**必须被捕获或声明，否则编译器会报错。\n- **Unchecked Exception**也叫运行时异常，不强制要求处理，但最好捕获处理。\n\n#### 什么是泛型？有什么作用？\n泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息\n\n#### 反射是什么？\n反射是`Java`中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。\n\n#### 反射的优缺点？\n- **反射的优点**：\n  - 动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。\n  - 很多流行的`Java`框架如`Spring`都依赖反射来实现动态代理、依赖注入。\n- **反射的缺点**：\n  - 反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。\n  - 反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。\n  - 使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。\n  - 反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。\n\n#### 何谓注解？\n注解是`Java`中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如`@Override`注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。\n\n#### 什么是序列化？什么是反序列化？\n- **序列化**：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。\n- **反序列化**：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。\n\n","slug":"Java基础八股文","published":1,"updated":"2024-07-05T14:17:06.441Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gi0003tuj8cj2o3ygb","content":"<h4 id=\"对象相等和引用相等的区别\"><a class=\"headerlink\" href=\"#对象相等和引用相等的区别\"></a>对象相等和引用相等的区别</h4>\n<ul>\n<li><strong>对象相等</strong>：比较的是内存中存放的内容是否相等。</li>\n<li><strong>引用相等</strong>：比较的是它们指向的内存地址是否相等。</li>\n</ul>\n<h4 id=\"如果一个类没有声明构造方法，该程序能正确执行吗？\"><a class=\"headerlink\" href=\"#如果一个类没有声明构造方法，该程序能正确执行吗？\"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h4>\n<ul>\n<li>如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。</li>\n<li>如果添加了类的构造方法，无论是否有参，<code>Java</code>都不会添加默认不带参数的构造方法。</li>\n</ul>\n<h4 id=\"构造方法有哪些特点？是否可被重写？\"><a class=\"headerlink\" href=\"#构造方法有哪些特点？是否可被重写？\"></a>构造方法有哪些特点？是否可被重写？</h4>\n<ul>\n<li><strong>构造方法的特点</strong>：\n<ul>\n<li>名字与类名相同。</li>\n<li>没有返回值。</li>\n<li>生成类的对象时自动执行，无需调用。<br>\n构造方法不能被重写，但是可以被重载。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向对象的三大特征\"><a class=\"headerlink\" href=\"#面向对象的三大特征\"></a>面向对象的三大特征</h4>\n<ul>\n<li><strong>封装</strong>：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。</li>\n<li><strong>继承</strong>：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。</li>\n<li><strong>多态</strong>：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。</li>\n</ul>\n<h4 id=\"接口和抽象类有什么共同点和区别？\"><a class=\"headerlink\" href=\"#接口和抽象类有什么共同点和区别？\"></a>接口和抽象类有什么共同点和区别？</h4>\n<ul>\n<li><strong>共同点</strong>：\n<ul>\n<li>都不能被实例化。</li>\n<li>都可以包含抽象方法。</li>\n<li>都可以有默认的实现方法。</li>\n</ul>\n</li>\n<li><strong>区别</strong>：\n<ul>\n<li>接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。</li>\n<li>抽象类主要用于代码的复用，强调所属关系。</li>\n<li>一个类只能继承一个类，但是可以实现多个接口。</li>\n<li>接口中的成员变量只能是静态常量，不能被修改且必须有初始值。</li>\n<li>抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"深拷贝和浅拷贝的区别？什么是引用拷贝？\"><a class=\"headerlink\" href=\"#深拷贝和浅拷贝的区别？什么是引用拷贝？\"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h4>\n<ul>\n<li><strong>浅拷贝</strong>：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用<code>Object</code>的<code>clone()</code>方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。</li>\n<li><strong>深拷贝</strong>：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。</li>\n<li><strong>引用拷贝</strong>：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。</li>\n</ul>\n<h4 id=\"和-equals-的区别？\"><a class=\"headerlink\" href=\"#和-equals-的区别？\"></a>== 和 equals()的区别？</h4>\n<ul>\n<li>对于基本数据类型，<code>==</code> 比较的是值。</li>\n<li>对于引用数据类型，<code>==</code> 比较的是对象的内存地址。</li>\n<li><code>equals()</code>没有重写时，等价于<code>==</code>比较两个对象。</li>\n<li>被重写时，一般都重写<code>equals()</code>方法用来比较两个对象中的属性是否相等。</li>\n</ul>\n<h4 id=\"hashCode-有什么用？\"><a class=\"headerlink\" href=\"#hashCode-有什么用？\"></a>hashCode() 有什么用？</h4>\n<p><code>hashCode()</code>方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。</p>\n<h4 id=\"为什么重写-equals-时必须重写-hashCode-方法？\"><a class=\"headerlink\" href=\"#为什么重写-equals-时必须重写-hashCode-方法？\"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4>\n<h5 id=\"equals-和hashCode-的合同（约定）\"><a class=\"headerlink\" href=\"#equals-和hashCode-的合同（约定）\"></a><code>equals()</code>和<code>hashCode()</code>的合同（约定）</h5>\n<p>如果两个对象根据<code>equals()</code>方法是相等的，那么它们的<code>hashCode()</code>值必须相同。</p>\n<p>如果两个对象的<code>hashCode()</code>值相同，它们不一定是相等的（但它们有可能是相等的）。</p>\n<h4 id=\"String、StringBuffer、StringBuilder-的区别？\"><a class=\"headerlink\" href=\"#String、StringBuffer、StringBuilder-的区别？\"></a>String、StringBuffer、StringBuilder 的区别？</h4>\n<ul>\n<li><strong>String</strong>：不可变的，因为不可变，所以它是线程安全的。</li>\n<li><strong>StringBuffer</strong>：可变的，允许对字符串进行修改，线程安全，所有的方法都被<code>synchronized</code>修饰。</li>\n<li><strong>StringBuilder</strong>：可变的，但不是线程安全的，没有被<code>synchronized</code>修饰。由于没有同步机制，性能比<code>StringBuffer</code>更高，适合单线程环境下使用。</li>\n<li><strong>使用场景</strong>：\n<ul>\n<li>当字符串是固定不变的时候使用<code>String</code>。</li>\n<li>当需要对字符串进行大量修改且在多线程环境下使用<code>StringBuffer</code>。</li>\n<li>当需要对字符串进行大量修改且在单线程环境下使用<code>StringBuilder</code>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"字符串常量池的作用了解吗？\"><a class=\"headerlink\" href=\"#字符串常量池的作用了解吗？\"></a>字符串常量池的作用了解吗？</h4>\n<p>字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，<code>JVM</code>会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。</p>\n<h4 id=\"Exception-和-Error-有什么区别？\"><a class=\"headerlink\" href=\"#Exception-和-Error-有什么区别？\"></a>Exception 和 Error 有什么区别？</h4>\n<ul>\n<li><strong>Exception</strong>和<strong>Error</strong>都是<strong>Throwable</strong>的子类。</li>\n<li><code>Exception</code>是程序本身可以处理的异常，可以通过<code>catch</code>来捕获。<code>Exception</code>还可以分为<code>checked Exception</code>和<code>Unchecked Exception</code>。</li>\n<li><code>Error</code>是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。</li>\n</ul>\n<h4 id=\"Checked-Exception-和-Unchecked-Exception-有什么区别？\"><a class=\"headerlink\" href=\"#Checked-Exception-和-Unchecked-Exception-有什么区别？\"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4>\n<ul>\n<li><strong>Checked Exception</strong>必须被捕获或声明，否则编译器会报错。</li>\n<li><strong>Unchecked Exception</strong>也叫运行时异常，不强制要求处理，但最好捕获处理。</li>\n</ul>\n<h4 id=\"什么是泛型？有什么作用？\"><a class=\"headerlink\" href=\"#什么是泛型？有什么作用？\"></a>什么是泛型？有什么作用？</h4>\n<p>泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息</p>\n<h4 id=\"反射是什么？\"><a class=\"headerlink\" href=\"#反射是什么？\"></a>反射是什么？</h4>\n<p>反射是<code>Java</code>中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。</p>\n<h4 id=\"反射的优缺点？\"><a class=\"headerlink\" href=\"#反射的优缺点？\"></a>反射的优缺点？</h4>\n<ul>\n<li><strong>反射的优点</strong>：\n<ul>\n<li>动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。</li>\n<li>很多流行的<code>Java</code>框架如<code>Spring</code>都依赖反射来实现动态代理、依赖注入。</li>\n</ul>\n</li>\n<li><strong>反射的缺点</strong>：\n<ul>\n<li>反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。</li>\n<li>反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。</li>\n<li>使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。</li>\n<li>反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"何谓注解？\"><a class=\"headerlink\" href=\"#何谓注解？\"></a>何谓注解？</h4>\n<p>注解是<code>Java</code>中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如<code>@Override</code>注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。</p>\n<h4 id=\"什么是序列化？什么是反序列化？\"><a class=\"headerlink\" href=\"#什么是序列化？什么是反序列化？\"></a>什么是序列化？什么是反序列化？</h4>\n<ul>\n<li><strong>序列化</strong>：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。</li>\n<li><strong>反序列化</strong>：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。</li>\n</ul>\n","excerpt":"","more":"<h4 id=\"对象相等和引用相等的区别\"><a class=\"headerlink\" href=\"#对象相等和引用相等的区别\"></a>对象相等和引用相等的区别</h4>\n<ul>\n<li><strong>对象相等</strong>：比较的是内存中存放的内容是否相等。</li>\n<li><strong>引用相等</strong>：比较的是它们指向的内存地址是否相等。</li>\n</ul>\n<h4 id=\"如果一个类没有声明构造方法，该程序能正确执行吗？\"><a class=\"headerlink\" href=\"#如果一个类没有声明构造方法，该程序能正确执行吗？\"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h4>\n<ul>\n<li>如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。</li>\n<li>如果添加了类的构造方法，无论是否有参，<code>Java</code>都不会添加默认不带参数的构造方法。</li>\n</ul>\n<h4 id=\"构造方法有哪些特点？是否可被重写？\"><a class=\"headerlink\" href=\"#构造方法有哪些特点？是否可被重写？\"></a>构造方法有哪些特点？是否可被重写？</h4>\n<ul>\n<li><strong>构造方法的特点</strong>：\n<ul>\n<li>名字与类名相同。</li>\n<li>没有返回值。</li>\n<li>生成类的对象时自动执行，无需调用。<br>\n构造方法不能被重写，但是可以被重载。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向对象的三大特征\"><a class=\"headerlink\" href=\"#面向对象的三大特征\"></a>面向对象的三大特征</h4>\n<ul>\n<li><strong>封装</strong>：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。</li>\n<li><strong>继承</strong>：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。</li>\n<li><strong>多态</strong>：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。</li>\n</ul>\n<h4 id=\"接口和抽象类有什么共同点和区别？\"><a class=\"headerlink\" href=\"#接口和抽象类有什么共同点和区别？\"></a>接口和抽象类有什么共同点和区别？</h4>\n<ul>\n<li><strong>共同点</strong>：\n<ul>\n<li>都不能被实例化。</li>\n<li>都可以包含抽象方法。</li>\n<li>都可以有默认的实现方法。</li>\n</ul>\n</li>\n<li><strong>区别</strong>：\n<ul>\n<li>接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。</li>\n<li>抽象类主要用于代码的复用，强调所属关系。</li>\n<li>一个类只能继承一个类，但是可以实现多个接口。</li>\n<li>接口中的成员变量只能是静态常量，不能被修改且必须有初始值。</li>\n<li>抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"深拷贝和浅拷贝的区别？什么是引用拷贝？\"><a class=\"headerlink\" href=\"#深拷贝和浅拷贝的区别？什么是引用拷贝？\"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h4>\n<ul>\n<li><strong>浅拷贝</strong>：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用<code>Object</code>的<code>clone()</code>方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。</li>\n<li><strong>深拷贝</strong>：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。</li>\n<li><strong>引用拷贝</strong>：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。</li>\n</ul>\n<h4 id=\"和-equals-的区别？\"><a class=\"headerlink\" href=\"#和-equals-的区别？\"></a>== 和 equals()的区别？</h4>\n<ul>\n<li>对于基本数据类型，<code>==</code> 比较的是值。</li>\n<li>对于引用数据类型，<code>==</code> 比较的是对象的内存地址。</li>\n<li><code>equals()</code>没有重写时，等价于<code>==</code>比较两个对象。</li>\n<li>被重写时，一般都重写<code>equals()</code>方法用来比较两个对象中的属性是否相等。</li>\n</ul>\n<h4 id=\"hashCode-有什么用？\"><a class=\"headerlink\" href=\"#hashCode-有什么用？\"></a>hashCode() 有什么用？</h4>\n<p><code>hashCode()</code>方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。</p>\n<h4 id=\"为什么重写-equals-时必须重写-hashCode-方法？\"><a class=\"headerlink\" href=\"#为什么重写-equals-时必须重写-hashCode-方法？\"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4>\n<h5 id=\"equals-和hashCode-的合同（约定）\"><a class=\"headerlink\" href=\"#equals-和hashCode-的合同（约定）\"></a><code>equals()</code>和<code>hashCode()</code>的合同（约定）</h5>\n<p>如果两个对象根据<code>equals()</code>方法是相等的，那么它们的<code>hashCode()</code>值必须相同。</p>\n<p>如果两个对象的<code>hashCode()</code>值相同，它们不一定是相等的（但它们有可能是相等的）。</p>\n<h4 id=\"String、StringBuffer、StringBuilder-的区别？\"><a class=\"headerlink\" href=\"#String、StringBuffer、StringBuilder-的区别？\"></a>String、StringBuffer、StringBuilder 的区别？</h4>\n<ul>\n<li><strong>String</strong>：不可变的，因为不可变，所以它是线程安全的。</li>\n<li><strong>StringBuffer</strong>：可变的，允许对字符串进行修改，线程安全，所有的方法都被<code>synchronized</code>修饰。</li>\n<li><strong>StringBuilder</strong>：可变的，但不是线程安全的，没有被<code>synchronized</code>修饰。由于没有同步机制，性能比<code>StringBuffer</code>更高，适合单线程环境下使用。</li>\n<li><strong>使用场景</strong>：\n<ul>\n<li>当字符串是固定不变的时候使用<code>String</code>。</li>\n<li>当需要对字符串进行大量修改且在多线程环境下使用<code>StringBuffer</code>。</li>\n<li>当需要对字符串进行大量修改且在单线程环境下使用<code>StringBuilder</code>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"字符串常量池的作用了解吗？\"><a class=\"headerlink\" href=\"#字符串常量池的作用了解吗？\"></a>字符串常量池的作用了解吗？</h4>\n<p>字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，<code>JVM</code>会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。</p>\n<h4 id=\"Exception-和-Error-有什么区别？\"><a class=\"headerlink\" href=\"#Exception-和-Error-有什么区别？\"></a>Exception 和 Error 有什么区别？</h4>\n<ul>\n<li><strong>Exception</strong>和<strong>Error</strong>都是<strong>Throwable</strong>的子类。</li>\n<li><code>Exception</code>是程序本身可以处理的异常，可以通过<code>catch</code>来捕获。<code>Exception</code>还可以分为<code>checked Exception</code>和<code>Unchecked Exception</code>。</li>\n<li><code>Error</code>是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。</li>\n</ul>\n<h4 id=\"Checked-Exception-和-Unchecked-Exception-有什么区别？\"><a class=\"headerlink\" href=\"#Checked-Exception-和-Unchecked-Exception-有什么区别？\"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4>\n<ul>\n<li><strong>Checked Exception</strong>必须被捕获或声明，否则编译器会报错。</li>\n<li><strong>Unchecked Exception</strong>也叫运行时异常，不强制要求处理，但最好捕获处理。</li>\n</ul>\n<h4 id=\"什么是泛型？有什么作用？\"><a class=\"headerlink\" href=\"#什么是泛型？有什么作用？\"></a>什么是泛型？有什么作用？</h4>\n<p>泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息</p>\n<h4 id=\"反射是什么？\"><a class=\"headerlink\" href=\"#反射是什么？\"></a>反射是什么？</h4>\n<p>反射是<code>Java</code>中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。</p>\n<h4 id=\"反射的优缺点？\"><a class=\"headerlink\" href=\"#反射的优缺点？\"></a>反射的优缺点？</h4>\n<ul>\n<li><strong>反射的优点</strong>：\n<ul>\n<li>动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。</li>\n<li>很多流行的<code>Java</code>框架如<code>Spring</code>都依赖反射来实现动态代理、依赖注入。</li>\n</ul>\n</li>\n<li><strong>反射的缺点</strong>：\n<ul>\n<li>反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。</li>\n<li>反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。</li>\n<li>使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。</li>\n<li>反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"何谓注解？\"><a class=\"headerlink\" href=\"#何谓注解？\"></a>何谓注解？</h4>\n<p>注解是<code>Java</code>中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如<code>@Override</code>注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。</p>\n<h4 id=\"什么是序列化？什么是反序列化？\"><a class=\"headerlink\" href=\"#什么是序列化？什么是反序列化？\"></a>什么是序列化？什么是反序列化？</h4>\n<ul>\n<li><strong>序列化</strong>：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。</li>\n<li><strong>反序列化</strong>：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。</li>\n</ul>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"Java集合总结","date":"2024-06-22T08:48:56.000Z","categorizes":"Java","cover":"/img/JavaCollection.png","_content":"\n# Java集合\n\n### 说说 List, Set, Queue, Map 四者的区别？\n\n- `List`：存储的元素是有序的、可重复的。\n\n- `Set`：存储的元素不可重复。\n- `Queue`：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。\n- `Map`：使用键值对存储，`key`是无序的、不可重复的，`value`是无序的、可重复的。\n\n## List\n\n### ArrayList 和 Array （数组）的区别？\n\n- **ArrayList**：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。\n- **Array（数组）**：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。 \n\n### ArrayList 可以添加 null 吗？\n\n`ArrayList`中可以存储任何类型的对象，包括`null`。\n\n#### ArrayList和LinkedList的区别是什么？\n\n- **ArrayList** 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。\n- **LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。\n\n### ArrayList如何去重？\n\n1. **使用HashSet**：通过`HashSet`的特性去重，然后转换回`ArrayList`。\n2. **使用Stream API**：使用Java 8引入的Stream的`distinct()`方法去重。\n3. **手动遍历**：手动遍历`ArrayList`并使用另一个`ArrayList`存储不重复的元素。\n\n\n\n## Map\n\n### HashMap和LinkedHashMap的区别？\n\n`LinkedHashMap`继承自`HashMap`，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。\n\n\n\n### HashMap 和 HashTable 有什么区别？\n\n因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。\n\n\n\n#### 初始化容量和扩容方式：\n\n- **HashMap**：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。\n- **Hashtable**：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1\n\n\n\n### ConcurrentHashMap和Hashtable的区别?\n\n`ConcurrentHashMap`和`Hashtable`都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。\n\n- **实现机制**：\n\n  - `ConcurrentHashMap`采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。\n  - `Hashtable`使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。\n\n  **性能**：\n\n  - `ConcurrentHashMap`性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。\n  - `Hashtable`性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。\n\n  **锁粒度**：\n\n  - `ConcurrentHashMap`锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。\n  - `Hashtable`锁粒度大，所有操作都需要获取全表锁，降低了并发能力。\n\n  **Null键和值**：\n\n  - `ConcurrentHashMap`不允许存储`null`键和`null`值，尝试存储`null`会抛出`NullPointerException`。\n  - `Hashtable`也不允许存储`null`键和`null`值，存储`null`时会抛出`NullPointerException`。\n\n  **迭代器安全性**：\n\n  - `ConcurrentHashMap`提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出`ConcurrentModificationException`，但不保证读取到的值是最新的。\n  - `Hashtable`提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出`ConcurrentModificationException`。\n\n  ### 总结：\n\n  - **ConcurrentHashMap**适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许`null`键和值。\n  - **Hashtable**适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许`null`键和值。\n\n\n\n### HashMap 的底层原理\n\n##### 1. 数据结构\n\n`HashMap`底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。\n\n- **数组**：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。\n- **链表**：是处理哈希冲突（多个键的哈希值相同）。当冲突较少时使用链表存储。\n- **红黑树**：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。\n\n#####  2. 插入元素\n\n1. 计算键的哈希值，并确定在数组中的索引位置。\n2. 检查该位置是否已经有元素：\n   - 如果没有元素，直接插入。\n   - 如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。\n\n##### 3. 查找元素\n\n1. 计算键的哈希值，并确定在数组中的索引位置。\n2. 在该位置的链表或红黑树中查找匹配键，返回对应的值。\n\n##### 4. 删除元素\n\n- 计算键的哈希值，并确定在数组中的索引位置。\n- 在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。\n\n##### 5. 扩容机制\n\n当`HashMap`中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：\n\n1. 创建一个新的数组，容量是原来的两倍。\n2. 将原数组中的所有元素重新哈希并放入新数组中。\n3. 重新调整链表或红黑树结构。\n\n#### 总结\n\n- **数据结构**：`HashMap`使用数组、链表和红黑树存储元素。\n- **哈希算法**：通过键的`hashCode()`计算哈希值，并通过哈希值确定数组索引。\n- **插入元素**：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。\n- **查找元素**：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。\n- **删除元素**：定位到数组索引，删除链表或红黑树中的节点。\n- **扩容机制**：当元素数量超过阈值时，`HashMap`会自动扩容，重新分配数组并调整元素位置。\n","source":"_posts/Java集合八股文.md","raw":"---\ntitle: Java集合总结\ndate: 2024-06-22 16:48:56\ntags: \n   - Java\n   - 笔记\ncategorizes: Java\ncover: /img/JavaCollection.png\n---\n\n# Java集合\n\n### 说说 List, Set, Queue, Map 四者的区别？\n\n- `List`：存储的元素是有序的、可重复的。\n\n- `Set`：存储的元素不可重复。\n- `Queue`：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。\n- `Map`：使用键值对存储，`key`是无序的、不可重复的，`value`是无序的、可重复的。\n\n## List\n\n### ArrayList 和 Array （数组）的区别？\n\n- **ArrayList**：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。\n- **Array（数组）**：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。 \n\n### ArrayList 可以添加 null 吗？\n\n`ArrayList`中可以存储任何类型的对象，包括`null`。\n\n#### ArrayList和LinkedList的区别是什么？\n\n- **ArrayList** 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。\n- **LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。\n\n### ArrayList如何去重？\n\n1. **使用HashSet**：通过`HashSet`的特性去重，然后转换回`ArrayList`。\n2. **使用Stream API**：使用Java 8引入的Stream的`distinct()`方法去重。\n3. **手动遍历**：手动遍历`ArrayList`并使用另一个`ArrayList`存储不重复的元素。\n\n\n\n## Map\n\n### HashMap和LinkedHashMap的区别？\n\n`LinkedHashMap`继承自`HashMap`，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。\n\n\n\n### HashMap 和 HashTable 有什么区别？\n\n因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。\n\n\n\n#### 初始化容量和扩容方式：\n\n- **HashMap**：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。\n- **Hashtable**：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1\n\n\n\n### ConcurrentHashMap和Hashtable的区别?\n\n`ConcurrentHashMap`和`Hashtable`都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。\n\n- **实现机制**：\n\n  - `ConcurrentHashMap`采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。\n  - `Hashtable`使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。\n\n  **性能**：\n\n  - `ConcurrentHashMap`性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。\n  - `Hashtable`性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。\n\n  **锁粒度**：\n\n  - `ConcurrentHashMap`锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。\n  - `Hashtable`锁粒度大，所有操作都需要获取全表锁，降低了并发能力。\n\n  **Null键和值**：\n\n  - `ConcurrentHashMap`不允许存储`null`键和`null`值，尝试存储`null`会抛出`NullPointerException`。\n  - `Hashtable`也不允许存储`null`键和`null`值，存储`null`时会抛出`NullPointerException`。\n\n  **迭代器安全性**：\n\n  - `ConcurrentHashMap`提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出`ConcurrentModificationException`，但不保证读取到的值是最新的。\n  - `Hashtable`提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出`ConcurrentModificationException`。\n\n  ### 总结：\n\n  - **ConcurrentHashMap**适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许`null`键和值。\n  - **Hashtable**适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许`null`键和值。\n\n\n\n### HashMap 的底层原理\n\n##### 1. 数据结构\n\n`HashMap`底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。\n\n- **数组**：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。\n- **链表**：是处理哈希冲突（多个键的哈希值相同）。当冲突较少时使用链表存储。\n- **红黑树**：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。\n\n#####  2. 插入元素\n\n1. 计算键的哈希值，并确定在数组中的索引位置。\n2. 检查该位置是否已经有元素：\n   - 如果没有元素，直接插入。\n   - 如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。\n\n##### 3. 查找元素\n\n1. 计算键的哈希值，并确定在数组中的索引位置。\n2. 在该位置的链表或红黑树中查找匹配键，返回对应的值。\n\n##### 4. 删除元素\n\n- 计算键的哈希值，并确定在数组中的索引位置。\n- 在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。\n\n##### 5. 扩容机制\n\n当`HashMap`中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：\n\n1. 创建一个新的数组，容量是原来的两倍。\n2. 将原数组中的所有元素重新哈希并放入新数组中。\n3. 重新调整链表或红黑树结构。\n\n#### 总结\n\n- **数据结构**：`HashMap`使用数组、链表和红黑树存储元素。\n- **哈希算法**：通过键的`hashCode()`计算哈希值，并通过哈希值确定数组索引。\n- **插入元素**：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。\n- **查找元素**：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。\n- **删除元素**：定位到数组索引，删除链表或红黑树中的节点。\n- **扩容机制**：当元素数量超过阈值时，`HashMap`会自动扩容，重新分配数组并调整元素位置。\n","slug":"Java集合八股文","published":1,"updated":"2024-07-05T14:17:17.141Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gl0007tuj8ckmiabsx","content":"<h1 id=\"Java集合\"><a class=\"headerlink\" href=\"#Java集合\"></a>Java集合</h1>\n<h3 id=\"说说-List-Set-Queue-Map-四者的区别？\"><a class=\"headerlink\" href=\"#说说-List-Set-Queue-Map-四者的区别？\"></a>说说 List, Set, Queue, Map 四者的区别？</h3>\n<ul>\n<li>\n<p><code>List</code>：存储的元素是有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Set</code>：存储的元素不可重复。</p>\n</li>\n<li>\n<p><code>Queue</code>：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Map</code>：使用键值对存储，<code>key</code>是无序的、不可重复的，<code>value</code>是无序的、可重复的。</p>\n</li>\n</ul>\n<h2 id=\"List\"><a class=\"headerlink\" href=\"#List\"></a>List</h2>\n<h3 id=\"ArrayList-和-Array-（数组）的区别？\"><a class=\"headerlink\" href=\"#ArrayList-和-Array-（数组）的区别？\"></a>ArrayList 和 Array （数组）的区别？</h3>\n<ul>\n<li><strong>ArrayList</strong>：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。</li>\n<li><strong>Array（数组）</strong>：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。</li>\n</ul>\n<h3 id=\"ArrayList-可以添加-null-吗？\"><a class=\"headerlink\" href=\"#ArrayList-可以添加-null-吗？\"></a>ArrayList 可以添加 null 吗？</h3>\n<p><code>ArrayList</code>中可以存储任何类型的对象，包括<code>null</code>。</p>\n<h4 id=\"ArrayList和LinkedList的区别是什么？\"><a class=\"headerlink\" href=\"#ArrayList和LinkedList的区别是什么？\"></a>ArrayList和LinkedList的区别是什么？</h4>\n<ul>\n<li><strong>ArrayList</strong> 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。</li>\n<li>**LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。</li>\n</ul>\n<h3 id=\"ArrayList如何去重？\"><a class=\"headerlink\" href=\"#ArrayList如何去重？\"></a>ArrayList如何去重？</h3>\n<ol>\n<li><strong>使用HashSet</strong>：通过<code>HashSet</code>的特性去重，然后转换回<code>ArrayList</code>。</li>\n<li><strong>使用Stream API</strong>：使用Java 8引入的Stream的<code>distinct()</code>方法去重。</li>\n<li><strong>手动遍历</strong>：手动遍历<code>ArrayList</code>并使用另一个<code>ArrayList</code>存储不重复的元素。</li>\n</ol>\n<h2 id=\"Map\"><a class=\"headerlink\" href=\"#Map\"></a>Map</h2>\n<h3 id=\"HashMap和LinkedHashMap的区别？\"><a class=\"headerlink\" href=\"#HashMap和LinkedHashMap的区别？\"></a>HashMap和LinkedHashMap的区别？</h3>\n<p><code>LinkedHashMap</code>继承自<code>HashMap</code>，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。</p>\n<h3 id=\"HashMap-和-HashTable-有什么区别？\"><a class=\"headerlink\" href=\"#HashMap-和-HashTable-有什么区别？\"></a>HashMap 和 HashTable 有什么区别？</h3>\n<p>因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。</p>\n<h4 id=\"初始化容量和扩容方式：\"><a class=\"headerlink\" href=\"#初始化容量和扩容方式：\"></a>初始化容量和扩容方式：</h4>\n<ul>\n<li><strong>HashMap</strong>：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。</li>\n<li><strong>Hashtable</strong>：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1</li>\n</ul>\n<h3 id=\"ConcurrentHashMap和Hashtable的区别\"><a class=\"headerlink\" href=\"#ConcurrentHashMap和Hashtable的区别\"></a>ConcurrentHashMap和Hashtable的区别?</h3>\n<p><code>ConcurrentHashMap</code>和<code>Hashtable</code>都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。</p>\n<ul>\n<li>\n<p><strong>实现机制</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。</li>\n<li><code>Hashtable</code>使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。</li>\n</ul>\n<p><strong>性能</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。</li>\n<li><code>Hashtable</code>性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。</li>\n</ul>\n<p><strong>锁粒度</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。</li>\n<li><code>Hashtable</code>锁粒度大，所有操作都需要获取全表锁，降低了并发能力。</li>\n</ul>\n<p><strong>Null键和值</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>不允许存储<code>null</code>键和<code>null</code>值，尝试存储<code>null</code>会抛出<code>NullPointerException</code>。</li>\n<li><code>Hashtable</code>也不允许存储<code>null</code>键和<code>null</code>值，存储<code>null</code>时会抛出<code>NullPointerException</code>。</li>\n</ul>\n<p><strong>迭代器安全性</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出<code>ConcurrentModificationException</code>，但不保证读取到的值是最新的。</li>\n<li><code>Hashtable</code>提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出<code>ConcurrentModificationException</code>。</li>\n</ul>\n<h3 id=\"总结：\"><a class=\"headerlink\" href=\"#总结：\"></a>总结：</h3>\n<ul>\n<li><strong>ConcurrentHashMap</strong>适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许<code>null</code>键和值。</li>\n<li><strong>Hashtable</strong>适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许<code>null</code>键和值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HashMap-的底层原理\"><a class=\"headerlink\" href=\"#HashMap-的底层原理\"></a>HashMap 的底层原理</h3>\n<h5 id=\"1-数据结构\"><a class=\"headerlink\" href=\"#1-数据结构\"></a>1. 数据结构</h5>\n<p><code>HashMap</code>底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。</p>\n<ul>\n<li><strong>数组</strong>：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。</li>\n<li><strong>链表</strong>：是处理哈希冲突（多个键的哈希值相同）。当冲突较少时使用链表存储。</li>\n<li><strong>红黑树</strong>：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。</li>\n</ul>\n<h5 id=\"2-插入元素\"><a class=\"headerlink\" href=\"#2-插入元素\"></a>2. 插入元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>检查该位置是否已经有元素：\n<ul>\n<li>如果没有元素，直接插入。</li>\n<li>如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"3-查找元素\"><a class=\"headerlink\" href=\"#3-查找元素\"></a>3. 查找元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中查找匹配键，返回对应的值。</li>\n</ol>\n<h5 id=\"4-删除元素\"><a class=\"headerlink\" href=\"#4-删除元素\"></a>4. 删除元素</h5>\n<ul>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。</li>\n</ul>\n<h5 id=\"5-扩容机制\"><a class=\"headerlink\" href=\"#5-扩容机制\"></a>5. 扩容机制</h5>\n<p>当<code>HashMap</code>中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：</p>\n<ol>\n<li>创建一个新的数组，容量是原来的两倍。</li>\n<li>将原数组中的所有元素重新哈希并放入新数组中。</li>\n<li>重新调整链表或红黑树结构。</li>\n</ol>\n<h4 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h4>\n<ul>\n<li><strong>数据结构</strong>：<code>HashMap</code>使用数组、链表和红黑树存储元素。</li>\n<li><strong>哈希算法</strong>：通过键的<code>hashCode()</code>计算哈希值，并通过哈希值确定数组索引。</li>\n<li><strong>插入元素</strong>：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。</li>\n<li><strong>查找元素</strong>：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。</li>\n<li><strong>删除元素</strong>：定位到数组索引，删除链表或红黑树中的节点。</li>\n<li><strong>扩容机制</strong>：当元素数量超过阈值时，<code>HashMap</code>会自动扩容，重新分配数组并调整元素位置。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"Java集合\"><a class=\"headerlink\" href=\"#Java集合\"></a>Java集合</h1>\n<h3 id=\"说说-List-Set-Queue-Map-四者的区别？\"><a class=\"headerlink\" href=\"#说说-List-Set-Queue-Map-四者的区别？\"></a>说说 List, Set, Queue, Map 四者的区别？</h3>\n<ul>\n<li>\n<p><code>List</code>：存储的元素是有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Set</code>：存储的元素不可重复。</p>\n</li>\n<li>\n<p><code>Queue</code>：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Map</code>：使用键值对存储，<code>key</code>是无序的、不可重复的，<code>value</code>是无序的、可重复的。</p>\n</li>\n</ul>\n<h2 id=\"List\"><a class=\"headerlink\" href=\"#List\"></a>List</h2>\n<h3 id=\"ArrayList-和-Array-（数组）的区别？\"><a class=\"headerlink\" href=\"#ArrayList-和-Array-（数组）的区别？\"></a>ArrayList 和 Array （数组）的区别？</h3>\n<ul>\n<li><strong>ArrayList</strong>：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。</li>\n<li><strong>Array（数组）</strong>：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。</li>\n</ul>\n<h3 id=\"ArrayList-可以添加-null-吗？\"><a class=\"headerlink\" href=\"#ArrayList-可以添加-null-吗？\"></a>ArrayList 可以添加 null 吗？</h3>\n<p><code>ArrayList</code>中可以存储任何类型的对象，包括<code>null</code>。</p>\n<h4 id=\"ArrayList和LinkedList的区别是什么？\"><a class=\"headerlink\" href=\"#ArrayList和LinkedList的区别是什么？\"></a>ArrayList和LinkedList的区别是什么？</h4>\n<ul>\n<li><strong>ArrayList</strong> 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。</li>\n<li>**LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。</li>\n</ul>\n<h3 id=\"ArrayList如何去重？\"><a class=\"headerlink\" href=\"#ArrayList如何去重？\"></a>ArrayList如何去重？</h3>\n<ol>\n<li><strong>使用HashSet</strong>：通过<code>HashSet</code>的特性去重，然后转换回<code>ArrayList</code>。</li>\n<li><strong>使用Stream API</strong>：使用Java 8引入的Stream的<code>distinct()</code>方法去重。</li>\n<li><strong>手动遍历</strong>：手动遍历<code>ArrayList</code>并使用另一个<code>ArrayList</code>存储不重复的元素。</li>\n</ol>\n<h2 id=\"Map\"><a class=\"headerlink\" href=\"#Map\"></a>Map</h2>\n<h3 id=\"HashMap和LinkedHashMap的区别？\"><a class=\"headerlink\" href=\"#HashMap和LinkedHashMap的区别？\"></a>HashMap和LinkedHashMap的区别？</h3>\n<p><code>LinkedHashMap</code>继承自<code>HashMap</code>，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。</p>\n<h3 id=\"HashMap-和-HashTable-有什么区别？\"><a class=\"headerlink\" href=\"#HashMap-和-HashTable-有什么区别？\"></a>HashMap 和 HashTable 有什么区别？</h3>\n<p>因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。</p>\n<h4 id=\"初始化容量和扩容方式：\"><a class=\"headerlink\" href=\"#初始化容量和扩容方式：\"></a>初始化容量和扩容方式：</h4>\n<ul>\n<li><strong>HashMap</strong>：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。</li>\n<li><strong>Hashtable</strong>：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1</li>\n</ul>\n<h3 id=\"ConcurrentHashMap和Hashtable的区别\"><a class=\"headerlink\" href=\"#ConcurrentHashMap和Hashtable的区别\"></a>ConcurrentHashMap和Hashtable的区别?</h3>\n<p><code>ConcurrentHashMap</code>和<code>Hashtable</code>都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。</p>\n<ul>\n<li>\n<p><strong>实现机制</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。</li>\n<li><code>Hashtable</code>使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。</li>\n</ul>\n<p><strong>性能</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。</li>\n<li><code>Hashtable</code>性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。</li>\n</ul>\n<p><strong>锁粒度</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。</li>\n<li><code>Hashtable</code>锁粒度大，所有操作都需要获取全表锁，降低了并发能力。</li>\n</ul>\n<p><strong>Null键和值</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>不允许存储<code>null</code>键和<code>null</code>值，尝试存储<code>null</code>会抛出<code>NullPointerException</code>。</li>\n<li><code>Hashtable</code>也不允许存储<code>null</code>键和<code>null</code>值，存储<code>null</code>时会抛出<code>NullPointerException</code>。</li>\n</ul>\n<p><strong>迭代器安全性</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出<code>ConcurrentModificationException</code>，但不保证读取到的值是最新的。</li>\n<li><code>Hashtable</code>提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出<code>ConcurrentModificationException</code>。</li>\n</ul>\n<h3 id=\"总结：\"><a class=\"headerlink\" href=\"#总结：\"></a>总结：</h3>\n<ul>\n<li><strong>ConcurrentHashMap</strong>适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许<code>null</code>键和值。</li>\n<li><strong>Hashtable</strong>适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许<code>null</code>键和值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HashMap-的底层原理\"><a class=\"headerlink\" href=\"#HashMap-的底层原理\"></a>HashMap 的底层原理</h3>\n<h5 id=\"1-数据结构\"><a class=\"headerlink\" href=\"#1-数据结构\"></a>1. 数据结构</h5>\n<p><code>HashMap</code>底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。</p>\n<ul>\n<li><strong>数组</strong>：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。</li>\n<li><strong>链表</strong>：是处理哈希冲突（多个键的哈希值相同）。当冲突较少时使用链表存储。</li>\n<li><strong>红黑树</strong>：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。</li>\n</ul>\n<h5 id=\"2-插入元素\"><a class=\"headerlink\" href=\"#2-插入元素\"></a>2. 插入元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>检查该位置是否已经有元素：\n<ul>\n<li>如果没有元素，直接插入。</li>\n<li>如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"3-查找元素\"><a class=\"headerlink\" href=\"#3-查找元素\"></a>3. 查找元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中查找匹配键，返回对应的值。</li>\n</ol>\n<h5 id=\"4-删除元素\"><a class=\"headerlink\" href=\"#4-删除元素\"></a>4. 删除元素</h5>\n<ul>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。</li>\n</ul>\n<h5 id=\"5-扩容机制\"><a class=\"headerlink\" href=\"#5-扩容机制\"></a>5. 扩容机制</h5>\n<p>当<code>HashMap</code>中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：</p>\n<ol>\n<li>创建一个新的数组，容量是原来的两倍。</li>\n<li>将原数组中的所有元素重新哈希并放入新数组中。</li>\n<li>重新调整链表或红黑树结构。</li>\n</ol>\n<h4 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h4>\n<ul>\n<li><strong>数据结构</strong>：<code>HashMap</code>使用数组、链表和红黑树存储元素。</li>\n<li><strong>哈希算法</strong>：通过键的<code>hashCode()</code>计算哈希值，并通过哈希值确定数组索引。</li>\n<li><strong>插入元素</strong>：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。</li>\n<li><strong>查找元素</strong>：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。</li>\n<li><strong>删除元素</strong>：定位到数组索引，删除链表或红黑树中的节点。</li>\n<li><strong>扩容机制</strong>：当元素数量超过阈值时，<code>HashMap</code>会自动扩容，重新分配数组并调整元素位置。</li>\n</ul>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"Linux安装MySQL","date":"2024-06-25T04:18:14.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E7%89%B9%E5%86%99%E3%80%912024-06-25%2012_21_11.png","_content":"\n# 如何在Ubuntu上安装和配置MySQL并允许远程访问\n\n在本文中，我们将介绍如何在Ubuntu上安装和配置MySQL，并设置允许远程访问。我们将从安装MySQL开始，然后进行基本的安全配置，修改MySQL配置文件以允许远程连接，并创建可以远程访问的用户。\n\n## 步骤1：更新包列表并安装MySQL服务器\n\n首先，确保你的包列表是最新的：\n\n```bash\nsudo apt update\n```\n\n然后安装MySQL服务器：\n\n```bash\nsudo apt install mysql-server\n```\n\n如果你需要安装特定版本的MySQL（例如8.0），可以使用以下命令：\n\n```bash\nsudo apt install -y mysql-server-8.0\n```\n\n## 步骤2：检查MySQL服务状态并启用MySQL服务\n\n检查MySQL服务是否正在运行：\n\n```bash\nsudo systemctl status mysql\n```\n\n确保MySQL服务在系统启动时自动启动：\n\n```bash\nsudo systemctl enable mysql\n```\n\n## 步骤3：运行安全安装脚本\n\nMySQL提供了一个安全安装脚本，可以帮助你进行一些基本的安全配置。运行以下命令：\n\n```bash\nsudo mysql_secure_installation\n```\n\n在提示中，你将需要：\n\n- 选择密码规则\n- 删除匿名用户\n- 禁用远程root登录\n- 删除测试数据库和表\n\n## 步骤4：修改MySQL配置文件以允许远程连接\n\n打开MySQL配置文件`mysqld.cnf`，通常位于`/etc/mysql/mysql.conf.d/`目录中：\n\n```bash\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n找到以下行：\n\n```plaintext\nbind-address = 127.0.0.1\n```\n\n将其注释掉或改为`0.0.0.0`，使MySQL监听所有网络接口：\n\n```plaintext\n# bind-address = 127.0.0.1\nbind-address = 0.0.0.0\n```\n\n保存配置文件并退出编辑器。\n\n## 步骤5：重启MySQL服务\n\n重启MySQL服务以使更改生效：\n\n```bash\nsudo systemctl restart mysql\n```\n\n## 步骤6：创建可以远程访问的用户\n\n登录到MySQL命令行：\n\n```bash\nmysql -u root -p\n```\n\n在MySQL提示符中运行以下命令，创建一个允许从任何IP地址连接的用户，并授予所有权限：\n\n```sql\nCREATE USER 'yourusername'@'%' IDENTIFIED BY 'yourpassword';\nGRANT ALL PRIVILEGES ON *.* TO 'yourusername'@'%' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n\n**解释：**\n\n- **GRANT ALL PRIVILEGES**：授予用户所有权限，包括SELECT、INSERT、UPDATE、DELETE、CREATE、DROP等操作权限。\n- **ON**：授予权限的范围。`*.*`表示所有数据库和所有表。\n- **TO**：指定权限接收者。`'yourusername'`是用户名，`'%'`是主机名通配符，表示允许从任何IP地址连接的用户。\n- **WITH GRANT OPTION**：允许用户将他自己拥有的权限授予其他用户。\n\n## 步骤7：配置防火墙\n\n确保防火墙允许MySQL的默认端口3306的流量。如果使用的是UFW（Uncomplicated Firewall），可以运行以下命令：\n\n```bash\nsudo ufw allow 3306\nsudo ufw reload\n```\n\n## 步骤8：验证远程连接\n\n在远程机器上，使用MySQL客户端或其他工具连接到MySQL服务器：\n\n```bash\nmysql -u yourusername -p -h your_server_ip\n```\n\n## 其他操作\n\n### 删除某些权限或用户\n\n如果你想删除某些权限，或者从特定数据库中删除权限，可以使用`REVOKE`命令。例如：\n\n```sql\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 'existinguser'@'%';\n```\n\n### 查看某个用户的当前权限\n\n如果你想查看某个用户的当前权限，可以使用以下命令：\n\n```sql\nSHOW GRANTS FOR 'existinguser'@'%';\n```\n\n通过这些步骤，你可以在Ubuntu上成功安装和配置MySQL，并设置允许远程访问。如果遇到任何问题或需要进一步帮助，请随时在评论区留言！\n","source":"_posts/Linux安装MySQL.md","raw":"---\ntitle: Linux安装MySQL\ndate: 2024-06-25 12:18:14\ntags:\n    - MySQL\n    - Linux\ncategories: \n    - Linux\n    - MySQL\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E7%89%B9%E5%86%99%E3%80%912024-06-25%2012_21_11.png\n---\n\n# 如何在Ubuntu上安装和配置MySQL并允许远程访问\n\n在本文中，我们将介绍如何在Ubuntu上安装和配置MySQL，并设置允许远程访问。我们将从安装MySQL开始，然后进行基本的安全配置，修改MySQL配置文件以允许远程连接，并创建可以远程访问的用户。\n\n## 步骤1：更新包列表并安装MySQL服务器\n\n首先，确保你的包列表是最新的：\n\n```bash\nsudo apt update\n```\n\n然后安装MySQL服务器：\n\n```bash\nsudo apt install mysql-server\n```\n\n如果你需要安装特定版本的MySQL（例如8.0），可以使用以下命令：\n\n```bash\nsudo apt install -y mysql-server-8.0\n```\n\n## 步骤2：检查MySQL服务状态并启用MySQL服务\n\n检查MySQL服务是否正在运行：\n\n```bash\nsudo systemctl status mysql\n```\n\n确保MySQL服务在系统启动时自动启动：\n\n```bash\nsudo systemctl enable mysql\n```\n\n## 步骤3：运行安全安装脚本\n\nMySQL提供了一个安全安装脚本，可以帮助你进行一些基本的安全配置。运行以下命令：\n\n```bash\nsudo mysql_secure_installation\n```\n\n在提示中，你将需要：\n\n- 选择密码规则\n- 删除匿名用户\n- 禁用远程root登录\n- 删除测试数据库和表\n\n## 步骤4：修改MySQL配置文件以允许远程连接\n\n打开MySQL配置文件`mysqld.cnf`，通常位于`/etc/mysql/mysql.conf.d/`目录中：\n\n```bash\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n找到以下行：\n\n```plaintext\nbind-address = 127.0.0.1\n```\n\n将其注释掉或改为`0.0.0.0`，使MySQL监听所有网络接口：\n\n```plaintext\n# bind-address = 127.0.0.1\nbind-address = 0.0.0.0\n```\n\n保存配置文件并退出编辑器。\n\n## 步骤5：重启MySQL服务\n\n重启MySQL服务以使更改生效：\n\n```bash\nsudo systemctl restart mysql\n```\n\n## 步骤6：创建可以远程访问的用户\n\n登录到MySQL命令行：\n\n```bash\nmysql -u root -p\n```\n\n在MySQL提示符中运行以下命令，创建一个允许从任何IP地址连接的用户，并授予所有权限：\n\n```sql\nCREATE USER 'yourusername'@'%' IDENTIFIED BY 'yourpassword';\nGRANT ALL PRIVILEGES ON *.* TO 'yourusername'@'%' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n\n**解释：**\n\n- **GRANT ALL PRIVILEGES**：授予用户所有权限，包括SELECT、INSERT、UPDATE、DELETE、CREATE、DROP等操作权限。\n- **ON**：授予权限的范围。`*.*`表示所有数据库和所有表。\n- **TO**：指定权限接收者。`'yourusername'`是用户名，`'%'`是主机名通配符，表示允许从任何IP地址连接的用户。\n- **WITH GRANT OPTION**：允许用户将他自己拥有的权限授予其他用户。\n\n## 步骤7：配置防火墙\n\n确保防火墙允许MySQL的默认端口3306的流量。如果使用的是UFW（Uncomplicated Firewall），可以运行以下命令：\n\n```bash\nsudo ufw allow 3306\nsudo ufw reload\n```\n\n## 步骤8：验证远程连接\n\n在远程机器上，使用MySQL客户端或其他工具连接到MySQL服务器：\n\n```bash\nmysql -u yourusername -p -h your_server_ip\n```\n\n## 其他操作\n\n### 删除某些权限或用户\n\n如果你想删除某些权限，或者从特定数据库中删除权限，可以使用`REVOKE`命令。例如：\n\n```sql\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 'existinguser'@'%';\n```\n\n### 查看某个用户的当前权限\n\n如果你想查看某个用户的当前权限，可以使用以下命令：\n\n```sql\nSHOW GRANTS FOR 'existinguser'@'%';\n```\n\n通过这些步骤，你可以在Ubuntu上成功安装和配置MySQL，并设置允许远程访问。如果遇到任何问题或需要进一步帮助，请随时在评论区留言！\n","slug":"Linux安装MySQL","published":1,"updated":"2024-07-11T10:16:34.889Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gm0008tuj8hfaefxuj","content":"<h1 id=\"如何在Ubuntu上安装和配置MySQL并允许远程访问\"><a class=\"headerlink\" href=\"#如何在Ubuntu上安装和配置MySQL并允许远程访问\"></a>如何在Ubuntu上安装和配置MySQL并允许远程访问</h1>\n<p>在本文中，我们将介绍如何在Ubuntu上安装和配置MySQL，并设置允许远程访问。我们将从安装MySQL开始，然后进行基本的安全配置，修改MySQL配置文件以允许远程连接，并创建可以远程访问的用户。</p>\n<h2 id=\"步骤1：更新包列表并安装MySQL服务器\"><a class=\"headerlink\" href=\"#步骤1：更新包列表并安装MySQL服务器\"></a>步骤1：更新包列表并安装MySQL服务器</h2>\n<p>首先，确保你的包列表是最新的：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后安装MySQL服务器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> mysql-server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果你需要安装特定版本的MySQL（例如8.0），可以使用以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> mysql-server-8.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"步骤2：检查MySQL服务状态并启用MySQL服务\"><a class=\"headerlink\" href=\"#步骤2：检查MySQL服务状态并启用MySQL服务\"></a>步骤2：检查MySQL服务状态并启用MySQL服务</h2>\n<p>检查MySQL服务是否正在运行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl status mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>确保MySQL服务在系统启动时自动启动：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl <span class=\"token builtin class-name\">enable</span> mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"步骤3：运行安全安装脚本\"><a class=\"headerlink\" href=\"#步骤3：运行安全安装脚本\"></a>步骤3：运行安全安装脚本</h2>\n<p>MySQL提供了一个安全安装脚本，可以帮助你进行一些基本的安全配置。运行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> mysql_secure_installation<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在提示中，你将需要：</p>\n<ul>\n<li>选择密码规则</li>\n<li>删除匿名用户</li>\n<li>禁用远程root登录</li>\n<li>删除测试数据库和表</li>\n</ul>\n<h2 id=\"步骤4：修改MySQL配置文件以允许远程连接\"><a class=\"headerlink\" href=\"#步骤4：修改MySQL配置文件以允许远程连接\"></a>步骤4：修改MySQL配置文件以允许远程连接</h2>\n<p>打开MySQL配置文件<code>mysqld.cnf</code>，通常位于<code>/etc/mysql/mysql.conf.d/</code>目录中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /etc/mysql/mysql.conf.d/mysqld.cnf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>找到以下行：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bind-address &#x3D; 127.0.0.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>将其注释掉或改为<code>0.0.0.0</code>，使MySQL监听所有网络接口：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># bind-address &#x3D; 127.0.0.1\nbind-address &#x3D; 0.0.0.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>保存配置文件并退出编辑器。</p>\n<h2 id=\"步骤5：重启MySQL服务\"><a class=\"headerlink\" href=\"#步骤5：重启MySQL服务\"></a>步骤5：重启MySQL服务</h2>\n<p>重启MySQL服务以使更改生效：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"步骤6：创建可以远程访问的用户\"><a class=\"headerlink\" href=\"#步骤6：创建可以远程访问的用户\"></a>步骤6：创建可以远程访问的用户</h2>\n<p>登录到MySQL命令行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysql <span class=\"token parameter variable\">-u</span> root <span class=\"token parameter variable\">-p</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在MySQL提示符中运行以下命令，创建一个允许从任何IP地址连接的用户，并授予所有权限：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">USER</span> <span class=\"token string\">'yourusername'</span><span class=\"token variable\">@'%'</span> IDENTIFIED <span class=\"token keyword\">BY</span> <span class=\"token string\">'yourpassword'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">PRIVILEGES</span> <span class=\"token keyword\">ON</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">TO</span> <span class=\"token string\">'yourusername'</span><span class=\"token variable\">@'%'</span> <span class=\"token keyword\">WITH</span> <span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">OPTION</span><span class=\"token punctuation\">;</span>\nFLUSH <span class=\"token keyword\">PRIVILEGES</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>解释：</strong></p>\n<ul>\n<li><strong>GRANT ALL PRIVILEGES</strong>：授予用户所有权限，包括SELECT、INSERT、UPDATE、DELETE、CREATE、DROP等操作权限。</li>\n<li><strong>ON</strong>：授予权限的范围。<code>*.*</code>表示所有数据库和所有表。</li>\n<li><strong>TO</strong>：指定权限接收者。<code>'yourusername'</code>是用户名，<code>'%'</code>是主机名通配符，表示允许从任何IP地址连接的用户。</li>\n<li><strong>WITH GRANT OPTION</strong>：允许用户将他自己拥有的权限授予其他用户。</li>\n</ul>\n<h2 id=\"步骤7：配置防火墙\"><a class=\"headerlink\" href=\"#步骤7：配置防火墙\"></a>步骤7：配置防火墙</h2>\n<p>确保防火墙允许MySQL的默认端口3306的流量。如果使用的是UFW（Uncomplicated Firewall），可以运行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">3306</span>\n<span class=\"token function\">sudo</span> ufw reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"步骤8：验证远程连接\"><a class=\"headerlink\" href=\"#步骤8：验证远程连接\"></a>步骤8：验证远程连接</h2>\n<p>在远程机器上，使用MySQL客户端或其他工具连接到MySQL服务器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysql <span class=\"token parameter variable\">-u</span> yourusername <span class=\"token parameter variable\">-p</span> <span class=\"token parameter variable\">-h</span> your_server_ip<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"其他操作\"><a class=\"headerlink\" href=\"#其他操作\"></a>其他操作</h2>\n<h3 id=\"删除某些权限或用户\"><a class=\"headerlink\" href=\"#删除某些权限或用户\"></a>删除某些权限或用户</h3>\n<p>如果你想删除某些权限，或者从特定数据库中删除权限，可以使用<code>REVOKE</code>命令。例如：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">REVOKE</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">PRIVILEGES</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">OPTION</span> <span class=\"token keyword\">FROM</span> <span class=\"token string\">'existinguser'</span><span class=\"token variable\">@'%'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"查看某个用户的当前权限\"><a class=\"headerlink\" href=\"#查看某个用户的当前权限\"></a>查看某个用户的当前权限</h3>\n<p>如果你想查看某个用户的当前权限，可以使用以下命令：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> GRANTS <span class=\"token keyword\">FOR</span> <span class=\"token string\">'existinguser'</span><span class=\"token variable\">@'%'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>通过这些步骤，你可以在Ubuntu上成功安装和配置MySQL，并设置允许远程访问。如果遇到任何问题或需要进一步帮助，请随时在评论区留言！</p>\n","excerpt":"","more":"<h1 id=\"如何在Ubuntu上安装和配置MySQL并允许远程访问\"><a class=\"headerlink\" href=\"#如何在Ubuntu上安装和配置MySQL并允许远程访问\"></a>如何在Ubuntu上安装和配置MySQL并允许远程访问</h1>\n<p>在本文中，我们将介绍如何在Ubuntu上安装和配置MySQL，并设置允许远程访问。我们将从安装MySQL开始，然后进行基本的安全配置，修改MySQL配置文件以允许远程连接，并创建可以远程访问的用户。</p>\n<h2 id=\"步骤1：更新包列表并安装MySQL服务器\"><a class=\"headerlink\" href=\"#步骤1：更新包列表并安装MySQL服务器\"></a>步骤1：更新包列表并安装MySQL服务器</h2>\n<p>首先，确保你的包列表是最新的：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后安装MySQL服务器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> mysql-server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果你需要安装特定版本的MySQL（例如8.0），可以使用以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> mysql-server-8.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"步骤2：检查MySQL服务状态并启用MySQL服务\"><a class=\"headerlink\" href=\"#步骤2：检查MySQL服务状态并启用MySQL服务\"></a>步骤2：检查MySQL服务状态并启用MySQL服务</h2>\n<p>检查MySQL服务是否正在运行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl status mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>确保MySQL服务在系统启动时自动启动：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl <span class=\"token builtin class-name\">enable</span> mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"步骤3：运行安全安装脚本\"><a class=\"headerlink\" href=\"#步骤3：运行安全安装脚本\"></a>步骤3：运行安全安装脚本</h2>\n<p>MySQL提供了一个安全安装脚本，可以帮助你进行一些基本的安全配置。运行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> mysql_secure_installation<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在提示中，你将需要：</p>\n<ul>\n<li>选择密码规则</li>\n<li>删除匿名用户</li>\n<li>禁用远程root登录</li>\n<li>删除测试数据库和表</li>\n</ul>\n<h2 id=\"步骤4：修改MySQL配置文件以允许远程连接\"><a class=\"headerlink\" href=\"#步骤4：修改MySQL配置文件以允许远程连接\"></a>步骤4：修改MySQL配置文件以允许远程连接</h2>\n<p>打开MySQL配置文件<code>mysqld.cnf</code>，通常位于<code>/etc/mysql/mysql.conf.d/</code>目录中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /etc/mysql/mysql.conf.d/mysqld.cnf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>找到以下行：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bind-address &#x3D; 127.0.0.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>将其注释掉或改为<code>0.0.0.0</code>，使MySQL监听所有网络接口：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># bind-address &#x3D; 127.0.0.1\nbind-address &#x3D; 0.0.0.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>保存配置文件并退出编辑器。</p>\n<h2 id=\"步骤5：重启MySQL服务\"><a class=\"headerlink\" href=\"#步骤5：重启MySQL服务\"></a>步骤5：重启MySQL服务</h2>\n<p>重启MySQL服务以使更改生效：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"步骤6：创建可以远程访问的用户\"><a class=\"headerlink\" href=\"#步骤6：创建可以远程访问的用户\"></a>步骤6：创建可以远程访问的用户</h2>\n<p>登录到MySQL命令行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysql <span class=\"token parameter variable\">-u</span> root <span class=\"token parameter variable\">-p</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在MySQL提示符中运行以下命令，创建一个允许从任何IP地址连接的用户，并授予所有权限：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">USER</span> <span class=\"token string\">'yourusername'</span><span class=\"token variable\">@'%'</span> IDENTIFIED <span class=\"token keyword\">BY</span> <span class=\"token string\">'yourpassword'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">PRIVILEGES</span> <span class=\"token keyword\">ON</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">TO</span> <span class=\"token string\">'yourusername'</span><span class=\"token variable\">@'%'</span> <span class=\"token keyword\">WITH</span> <span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">OPTION</span><span class=\"token punctuation\">;</span>\nFLUSH <span class=\"token keyword\">PRIVILEGES</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>解释：</strong></p>\n<ul>\n<li><strong>GRANT ALL PRIVILEGES</strong>：授予用户所有权限，包括SELECT、INSERT、UPDATE、DELETE、CREATE、DROP等操作权限。</li>\n<li><strong>ON</strong>：授予权限的范围。<code>*.*</code>表示所有数据库和所有表。</li>\n<li><strong>TO</strong>：指定权限接收者。<code>'yourusername'</code>是用户名，<code>'%'</code>是主机名通配符，表示允许从任何IP地址连接的用户。</li>\n<li><strong>WITH GRANT OPTION</strong>：允许用户将他自己拥有的权限授予其他用户。</li>\n</ul>\n<h2 id=\"步骤7：配置防火墙\"><a class=\"headerlink\" href=\"#步骤7：配置防火墙\"></a>步骤7：配置防火墙</h2>\n<p>确保防火墙允许MySQL的默认端口3306的流量。如果使用的是UFW（Uncomplicated Firewall），可以运行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">3306</span>\n<span class=\"token function\">sudo</span> ufw reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"步骤8：验证远程连接\"><a class=\"headerlink\" href=\"#步骤8：验证远程连接\"></a>步骤8：验证远程连接</h2>\n<p>在远程机器上，使用MySQL客户端或其他工具连接到MySQL服务器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysql <span class=\"token parameter variable\">-u</span> yourusername <span class=\"token parameter variable\">-p</span> <span class=\"token parameter variable\">-h</span> your_server_ip<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"其他操作\"><a class=\"headerlink\" href=\"#其他操作\"></a>其他操作</h2>\n<h3 id=\"删除某些权限或用户\"><a class=\"headerlink\" href=\"#删除某些权限或用户\"></a>删除某些权限或用户</h3>\n<p>如果你想删除某些权限，或者从特定数据库中删除权限，可以使用<code>REVOKE</code>命令。例如：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">REVOKE</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">PRIVILEGES</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">OPTION</span> <span class=\"token keyword\">FROM</span> <span class=\"token string\">'existinguser'</span><span class=\"token variable\">@'%'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"查看某个用户的当前权限\"><a class=\"headerlink\" href=\"#查看某个用户的当前权限\"></a>查看某个用户的当前权限</h3>\n<p>如果你想查看某个用户的当前权限，可以使用以下命令：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> GRANTS <span class=\"token keyword\">FOR</span> <span class=\"token string\">'existinguser'</span><span class=\"token variable\">@'%'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>通过这些步骤，你可以在Ubuntu上成功安装和配置MySQL，并设置允许远程访问。如果遇到任何问题或需要进一步帮助，请随时在评论区留言！</p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"MyBatis应用与总结","date":"2024-06-26T09:53:37.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E5%B9%B2%E7%89%A9%E5%A6%B9%E5%B0%8F%E5%9F%8B%E3%80%912024-06-26%2017_55_33.png","_content":"\n# MyBatis常见面试题总结\n\n### #{} 和 ${} 的区别是什么？\n\n- `${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 slq 内部，属于原样文本替换，可以替换任意内容。\n- `#{}`是 sql 的参数占位符，Mybatis 会将 sql 中`#{}`替换为？号，在 sql 执行前会使用PreparedStatement 的参数设置方法，按序给 sql 的 ？号占位符设置参数值。使用`#{}`可以有效防止 sql 注入。\n\n","source":"_posts/MyBatis八股文.md","raw":"---\ntitle: MyBatis应用与总结\ndate: 2024-06-26 17:53:37\ntags:\n  - Java\n  - MyBatis\n  - 总结\ncategories: Java\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E5%B9%B2%E7%89%A9%E5%A6%B9%E5%B0%8F%E5%9F%8B%E3%80%912024-06-26%2017_55_33.png\n---\n\n# MyBatis常见面试题总结\n\n### #{} 和 ${} 的区别是什么？\n\n- `${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 slq 内部，属于原样文本替换，可以替换任意内容。\n- `#{}`是 sql 的参数占位符，Mybatis 会将 sql 中`#{}`替换为？号，在 sql 执行前会使用PreparedStatement 的参数设置方法，按序给 sql 的 ？号占位符设置参数值。使用`#{}`可以有效防止 sql 注入。\n\n","slug":"MyBatis八股文","published":1,"updated":"2024-07-11T10:16:11.952Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gn0009tuj88jie57tz","content":"<h1 id=\"MyBatis常见面试题总结\"><a class=\"headerlink\" href=\"#MyBatis常见面试题总结\"></a>MyBatis常见面试题总结</h1>\n<h3 id=\"和-的区别是什么？\"><a class=\"headerlink\" href=\"#和-的区别是什么？\"></a>#{} 和 ${} 的区别是什么？</h3>\n<ul>\n<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 slq 内部，属于原样文本替换，可以替换任意内容。</li>\n<li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中<code>#&#123;&#125;</code>替换为？号，在 sql 执行前会使用PreparedStatement 的参数设置方法，按序给 sql 的 ？号占位符设置参数值。使用<code>#&#123;&#125;</code>可以有效防止 sql 注入。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"MyBatis常见面试题总结\"><a class=\"headerlink\" href=\"#MyBatis常见面试题总结\"></a>MyBatis常见面试题总结</h1>\n<h3 id=\"和-的区别是什么？\"><a class=\"headerlink\" href=\"#和-的区别是什么？\"></a>#{} 和 ${} 的区别是什么？</h3>\n<ul>\n<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 slq 内部，属于原样文本替换，可以替换任意内容。</li>\n<li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中<code>#&#123;&#125;</code>替换为？号，在 sql 执行前会使用PreparedStatement 的参数设置方法，按序给 sql 的 ？号占位符设置参数值。使用<code>#&#123;&#125;</code>可以有效防止 sql 注入。</li>\n</ul>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"MySQL应用与总结","date":"2024-06-22T10:02:39.000Z","cover":"/img/mysqlbaguwen.png","_content":"\n# 数据库\n\n## 索引\n\n### 为什么使用索引会加快查询？\n\n数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。\n\n有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。\n\nMySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。\n\n索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。\n\n索引就好像书的目录，通过目录去查找对应的章节内容会比一页一页的翻书快很多。\n\n### MySQL中的索引有哪些类型？\n\n- **B-Tree索引**：是MySQL中最常用的索引类型。适用于等值查询、范围查询、排序和分组操作。B-Tree索引的优点是查询效率高，尤其适合范围查询和排序操作，但对于频繁更新的列，索引维护成本较高。\n- **哈希索引**：通过哈希函数将键值映射到哈希表的位置，查找速度非常快。它适用于等值查询，但不支持范围查询、排序和分组。此外，哈希冲突会降低性能。\n- **全文索引**：用于全文搜索，支持对文本字段的关键词查询。它适合需要全文检索的场景，如搜索引擎和文章内容搜索，全文检索速度快，但建立和维护成本高，不适合实时更新的数据。\n- **空间索引**：（R-Tree索引）用于地理信息系统中的空间查询，适合多维数据的快速查询，如地理位置查询和地图服务。它能够有效地进行范围查询和最近邻查询，但不适合其他类型的数据，且建立和维护成本较高。\n- **前缀索引**：是对字符串类型的列的前几个字符创建索引，适用于字符串列较长且前缀部分区分度较高的场景。它能节省索引空间并提高查询效率，但只适用于前缀匹配查询，不支持全文匹配。\n- **聚簇索引**：决定数据在磁盘上的物理存储顺序，每个表只能有一个聚簇索引，通常是主键。它的数据访问速度快，特别适合范围查询，但更新开销较大，且非聚簇索引需要包含聚簇索引列作为引用。\n- **非聚簇索引**：的索引和数据分别存储，叶节点存储指向数据的指针。它的更新开销较小，可以有多个非聚簇索引，但查询时需要先访问索引再访问数据，速度略慢于聚簇索引。\n- **唯一索引**：确保索引列中的值是唯一的，适用于需要唯一性约束的场景，如用户名、电子邮件地址等。它能确保数据的唯一性，防止重复数据，但插入和更新时需要检查唯一性，开销较大。\n- **组合索引**：是对多个列创建的索引，能够提高多列查询的效率，适用于WHERE子句中涉及多列的查询。它能显著提高查询效率，但索引创建和维护成本较高，且需要考虑索引的顺序。\n\n## 日志\n\n### MySQL 日志文件有哪些？\n\n1. **错误日志**：记录 MySQL 服务器启动、运行或停止时出现的问题。\n2. **慢查询日志**：记录执行时间超过`long_query_time`值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。\n3. **一般查询日志**：记录所有 MySQL 服务器的链接信息以及所有的 SQL 语句，不论这些语句是否修改了数据。\n4. **二进制日志**：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。\n5. **重做日志**：记录对于`InnDB`表的每个写操作，不是 SQL 级的，而是物理级别的，主要用于崩溃恢复。\n6. **回滚日志**：记录数据被修改前的值，用于事务回滚。\n\n","source":"_posts/Myql八股文.md","raw":"---\ntitle: MySQL应用与总结\ndate: 2024-06-22 18:02:39\ntags:\n  - MySQL\n  - 总结\ncategories: MySQL\ncover: /img/mysqlbaguwen.png\n---\n\n# 数据库\n\n## 索引\n\n### 为什么使用索引会加快查询？\n\n数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。\n\n有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。\n\nMySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。\n\n索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。\n\n索引就好像书的目录，通过目录去查找对应的章节内容会比一页一页的翻书快很多。\n\n### MySQL中的索引有哪些类型？\n\n- **B-Tree索引**：是MySQL中最常用的索引类型。适用于等值查询、范围查询、排序和分组操作。B-Tree索引的优点是查询效率高，尤其适合范围查询和排序操作，但对于频繁更新的列，索引维护成本较高。\n- **哈希索引**：通过哈希函数将键值映射到哈希表的位置，查找速度非常快。它适用于等值查询，但不支持范围查询、排序和分组。此外，哈希冲突会降低性能。\n- **全文索引**：用于全文搜索，支持对文本字段的关键词查询。它适合需要全文检索的场景，如搜索引擎和文章内容搜索，全文检索速度快，但建立和维护成本高，不适合实时更新的数据。\n- **空间索引**：（R-Tree索引）用于地理信息系统中的空间查询，适合多维数据的快速查询，如地理位置查询和地图服务。它能够有效地进行范围查询和最近邻查询，但不适合其他类型的数据，且建立和维护成本较高。\n- **前缀索引**：是对字符串类型的列的前几个字符创建索引，适用于字符串列较长且前缀部分区分度较高的场景。它能节省索引空间并提高查询效率，但只适用于前缀匹配查询，不支持全文匹配。\n- **聚簇索引**：决定数据在磁盘上的物理存储顺序，每个表只能有一个聚簇索引，通常是主键。它的数据访问速度快，特别适合范围查询，但更新开销较大，且非聚簇索引需要包含聚簇索引列作为引用。\n- **非聚簇索引**：的索引和数据分别存储，叶节点存储指向数据的指针。它的更新开销较小，可以有多个非聚簇索引，但查询时需要先访问索引再访问数据，速度略慢于聚簇索引。\n- **唯一索引**：确保索引列中的值是唯一的，适用于需要唯一性约束的场景，如用户名、电子邮件地址等。它能确保数据的唯一性，防止重复数据，但插入和更新时需要检查唯一性，开销较大。\n- **组合索引**：是对多个列创建的索引，能够提高多列查询的效率，适用于WHERE子句中涉及多列的查询。它能显著提高查询效率，但索引创建和维护成本较高，且需要考虑索引的顺序。\n\n## 日志\n\n### MySQL 日志文件有哪些？\n\n1. **错误日志**：记录 MySQL 服务器启动、运行或停止时出现的问题。\n2. **慢查询日志**：记录执行时间超过`long_query_time`值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。\n3. **一般查询日志**：记录所有 MySQL 服务器的链接信息以及所有的 SQL 语句，不论这些语句是否修改了数据。\n4. **二进制日志**：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。\n5. **重做日志**：记录对于`InnDB`表的每个写操作，不是 SQL 级的，而是物理级别的，主要用于崩溃恢复。\n6. **回滚日志**：记录数据被修改前的值，用于事务回滚。\n\n","slug":"Myql八股文","published":1,"updated":"2024-07-08T09:42:12.272Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gp000dtuj8af848htf","content":"<h1 id=\"数据库\"><a class=\"headerlink\" href=\"#数据库\"></a>数据库</h1>\n<h2 id=\"索引\"><a class=\"headerlink\" href=\"#索引\"></a>索引</h2>\n<h3 id=\"为什么使用索引会加快查询？\"><a class=\"headerlink\" href=\"#为什么使用索引会加快查询？\"></a>为什么使用索引会加快查询？</h3>\n<p>数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。</p>\n<p>有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。</p>\n<p>MySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。</p>\n<p>索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。</p>\n<p>索引就好像书的目录，通过目录去查找对应的章节内容会比一页一页的翻书快很多。</p>\n<h3 id=\"MySQL中的索引有哪些类型？\"><a class=\"headerlink\" href=\"#MySQL中的索引有哪些类型？\"></a>MySQL中的索引有哪些类型？</h3>\n<ul>\n<li><strong>B-Tree索引</strong>：是MySQL中最常用的索引类型。适用于等值查询、范围查询、排序和分组操作。B-Tree索引的优点是查询效率高，尤其适合范围查询和排序操作，但对于频繁更新的列，索引维护成本较高。</li>\n<li><strong>哈希索引</strong>：通过哈希函数将键值映射到哈希表的位置，查找速度非常快。它适用于等值查询，但不支持范围查询、排序和分组。此外，哈希冲突会降低性能。</li>\n<li><strong>全文索引</strong>：用于全文搜索，支持对文本字段的关键词查询。它适合需要全文检索的场景，如搜索引擎和文章内容搜索，全文检索速度快，但建立和维护成本高，不适合实时更新的数据。</li>\n<li><strong>空间索引</strong>：（R-Tree索引）用于地理信息系统中的空间查询，适合多维数据的快速查询，如地理位置查询和地图服务。它能够有效地进行范围查询和最近邻查询，但不适合其他类型的数据，且建立和维护成本较高。</li>\n<li><strong>前缀索引</strong>：是对字符串类型的列的前几个字符创建索引，适用于字符串列较长且前缀部分区分度较高的场景。它能节省索引空间并提高查询效率，但只适用于前缀匹配查询，不支持全文匹配。</li>\n<li><strong>聚簇索引</strong>：决定数据在磁盘上的物理存储顺序，每个表只能有一个聚簇索引，通常是主键。它的数据访问速度快，特别适合范围查询，但更新开销较大，且非聚簇索引需要包含聚簇索引列作为引用。</li>\n<li><strong>非聚簇索引</strong>：的索引和数据分别存储，叶节点存储指向数据的指针。它的更新开销较小，可以有多个非聚簇索引，但查询时需要先访问索引再访问数据，速度略慢于聚簇索引。</li>\n<li><strong>唯一索引</strong>：确保索引列中的值是唯一的，适用于需要唯一性约束的场景，如用户名、电子邮件地址等。它能确保数据的唯一性，防止重复数据，但插入和更新时需要检查唯一性，开销较大。</li>\n<li><strong>组合索引</strong>：是对多个列创建的索引，能够提高多列查询的效率，适用于WHERE子句中涉及多列的查询。它能显著提高查询效率，但索引创建和维护成本较高，且需要考虑索引的顺序。</li>\n</ul>\n<h2 id=\"日志\"><a class=\"headerlink\" href=\"#日志\"></a>日志</h2>\n<h3 id=\"MySQL-日志文件有哪些？\"><a class=\"headerlink\" href=\"#MySQL-日志文件有哪些？\"></a>MySQL 日志文件有哪些？</h3>\n<ol>\n<li><strong>错误日志</strong>：记录 MySQL 服务器启动、运行或停止时出现的问题。</li>\n<li><strong>慢查询日志</strong>：记录执行时间超过<code>long_query_time</code>值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。</li>\n<li><strong>一般查询日志</strong>：记录所有 MySQL 服务器的链接信息以及所有的 SQL 语句，不论这些语句是否修改了数据。</li>\n<li><strong>二进制日志</strong>：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。</li>\n<li><strong>重做日志</strong>：记录对于<code>InnDB</code>表的每个写操作，不是 SQL 级的，而是物理级别的，主要用于崩溃恢复。</li>\n<li><strong>回滚日志</strong>：记录数据被修改前的值，用于事务回滚。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"数据库\"><a class=\"headerlink\" href=\"#数据库\"></a>数据库</h1>\n<h2 id=\"索引\"><a class=\"headerlink\" href=\"#索引\"></a>索引</h2>\n<h3 id=\"为什么使用索引会加快查询？\"><a class=\"headerlink\" href=\"#为什么使用索引会加快查询？\"></a>为什么使用索引会加快查询？</h3>\n<p>数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。</p>\n<p>有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。</p>\n<p>MySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。</p>\n<p>索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。</p>\n<p>索引就好像书的目录，通过目录去查找对应的章节内容会比一页一页的翻书快很多。</p>\n<h3 id=\"MySQL中的索引有哪些类型？\"><a class=\"headerlink\" href=\"#MySQL中的索引有哪些类型？\"></a>MySQL中的索引有哪些类型？</h3>\n<ul>\n<li><strong>B-Tree索引</strong>：是MySQL中最常用的索引类型。适用于等值查询、范围查询、排序和分组操作。B-Tree索引的优点是查询效率高，尤其适合范围查询和排序操作，但对于频繁更新的列，索引维护成本较高。</li>\n<li><strong>哈希索引</strong>：通过哈希函数将键值映射到哈希表的位置，查找速度非常快。它适用于等值查询，但不支持范围查询、排序和分组。此外，哈希冲突会降低性能。</li>\n<li><strong>全文索引</strong>：用于全文搜索，支持对文本字段的关键词查询。它适合需要全文检索的场景，如搜索引擎和文章内容搜索，全文检索速度快，但建立和维护成本高，不适合实时更新的数据。</li>\n<li><strong>空间索引</strong>：（R-Tree索引）用于地理信息系统中的空间查询，适合多维数据的快速查询，如地理位置查询和地图服务。它能够有效地进行范围查询和最近邻查询，但不适合其他类型的数据，且建立和维护成本较高。</li>\n<li><strong>前缀索引</strong>：是对字符串类型的列的前几个字符创建索引，适用于字符串列较长且前缀部分区分度较高的场景。它能节省索引空间并提高查询效率，但只适用于前缀匹配查询，不支持全文匹配。</li>\n<li><strong>聚簇索引</strong>：决定数据在磁盘上的物理存储顺序，每个表只能有一个聚簇索引，通常是主键。它的数据访问速度快，特别适合范围查询，但更新开销较大，且非聚簇索引需要包含聚簇索引列作为引用。</li>\n<li><strong>非聚簇索引</strong>：的索引和数据分别存储，叶节点存储指向数据的指针。它的更新开销较小，可以有多个非聚簇索引，但查询时需要先访问索引再访问数据，速度略慢于聚簇索引。</li>\n<li><strong>唯一索引</strong>：确保索引列中的值是唯一的，适用于需要唯一性约束的场景，如用户名、电子邮件地址等。它能确保数据的唯一性，防止重复数据，但插入和更新时需要检查唯一性，开销较大。</li>\n<li><strong>组合索引</strong>：是对多个列创建的索引，能够提高多列查询的效率，适用于WHERE子句中涉及多列的查询。它能显著提高查询效率，但索引创建和维护成本较高，且需要考虑索引的顺序。</li>\n</ul>\n<h2 id=\"日志\"><a class=\"headerlink\" href=\"#日志\"></a>日志</h2>\n<h3 id=\"MySQL-日志文件有哪些？\"><a class=\"headerlink\" href=\"#MySQL-日志文件有哪些？\"></a>MySQL 日志文件有哪些？</h3>\n<ol>\n<li><strong>错误日志</strong>：记录 MySQL 服务器启动、运行或停止时出现的问题。</li>\n<li><strong>慢查询日志</strong>：记录执行时间超过<code>long_query_time</code>值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。</li>\n<li><strong>一般查询日志</strong>：记录所有 MySQL 服务器的链接信息以及所有的 SQL 语句，不论这些语句是否修改了数据。</li>\n<li><strong>二进制日志</strong>：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。</li>\n<li><strong>重做日志</strong>：记录对于<code>InnDB</code>表的每个写操作，不是 SQL 级的，而是物理级别的，主要用于崩溃恢复。</li>\n<li><strong>回滚日志</strong>：记录数据被修改前的值，用于事务回滚。</li>\n</ol>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"RabbitMQ应用与总结","date":"2024-06-26T15:14:15.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E9%87%8E%E5%8E%9F%E6%96%B0%E4%B9%8B%E5%8A%A9%E3%80%912024-06-26%2023_14_57.png","_content":"\n## RabbitMQ常见面试题总结\n\n### 什么是 RabbitMQ？\n\nRabbitMQ 是一个开源的消息代理软件，广泛用于消息队列中。它实现了高级消息队列协议（AMQP），支持多重消息模式，能够在分布式系统重提供可靠的消息传递。。RabbitMQ 用于不同系统或服务之间异步传递消息，从而解耦生产者和消费者，增强系统的可扩展性和容错能力。\n\n\n\n### RabbitMQ 的组件有哪些？\n\n#### 1. Producer（生产者）\n\n- 生产者是消息的发送方，它将消息发送到 RabbitMQ 交换器。\n- 生成者负责创建和发送消息，不直接与队列通信。\n\n#### 2. Exchange（交换器）\n\n- 交换器接收来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。\n- 交换器有不同类型，主要包括：`direct`、`topic`、`fanout`和`headers`。\n\n##### Exchange 类型\n\n- **Direct Exchange**：根据消息的路由键完全匹配队列的绑定键进行路由。\n- **Topic Exchange**：根据消息的路由键模式（使用通配符）进行路由，适用于主题匹配的场景。\n- **Fanout Exchange**：将消息广播到所有与该交换器绑定的队列，不考虑路由键。\n- **Headers Exchange**：根据消息的头属性进行路由，相对较少使用。\n\n#### 3. Queue（队列）\n\n- 队列是 RabbitMQ 存储消息的容器，消费者从队列中接收消息。\n- 队列按照先进先出的顺序存储消息，可以持久化、镜像等。\n\n#### 4. Bindng（绑定）\n\n- 绑定是交换器与队列之间的连接，通过绑定将消息路由到特定的队列。\n- 绑定可以包含路由键和绑定参数，用于匹配消息的路由键。\n\n#### 5. Consumer（消费者）\n\n- 消费者是消息的接收方，它从 RabbitMQ 队列中接收和处理消息。\n\n- 消费者可以是主动拉取消息，也可以是被动推送消息。\n\n\n#### 6. Connection（连接）和Channel（信道）\n\n- 连接是应用程序与 RabbitMQ 之间的 TCP 连接。\n- 信道是建立在连接之上的虚拟连接，应用程序通过信道与 RabbitMQ 进行通信。信道是轻量级的，可以在一个连接上创建多个信道。\n\n#### 7. Virtual Host（虚拟机）\n\n- 虚拟机用于隔离不同的应用，每个虚拟机都有自己的交换器、队列、绑定和权限。\n\n#### 8. Broker（代理服务器）\n\n- Broker 是 RabbitMQ 服务器实例，负责接收、存储和转发消息。\n\n","source":"_posts/RabbitMQ八股文.md","raw":"---\ntitle: RabbitMQ应用与总结\ndate: 2024-06-26 23:14:15\ntags:\n  - RabbitMQ\n  - 总结\n  - Java\ncategories: Java\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E9%87%8E%E5%8E%9F%E6%96%B0%E4%B9%8B%E5%8A%A9%E3%80%912024-06-26%2023_14_57.png\n---\n\n## RabbitMQ常见面试题总结\n\n### 什么是 RabbitMQ？\n\nRabbitMQ 是一个开源的消息代理软件，广泛用于消息队列中。它实现了高级消息队列协议（AMQP），支持多重消息模式，能够在分布式系统重提供可靠的消息传递。。RabbitMQ 用于不同系统或服务之间异步传递消息，从而解耦生产者和消费者，增强系统的可扩展性和容错能力。\n\n\n\n### RabbitMQ 的组件有哪些？\n\n#### 1. Producer（生产者）\n\n- 生产者是消息的发送方，它将消息发送到 RabbitMQ 交换器。\n- 生成者负责创建和发送消息，不直接与队列通信。\n\n#### 2. Exchange（交换器）\n\n- 交换器接收来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。\n- 交换器有不同类型，主要包括：`direct`、`topic`、`fanout`和`headers`。\n\n##### Exchange 类型\n\n- **Direct Exchange**：根据消息的路由键完全匹配队列的绑定键进行路由。\n- **Topic Exchange**：根据消息的路由键模式（使用通配符）进行路由，适用于主题匹配的场景。\n- **Fanout Exchange**：将消息广播到所有与该交换器绑定的队列，不考虑路由键。\n- **Headers Exchange**：根据消息的头属性进行路由，相对较少使用。\n\n#### 3. Queue（队列）\n\n- 队列是 RabbitMQ 存储消息的容器，消费者从队列中接收消息。\n- 队列按照先进先出的顺序存储消息，可以持久化、镜像等。\n\n#### 4. Bindng（绑定）\n\n- 绑定是交换器与队列之间的连接，通过绑定将消息路由到特定的队列。\n- 绑定可以包含路由键和绑定参数，用于匹配消息的路由键。\n\n#### 5. Consumer（消费者）\n\n- 消费者是消息的接收方，它从 RabbitMQ 队列中接收和处理消息。\n\n- 消费者可以是主动拉取消息，也可以是被动推送消息。\n\n\n#### 6. Connection（连接）和Channel（信道）\n\n- 连接是应用程序与 RabbitMQ 之间的 TCP 连接。\n- 信道是建立在连接之上的虚拟连接，应用程序通过信道与 RabbitMQ 进行通信。信道是轻量级的，可以在一个连接上创建多个信道。\n\n#### 7. Virtual Host（虚拟机）\n\n- 虚拟机用于隔离不同的应用，每个虚拟机都有自己的交换器、队列、绑定和权限。\n\n#### 8. Broker（代理服务器）\n\n- Broker 是 RabbitMQ 服务器实例，负责接收、存储和转发消息。\n\n","slug":"RabbitMQ八股文","published":1,"updated":"2024-07-11T10:15:58.074Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gq000etuj8e266gyo9","content":"<h2 id=\"RabbitMQ常见面试题总结\"><a class=\"headerlink\" href=\"#RabbitMQ常见面试题总结\"></a>RabbitMQ常见面试题总结</h2>\n<h3 id=\"什么是-RabbitMQ？\"><a class=\"headerlink\" href=\"#什么是-RabbitMQ？\"></a>什么是 RabbitMQ？</h3>\n<p>RabbitMQ 是一个开源的消息代理软件，广泛用于消息队列中。它实现了高级消息队列协议（AMQP），支持多重消息模式，能够在分布式系统重提供可靠的消息传递。。RabbitMQ 用于不同系统或服务之间异步传递消息，从而解耦生产者和消费者，增强系统的可扩展性和容错能力。</p>\n<h3 id=\"RabbitMQ-的组件有哪些？\"><a class=\"headerlink\" href=\"#RabbitMQ-的组件有哪些？\"></a>RabbitMQ 的组件有哪些？</h3>\n<h4 id=\"1-Producer（生产者）\"><a class=\"headerlink\" href=\"#1-Producer（生产者）\"></a>1. Producer（生产者）</h4>\n<ul>\n<li>生产者是消息的发送方，它将消息发送到 RabbitMQ 交换器。</li>\n<li>生成者负责创建和发送消息，不直接与队列通信。</li>\n</ul>\n<h4 id=\"2-Exchange（交换器）\"><a class=\"headerlink\" href=\"#2-Exchange（交换器）\"></a>2. Exchange（交换器）</h4>\n<ul>\n<li>交换器接收来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。</li>\n<li>交换器有不同类型，主要包括：<code>direct</code>、<code>topic</code>、<code>fanout</code>和<code>headers</code>。</li>\n</ul>\n<h5 id=\"Exchange-类型\"><a class=\"headerlink\" href=\"#Exchange-类型\"></a>Exchange 类型</h5>\n<ul>\n<li><strong>Direct Exchange</strong>：根据消息的路由键完全匹配队列的绑定键进行路由。</li>\n<li><strong>Topic Exchange</strong>：根据消息的路由键模式（使用通配符）进行路由，适用于主题匹配的场景。</li>\n<li><strong>Fanout Exchange</strong>：将消息广播到所有与该交换器绑定的队列，不考虑路由键。</li>\n<li><strong>Headers Exchange</strong>：根据消息的头属性进行路由，相对较少使用。</li>\n</ul>\n<h4 id=\"3-Queue（队列）\"><a class=\"headerlink\" href=\"#3-Queue（队列）\"></a>3. Queue（队列）</h4>\n<ul>\n<li>队列是 RabbitMQ 存储消息的容器，消费者从队列中接收消息。</li>\n<li>队列按照先进先出的顺序存储消息，可以持久化、镜像等。</li>\n</ul>\n<h4 id=\"4-Bindng（绑定）\"><a class=\"headerlink\" href=\"#4-Bindng（绑定）\"></a>4. Bindng（绑定）</h4>\n<ul>\n<li>绑定是交换器与队列之间的连接，通过绑定将消息路由到特定的队列。</li>\n<li>绑定可以包含路由键和绑定参数，用于匹配消息的路由键。</li>\n</ul>\n<h4 id=\"5-Consumer（消费者）\"><a class=\"headerlink\" href=\"#5-Consumer（消费者）\"></a>5. Consumer（消费者）</h4>\n<ul>\n<li>\n<p>消费者是消息的接收方，它从 RabbitMQ 队列中接收和处理消息。</p>\n</li>\n<li>\n<p>消费者可以是主动拉取消息，也可以是被动推送消息。</p>\n</li>\n</ul>\n<h4 id=\"6-Connection（连接）和Channel（信道）\"><a class=\"headerlink\" href=\"#6-Connection（连接）和Channel（信道）\"></a>6. Connection（连接）和Channel（信道）</h4>\n<ul>\n<li>连接是应用程序与 RabbitMQ 之间的 TCP 连接。</li>\n<li>信道是建立在连接之上的虚拟连接，应用程序通过信道与 RabbitMQ 进行通信。信道是轻量级的，可以在一个连接上创建多个信道。</li>\n</ul>\n<h4 id=\"7-Virtual-Host（虚拟机）\"><a class=\"headerlink\" href=\"#7-Virtual-Host（虚拟机）\"></a>7. Virtual Host（虚拟机）</h4>\n<ul>\n<li>虚拟机用于隔离不同的应用，每个虚拟机都有自己的交换器、队列、绑定和权限。</li>\n</ul>\n<h4 id=\"8-Broker（代理服务器）\"><a class=\"headerlink\" href=\"#8-Broker（代理服务器）\"></a>8. Broker（代理服务器）</h4>\n<ul>\n<li>Broker 是 RabbitMQ 服务器实例，负责接收、存储和转发消息。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"RabbitMQ常见面试题总结\"><a class=\"headerlink\" href=\"#RabbitMQ常见面试题总结\"></a>RabbitMQ常见面试题总结</h2>\n<h3 id=\"什么是-RabbitMQ？\"><a class=\"headerlink\" href=\"#什么是-RabbitMQ？\"></a>什么是 RabbitMQ？</h3>\n<p>RabbitMQ 是一个开源的消息代理软件，广泛用于消息队列中。它实现了高级消息队列协议（AMQP），支持多重消息模式，能够在分布式系统重提供可靠的消息传递。。RabbitMQ 用于不同系统或服务之间异步传递消息，从而解耦生产者和消费者，增强系统的可扩展性和容错能力。</p>\n<h3 id=\"RabbitMQ-的组件有哪些？\"><a class=\"headerlink\" href=\"#RabbitMQ-的组件有哪些？\"></a>RabbitMQ 的组件有哪些？</h3>\n<h4 id=\"1-Producer（生产者）\"><a class=\"headerlink\" href=\"#1-Producer（生产者）\"></a>1. Producer（生产者）</h4>\n<ul>\n<li>生产者是消息的发送方，它将消息发送到 RabbitMQ 交换器。</li>\n<li>生成者负责创建和发送消息，不直接与队列通信。</li>\n</ul>\n<h4 id=\"2-Exchange（交换器）\"><a class=\"headerlink\" href=\"#2-Exchange（交换器）\"></a>2. Exchange（交换器）</h4>\n<ul>\n<li>交换器接收来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。</li>\n<li>交换器有不同类型，主要包括：<code>direct</code>、<code>topic</code>、<code>fanout</code>和<code>headers</code>。</li>\n</ul>\n<h5 id=\"Exchange-类型\"><a class=\"headerlink\" href=\"#Exchange-类型\"></a>Exchange 类型</h5>\n<ul>\n<li><strong>Direct Exchange</strong>：根据消息的路由键完全匹配队列的绑定键进行路由。</li>\n<li><strong>Topic Exchange</strong>：根据消息的路由键模式（使用通配符）进行路由，适用于主题匹配的场景。</li>\n<li><strong>Fanout Exchange</strong>：将消息广播到所有与该交换器绑定的队列，不考虑路由键。</li>\n<li><strong>Headers Exchange</strong>：根据消息的头属性进行路由，相对较少使用。</li>\n</ul>\n<h4 id=\"3-Queue（队列）\"><a class=\"headerlink\" href=\"#3-Queue（队列）\"></a>3. Queue（队列）</h4>\n<ul>\n<li>队列是 RabbitMQ 存储消息的容器，消费者从队列中接收消息。</li>\n<li>队列按照先进先出的顺序存储消息，可以持久化、镜像等。</li>\n</ul>\n<h4 id=\"4-Bindng（绑定）\"><a class=\"headerlink\" href=\"#4-Bindng（绑定）\"></a>4. Bindng（绑定）</h4>\n<ul>\n<li>绑定是交换器与队列之间的连接，通过绑定将消息路由到特定的队列。</li>\n<li>绑定可以包含路由键和绑定参数，用于匹配消息的路由键。</li>\n</ul>\n<h4 id=\"5-Consumer（消费者）\"><a class=\"headerlink\" href=\"#5-Consumer（消费者）\"></a>5. Consumer（消费者）</h4>\n<ul>\n<li>\n<p>消费者是消息的接收方，它从 RabbitMQ 队列中接收和处理消息。</p>\n</li>\n<li>\n<p>消费者可以是主动拉取消息，也可以是被动推送消息。</p>\n</li>\n</ul>\n<h4 id=\"6-Connection（连接）和Channel（信道）\"><a class=\"headerlink\" href=\"#6-Connection（连接）和Channel（信道）\"></a>6. Connection（连接）和Channel（信道）</h4>\n<ul>\n<li>连接是应用程序与 RabbitMQ 之间的 TCP 连接。</li>\n<li>信道是建立在连接之上的虚拟连接，应用程序通过信道与 RabbitMQ 进行通信。信道是轻量级的，可以在一个连接上创建多个信道。</li>\n</ul>\n<h4 id=\"7-Virtual-Host（虚拟机）\"><a class=\"headerlink\" href=\"#7-Virtual-Host（虚拟机）\"></a>7. Virtual Host（虚拟机）</h4>\n<ul>\n<li>虚拟机用于隔离不同的应用，每个虚拟机都有自己的交换器、队列、绑定和权限。</li>\n</ul>\n<h4 id=\"8-Broker（代理服务器）\"><a class=\"headerlink\" href=\"#8-Broker（代理服务器）\"></a>8. Broker（代理服务器）</h4>\n<ul>\n<li>Broker 是 RabbitMQ 服务器实例，负责接收、存储和转发消息。</li>\n</ul>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"Redis应用与总结","date":"2024-06-26T12:18:49.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E5%9C%9F%E9%97%B4%E5%9F%8B%E3%80%912024-06-26%2020_21_21.png","_content":"\n## Redis 常见面试题总结\n\n### Redis 为什么这么快？\n\n1. Redis 基于内存，内存的访问速度比磁盘块很多；\n\n2. Redis 主要是单线程事件循环和 IO 多路复用；\n\n3. Redis 内置了多重优化过后的数据类型、结构实现，性能非常高\n\n4. Redis 通信协议实现简单且解析高效。\n\n   #### 为什么不直接使用 Redis 当主数据库呢？\n\n   主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。\n\n### 为什么用 Redis？\n\n1. 访问速度更快\n\n2. 高并发\n\n3. 功能全面\n\n   Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。\n\n\n\n### Redis 除了做缓存，还能做什么？\n\n- **分布式锁**：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。\n- **限流**：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的`RRateLimiter`来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。\n- **消息队列**：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。\n- **延时队列**：Redisson 内置了延时队列（基于 Sorted Set 实现的）。\n- **分布式 Session**：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。\n\n### Redis 常用的数据类型有哪些？\n\n- **5 种基本数据类型**：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\n- **3 种特殊数据类型**：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。\n\n\n\n### String 的应用场景有哪些？\n\nString 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。\n\n- 常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；\n- 计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；\n- 分布式锁（利用`SETNX key value`命令可以实现一个最简易的分布式锁）；\n\n\n\n### Redis 持久化机制\n\nRedis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。\n\n1. **RDB（Redis DataBase）快照**\n\n   RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。\n\n   ​\t**优点：**\n\n   ​\tRDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。\n\n   ​\tRDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。\n\n   ​\t**缺点：**\n\n   ​\tRDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。\n\n   ​\tRDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。\n\n2. **AOF（Append Only File）日志**\n\n   AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。\n\n\n​\t\t**优点：**\n\n​\t\tAOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。\n\n​\t\tAOF 文件是可读的文本文件，便于分析和调试。\n\n​\t\t**缺点：**\n\n​\t\tAOF 文件通常比 RDB 文件更大，恢复速度相对慢。\n\n​\t\tAOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。\n\n#### 混合持久化\n\nRedis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。\n\n\n\n### 缓存穿透\n\n#### 什么是缓存穿透？\n\n缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。\n\n#### 有哪些解决办法？\n\n最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。\n\n比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。\n\n##### 1. 使用缓存空值\n\n将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。\n\n##### 2. 布隆过滤器\n\n布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。\n\n##### 3. 接口限流\n\n根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。\n\n\n\n### 缓存击穿\n\n#### 什么是缓存击穿？\n\n缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。\n\n#### 有哪些解决方法？\n\n##### 1. 永不过期\n\n将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。\n\n##### 2.提前预热\n\n在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。\n\n##### 3. 加锁\n\n当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。\n\n\n\n#### 缓存穿透和缓存击穿有什么区别？\n\n- 缓存穿透是查询一个在缓存和数据中都不存在的数据。\n\n- 缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。\n\n\n\n### 缓存雪崩\n\n#### 什么是缓存雪崩？\n\n缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。\n\n#### 有哪些解决方法？\n\n##### 针对Redis 服务不可用的情况：\n\n1. **Redis 集群**：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。\n2. **多级缓存**：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。\n\n##### 针对大量缓存同时失效的情况:\n\n1. **过期时间随机化**：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。\n2. **缓存预热**：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。\n3. **主动更新**：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。\n\n\n\n### 如何保证缓存和数据库数据一致性？\n\n#### 1. Cache Aside Pattern（旁路缓存模式）\n\n当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。\n\n#### 2. Write Through Cache（写直达缓存）\n\n所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。\n\n#### 3. Write Behind Cache（异步写缓存）\n\n写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。\n\n#### 4. Cache and Database Double Write（双写一致性）\n\n确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。\n\n#### 5. 使用消息队列实现最终一致性\n\n写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。\n\n#### 总结\n\n- **Cache Aside Pattern（旁路缓存模式）**：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。\n- **Write Through Cache（写直达缓存）**：写操作先更新缓存，再同步更新数据库。\n- **Write Behind Cache（异步写缓存）**：写操作先更新缓存，再异步批量更新数据库。\n- **双写一致性（Cache and Database Double Write）**：写操作时同时更新缓存和数据库，确保原子性。\n- **使用消息队列实现最终一致性**：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。\n","source":"_posts/Redis八股文.md","raw":"---\ntitle: Redis应用与总结\ndate: 2024-06-26 20:18:49\ntags: \n  - Redis\n  - 总结\ncategories: Java\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E5%9C%9F%E9%97%B4%E5%9F%8B%E3%80%912024-06-26%2020_21_21.png\n---\n\n## Redis 常见面试题总结\n\n### Redis 为什么这么快？\n\n1. Redis 基于内存，内存的访问速度比磁盘块很多；\n\n2. Redis 主要是单线程事件循环和 IO 多路复用；\n\n3. Redis 内置了多重优化过后的数据类型、结构实现，性能非常高\n\n4. Redis 通信协议实现简单且解析高效。\n\n   #### 为什么不直接使用 Redis 当主数据库呢？\n\n   主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。\n\n### 为什么用 Redis？\n\n1. 访问速度更快\n\n2. 高并发\n\n3. 功能全面\n\n   Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。\n\n\n\n### Redis 除了做缓存，还能做什么？\n\n- **分布式锁**：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。\n- **限流**：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的`RRateLimiter`来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。\n- **消息队列**：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。\n- **延时队列**：Redisson 内置了延时队列（基于 Sorted Set 实现的）。\n- **分布式 Session**：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。\n\n### Redis 常用的数据类型有哪些？\n\n- **5 种基本数据类型**：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\n- **3 种特殊数据类型**：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。\n\n\n\n### String 的应用场景有哪些？\n\nString 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。\n\n- 常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；\n- 计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；\n- 分布式锁（利用`SETNX key value`命令可以实现一个最简易的分布式锁）；\n\n\n\n### Redis 持久化机制\n\nRedis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。\n\n1. **RDB（Redis DataBase）快照**\n\n   RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。\n\n   ​\t**优点：**\n\n   ​\tRDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。\n\n   ​\tRDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。\n\n   ​\t**缺点：**\n\n   ​\tRDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。\n\n   ​\tRDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。\n\n2. **AOF（Append Only File）日志**\n\n   AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。\n\n\n​\t\t**优点：**\n\n​\t\tAOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。\n\n​\t\tAOF 文件是可读的文本文件，便于分析和调试。\n\n​\t\t**缺点：**\n\n​\t\tAOF 文件通常比 RDB 文件更大，恢复速度相对慢。\n\n​\t\tAOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。\n\n#### 混合持久化\n\nRedis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。\n\n\n\n### 缓存穿透\n\n#### 什么是缓存穿透？\n\n缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。\n\n#### 有哪些解决办法？\n\n最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。\n\n比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。\n\n##### 1. 使用缓存空值\n\n将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。\n\n##### 2. 布隆过滤器\n\n布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。\n\n##### 3. 接口限流\n\n根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。\n\n\n\n### 缓存击穿\n\n#### 什么是缓存击穿？\n\n缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。\n\n#### 有哪些解决方法？\n\n##### 1. 永不过期\n\n将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。\n\n##### 2.提前预热\n\n在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。\n\n##### 3. 加锁\n\n当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。\n\n\n\n#### 缓存穿透和缓存击穿有什么区别？\n\n- 缓存穿透是查询一个在缓存和数据中都不存在的数据。\n\n- 缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。\n\n\n\n### 缓存雪崩\n\n#### 什么是缓存雪崩？\n\n缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。\n\n#### 有哪些解决方法？\n\n##### 针对Redis 服务不可用的情况：\n\n1. **Redis 集群**：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。\n2. **多级缓存**：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。\n\n##### 针对大量缓存同时失效的情况:\n\n1. **过期时间随机化**：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。\n2. **缓存预热**：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。\n3. **主动更新**：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。\n\n\n\n### 如何保证缓存和数据库数据一致性？\n\n#### 1. Cache Aside Pattern（旁路缓存模式）\n\n当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。\n\n#### 2. Write Through Cache（写直达缓存）\n\n所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。\n\n#### 3. Write Behind Cache（异步写缓存）\n\n写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。\n\n#### 4. Cache and Database Double Write（双写一致性）\n\n确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。\n\n#### 5. 使用消息队列实现最终一致性\n\n写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。\n\n#### 总结\n\n- **Cache Aside Pattern（旁路缓存模式）**：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。\n- **Write Through Cache（写直达缓存）**：写操作先更新缓存，再同步更新数据库。\n- **Write Behind Cache（异步写缓存）**：写操作先更新缓存，再异步批量更新数据库。\n- **双写一致性（Cache and Database Double Write）**：写操作时同时更新缓存和数据库，确保原子性。\n- **使用消息队列实现最终一致性**：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。\n","slug":"Redis八股文","published":1,"updated":"2024-07-11T10:14:13.020Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gr000ituj85ievhv4l","content":"<h2 id=\"Redis-常见面试题总结\"><a class=\"headerlink\" href=\"#Redis-常见面试题总结\"></a>Redis 常见面试题总结</h2>\n<h3 id=\"Redis-为什么这么快？\"><a class=\"headerlink\" href=\"#Redis-为什么这么快？\"></a>Redis 为什么这么快？</h3>\n<ol>\n<li>\n<p>Redis 基于内存，内存的访问速度比磁盘块很多；</p>\n</li>\n<li>\n<p>Redis 主要是单线程事件循环和 IO 多路复用；</p>\n</li>\n<li>\n<p>Redis 内置了多重优化过后的数据类型、结构实现，性能非常高</p>\n</li>\n<li>\n<p>Redis 通信协议实现简单且解析高效。</p>\n<h4 id=\"为什么不直接使用-Redis-当主数据库呢？\"><a class=\"headerlink\" href=\"#为什么不直接使用-Redis-当主数据库呢？\"></a>为什么不直接使用 Redis 当主数据库呢？</h4>\n<p>主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。</p>\n</li>\n</ol>\n<h3 id=\"为什么用-Redis？\"><a class=\"headerlink\" href=\"#为什么用-Redis？\"></a>为什么用 Redis？</h3>\n<ol>\n<li>\n<p>访问速度更快</p>\n</li>\n<li>\n<p>高并发</p>\n</li>\n<li>\n<p>功能全面</p>\n<p>Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。</p>\n</li>\n</ol>\n<h3 id=\"Redis-除了做缓存，还能做什么？\"><a class=\"headerlink\" href=\"#Redis-除了做缓存，还能做什么？\"></a>Redis 除了做缓存，还能做什么？</h3>\n<ul>\n<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li>\n<li><strong>限流</strong>：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的<code>RRateLimiter</code>来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>\n<li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。</li>\n<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li>\n<li><strong>分布式 Session</strong>：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li>\n</ul>\n<h3 id=\"Redis-常用的数据类型有哪些？\"><a class=\"headerlink\" href=\"#Redis-常用的数据类型有哪些？\"></a>Redis 常用的数据类型有哪些？</h3>\n<ul>\n<li><strong>5 种基本数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>\n<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。</li>\n</ul>\n<h3 id=\"String-的应用场景有哪些？\"><a class=\"headerlink\" href=\"#String-的应用场景有哪些？\"></a>String 的应用场景有哪些？</h3>\n<p>String 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。</p>\n<ul>\n<li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li>\n<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>\n<li>分布式锁（利用<code>SETNX key value</code>命令可以实现一个最简易的分布式锁）；</li>\n</ul>\n<h3 id=\"Redis-持久化机制\"><a class=\"headerlink\" href=\"#Redis-持久化机制\"></a>Redis 持久化机制</h3>\n<p>Redis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。</p>\n<ol>\n<li>\n<p><strong>RDB（Redis DataBase）快照</strong></p>\n<p>RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。</p>\n<p>​\t<strong>优点：</strong></p>\n<p>​\tRDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。</p>\n<p>​\tRDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。</p>\n<p>​\t<strong>缺点：</strong></p>\n<p>​\tRDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。</p>\n<p>​\tRDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。</p>\n</li>\n<li>\n<p><strong>AOF（Append Only File）日志</strong></p>\n<p>AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。</p>\n</li>\n</ol>\n<p>​\t\t<strong>优点：</strong></p>\n<p>​\t\tAOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。</p>\n<p>​\t\tAOF 文件是可读的文本文件，便于分析和调试。</p>\n<p>​\t\t<strong>缺点：</strong></p>\n<p>​\t\tAOF 文件通常比 RDB 文件更大，恢复速度相对慢。</p>\n<p>​\t\tAOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。</p>\n<h4 id=\"混合持久化\"><a class=\"headerlink\" href=\"#混合持久化\"></a>混合持久化</h4>\n<p>Redis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。</p>\n<h3 id=\"缓存穿透\"><a class=\"headerlink\" href=\"#缓存穿透\"></a>缓存穿透</h3>\n<h4 id=\"什么是缓存穿透？\"><a class=\"headerlink\" href=\"#什么是缓存穿透？\"></a>什么是缓存穿透？</h4>\n<p>缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。</p>\n<h4 id=\"有哪些解决办法？\"><a class=\"headerlink\" href=\"#有哪些解决办法？\"></a>有哪些解决办法？</h4>\n<p>最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p>\n<p>比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。</p>\n<h5 id=\"1-使用缓存空值\"><a class=\"headerlink\" href=\"#1-使用缓存空值\"></a>1. 使用缓存空值</h5>\n<p>将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。</p>\n<h5 id=\"2-布隆过滤器\"><a class=\"headerlink\" href=\"#2-布隆过滤器\"></a>2. 布隆过滤器</h5>\n<p>布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。</p>\n<h5 id=\"3-接口限流\"><a class=\"headerlink\" href=\"#3-接口限流\"></a>3. 接口限流</h5>\n<p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。</p>\n<h3 id=\"缓存击穿\"><a class=\"headerlink\" href=\"#缓存击穿\"></a>缓存击穿</h3>\n<h4 id=\"什么是缓存击穿？\"><a class=\"headerlink\" href=\"#什么是缓存击穿？\"></a>什么是缓存击穿？</h4>\n<p>缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。</p>\n<h4 id=\"有哪些解决方法？\"><a class=\"headerlink\" href=\"#有哪些解决方法？\"></a>有哪些解决方法？</h4>\n<h5 id=\"1-永不过期\"><a class=\"headerlink\" href=\"#1-永不过期\"></a>1. 永不过期</h5>\n<p>将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。</p>\n<h5 id=\"2-提前预热\"><a class=\"headerlink\" href=\"#2-提前预热\"></a>2.提前预热</h5>\n<p>在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。</p>\n<h5 id=\"3-加锁\"><a class=\"headerlink\" href=\"#3-加锁\"></a>3. 加锁</h5>\n<p>当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。</p>\n<h4 id=\"缓存穿透和缓存击穿有什么区别？\"><a class=\"headerlink\" href=\"#缓存穿透和缓存击穿有什么区别？\"></a>缓存穿透和缓存击穿有什么区别？</h4>\n<ul>\n<li>\n<p>缓存穿透是查询一个在缓存和数据中都不存在的数据。</p>\n</li>\n<li>\n<p>缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。</p>\n</li>\n</ul>\n<h3 id=\"缓存雪崩\"><a class=\"headerlink\" href=\"#缓存雪崩\"></a>缓存雪崩</h3>\n<h4 id=\"什么是缓存雪崩？\"><a class=\"headerlink\" href=\"#什么是缓存雪崩？\"></a>什么是缓存雪崩？</h4>\n<p>缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。</p>\n<h4 id=\"有哪些解决方法？-2\"><a class=\"headerlink\" href=\"#有哪些解决方法？-2\"></a>有哪些解决方法？</h4>\n<h5 id=\"针对Redis-服务不可用的情况：\"><a class=\"headerlink\" href=\"#针对Redis-服务不可用的情况：\"></a>针对Redis 服务不可用的情况：</h5>\n<ol>\n<li><strong>Redis 集群</strong>：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。</li>\n<li><strong>多级缓存</strong>：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。</li>\n</ol>\n<h5 id=\"针对大量缓存同时失效的情况\"><a class=\"headerlink\" href=\"#针对大量缓存同时失效的情况\"></a>针对大量缓存同时失效的情况:</h5>\n<ol>\n<li><strong>过期时间随机化</strong>：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。</li>\n<li><strong>缓存预热</strong>：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。</li>\n<li><strong>主动更新</strong>：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。</li>\n</ol>\n<h3 id=\"如何保证缓存和数据库数据一致性？\"><a class=\"headerlink\" href=\"#如何保证缓存和数据库数据一致性？\"></a>如何保证缓存和数据库数据一致性？</h3>\n<h4 id=\"1-Cache-Aside-Pattern（旁路缓存模式）\"><a class=\"headerlink\" href=\"#1-Cache-Aside-Pattern（旁路缓存模式）\"></a>1. Cache Aside Pattern（旁路缓存模式）</h4>\n<p>当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。</p>\n<h4 id=\"2-Write-Through-Cache（写直达缓存）\"><a class=\"headerlink\" href=\"#2-Write-Through-Cache（写直达缓存）\"></a>2. Write Through Cache（写直达缓存）</h4>\n<p>所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。</p>\n<h4 id=\"3-Write-Behind-Cache（异步写缓存）\"><a class=\"headerlink\" href=\"#3-Write-Behind-Cache（异步写缓存）\"></a>3. Write Behind Cache（异步写缓存）</h4>\n<p>写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。</p>\n<h4 id=\"4-Cache-and-Database-Double-Write（双写一致性）\"><a class=\"headerlink\" href=\"#4-Cache-and-Database-Double-Write（双写一致性）\"></a>4. Cache and Database Double Write（双写一致性）</h4>\n<p>确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。</p>\n<h4 id=\"5-使用消息队列实现最终一致性\"><a class=\"headerlink\" href=\"#5-使用消息队列实现最终一致性\"></a>5. 使用消息队列实现最终一致性</h4>\n<p>写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。</p>\n<h4 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h4>\n<ul>\n<li><strong>Cache Aside Pattern（旁路缓存模式）</strong>：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。</li>\n<li><strong>Write Through Cache（写直达缓存）</strong>：写操作先更新缓存，再同步更新数据库。</li>\n<li><strong>Write Behind Cache（异步写缓存）</strong>：写操作先更新缓存，再异步批量更新数据库。</li>\n<li><strong>双写一致性（Cache and Database Double Write）</strong>：写操作时同时更新缓存和数据库，确保原子性。</li>\n<li><strong>使用消息队列实现最终一致性</strong>：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"Redis-常见面试题总结\"><a class=\"headerlink\" href=\"#Redis-常见面试题总结\"></a>Redis 常见面试题总结</h2>\n<h3 id=\"Redis-为什么这么快？\"><a class=\"headerlink\" href=\"#Redis-为什么这么快？\"></a>Redis 为什么这么快？</h3>\n<ol>\n<li>\n<p>Redis 基于内存，内存的访问速度比磁盘块很多；</p>\n</li>\n<li>\n<p>Redis 主要是单线程事件循环和 IO 多路复用；</p>\n</li>\n<li>\n<p>Redis 内置了多重优化过后的数据类型、结构实现，性能非常高</p>\n</li>\n<li>\n<p>Redis 通信协议实现简单且解析高效。</p>\n<h4 id=\"为什么不直接使用-Redis-当主数据库呢？\"><a class=\"headerlink\" href=\"#为什么不直接使用-Redis-当主数据库呢？\"></a>为什么不直接使用 Redis 当主数据库呢？</h4>\n<p>主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。</p>\n</li>\n</ol>\n<h3 id=\"为什么用-Redis？\"><a class=\"headerlink\" href=\"#为什么用-Redis？\"></a>为什么用 Redis？</h3>\n<ol>\n<li>\n<p>访问速度更快</p>\n</li>\n<li>\n<p>高并发</p>\n</li>\n<li>\n<p>功能全面</p>\n<p>Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。</p>\n</li>\n</ol>\n<h3 id=\"Redis-除了做缓存，还能做什么？\"><a class=\"headerlink\" href=\"#Redis-除了做缓存，还能做什么？\"></a>Redis 除了做缓存，还能做什么？</h3>\n<ul>\n<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li>\n<li><strong>限流</strong>：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的<code>RRateLimiter</code>来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>\n<li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。</li>\n<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li>\n<li><strong>分布式 Session</strong>：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li>\n</ul>\n<h3 id=\"Redis-常用的数据类型有哪些？\"><a class=\"headerlink\" href=\"#Redis-常用的数据类型有哪些？\"></a>Redis 常用的数据类型有哪些？</h3>\n<ul>\n<li><strong>5 种基本数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>\n<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。</li>\n</ul>\n<h3 id=\"String-的应用场景有哪些？\"><a class=\"headerlink\" href=\"#String-的应用场景有哪些？\"></a>String 的应用场景有哪些？</h3>\n<p>String 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。</p>\n<ul>\n<li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li>\n<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>\n<li>分布式锁（利用<code>SETNX key value</code>命令可以实现一个最简易的分布式锁）；</li>\n</ul>\n<h3 id=\"Redis-持久化机制\"><a class=\"headerlink\" href=\"#Redis-持久化机制\"></a>Redis 持久化机制</h3>\n<p>Redis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。</p>\n<ol>\n<li>\n<p><strong>RDB（Redis DataBase）快照</strong></p>\n<p>RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。</p>\n<p>​\t<strong>优点：</strong></p>\n<p>​\tRDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。</p>\n<p>​\tRDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。</p>\n<p>​\t<strong>缺点：</strong></p>\n<p>​\tRDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。</p>\n<p>​\tRDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。</p>\n</li>\n<li>\n<p><strong>AOF（Append Only File）日志</strong></p>\n<p>AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。</p>\n</li>\n</ol>\n<p>​\t\t<strong>优点：</strong></p>\n<p>​\t\tAOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。</p>\n<p>​\t\tAOF 文件是可读的文本文件，便于分析和调试。</p>\n<p>​\t\t<strong>缺点：</strong></p>\n<p>​\t\tAOF 文件通常比 RDB 文件更大，恢复速度相对慢。</p>\n<p>​\t\tAOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。</p>\n<h4 id=\"混合持久化\"><a class=\"headerlink\" href=\"#混合持久化\"></a>混合持久化</h4>\n<p>Redis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。</p>\n<h3 id=\"缓存穿透\"><a class=\"headerlink\" href=\"#缓存穿透\"></a>缓存穿透</h3>\n<h4 id=\"什么是缓存穿透？\"><a class=\"headerlink\" href=\"#什么是缓存穿透？\"></a>什么是缓存穿透？</h4>\n<p>缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。</p>\n<h4 id=\"有哪些解决办法？\"><a class=\"headerlink\" href=\"#有哪些解决办法？\"></a>有哪些解决办法？</h4>\n<p>最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p>\n<p>比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。</p>\n<h5 id=\"1-使用缓存空值\"><a class=\"headerlink\" href=\"#1-使用缓存空值\"></a>1. 使用缓存空值</h5>\n<p>将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。</p>\n<h5 id=\"2-布隆过滤器\"><a class=\"headerlink\" href=\"#2-布隆过滤器\"></a>2. 布隆过滤器</h5>\n<p>布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。</p>\n<h5 id=\"3-接口限流\"><a class=\"headerlink\" href=\"#3-接口限流\"></a>3. 接口限流</h5>\n<p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。</p>\n<h3 id=\"缓存击穿\"><a class=\"headerlink\" href=\"#缓存击穿\"></a>缓存击穿</h3>\n<h4 id=\"什么是缓存击穿？\"><a class=\"headerlink\" href=\"#什么是缓存击穿？\"></a>什么是缓存击穿？</h4>\n<p>缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。</p>\n<h4 id=\"有哪些解决方法？\"><a class=\"headerlink\" href=\"#有哪些解决方法？\"></a>有哪些解决方法？</h4>\n<h5 id=\"1-永不过期\"><a class=\"headerlink\" href=\"#1-永不过期\"></a>1. 永不过期</h5>\n<p>将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。</p>\n<h5 id=\"2-提前预热\"><a class=\"headerlink\" href=\"#2-提前预热\"></a>2.提前预热</h5>\n<p>在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。</p>\n<h5 id=\"3-加锁\"><a class=\"headerlink\" href=\"#3-加锁\"></a>3. 加锁</h5>\n<p>当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。</p>\n<h4 id=\"缓存穿透和缓存击穿有什么区别？\"><a class=\"headerlink\" href=\"#缓存穿透和缓存击穿有什么区别？\"></a>缓存穿透和缓存击穿有什么区别？</h4>\n<ul>\n<li>\n<p>缓存穿透是查询一个在缓存和数据中都不存在的数据。</p>\n</li>\n<li>\n<p>缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。</p>\n</li>\n</ul>\n<h3 id=\"缓存雪崩\"><a class=\"headerlink\" href=\"#缓存雪崩\"></a>缓存雪崩</h3>\n<h4 id=\"什么是缓存雪崩？\"><a class=\"headerlink\" href=\"#什么是缓存雪崩？\"></a>什么是缓存雪崩？</h4>\n<p>缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。</p>\n<h4 id=\"有哪些解决方法？-2\"><a class=\"headerlink\" href=\"#有哪些解决方法？-2\"></a>有哪些解决方法？</h4>\n<h5 id=\"针对Redis-服务不可用的情况：\"><a class=\"headerlink\" href=\"#针对Redis-服务不可用的情况：\"></a>针对Redis 服务不可用的情况：</h5>\n<ol>\n<li><strong>Redis 集群</strong>：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。</li>\n<li><strong>多级缓存</strong>：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。</li>\n</ol>\n<h5 id=\"针对大量缓存同时失效的情况\"><a class=\"headerlink\" href=\"#针对大量缓存同时失效的情况\"></a>针对大量缓存同时失效的情况:</h5>\n<ol>\n<li><strong>过期时间随机化</strong>：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。</li>\n<li><strong>缓存预热</strong>：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。</li>\n<li><strong>主动更新</strong>：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。</li>\n</ol>\n<h3 id=\"如何保证缓存和数据库数据一致性？\"><a class=\"headerlink\" href=\"#如何保证缓存和数据库数据一致性？\"></a>如何保证缓存和数据库数据一致性？</h3>\n<h4 id=\"1-Cache-Aside-Pattern（旁路缓存模式）\"><a class=\"headerlink\" href=\"#1-Cache-Aside-Pattern（旁路缓存模式）\"></a>1. Cache Aside Pattern（旁路缓存模式）</h4>\n<p>当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。</p>\n<h4 id=\"2-Write-Through-Cache（写直达缓存）\"><a class=\"headerlink\" href=\"#2-Write-Through-Cache（写直达缓存）\"></a>2. Write Through Cache（写直达缓存）</h4>\n<p>所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。</p>\n<h4 id=\"3-Write-Behind-Cache（异步写缓存）\"><a class=\"headerlink\" href=\"#3-Write-Behind-Cache（异步写缓存）\"></a>3. Write Behind Cache（异步写缓存）</h4>\n<p>写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。</p>\n<h4 id=\"4-Cache-and-Database-Double-Write（双写一致性）\"><a class=\"headerlink\" href=\"#4-Cache-and-Database-Double-Write（双写一致性）\"></a>4. Cache and Database Double Write（双写一致性）</h4>\n<p>确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。</p>\n<h4 id=\"5-使用消息队列实现最终一致性\"><a class=\"headerlink\" href=\"#5-使用消息队列实现最终一致性\"></a>5. 使用消息队列实现最终一致性</h4>\n<p>写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。</p>\n<h4 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h4>\n<ul>\n<li><strong>Cache Aside Pattern（旁路缓存模式）</strong>：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。</li>\n<li><strong>Write Through Cache（写直达缓存）</strong>：写操作先更新缓存，再同步更新数据库。</li>\n<li><strong>Write Behind Cache（异步写缓存）</strong>：写操作先更新缓存，再异步批量更新数据库。</li>\n<li><strong>双写一致性（Cache and Database Double Write）</strong>：写操作时同时更新缓存和数据库，确保原子性。</li>\n<li><strong>使用消息队列实现最终一致性</strong>：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。</li>\n</ul>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"Spring应用与总结","date":"2024-06-22T10:11:04.000Z","cover":"/img/springbaguwen.png","_content":"\n## Spring 常见面试题总结\n\n### 什么是Spring框架？\n\nSpring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。\n\n\n\n### 谈谈自己对于Spring IoC的了解\n\n**IoC** （Inversion of Control 控制反转）是一种设计模式，用来实现对象之间的解耦。\n\nIoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。\n\n\n\n#### 为什么叫控制反转？\n\n- **控制**：指的是对象创建（实例化、管理）的权利\n- **反转**：控制权交给外部环境（Spring框架、IoC容器）\n\n将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。\n\n\n\n### 什么是 Bean？\n\nBean 就是哪些被 IoC 容器所管理的对象。\n\n\n\n### @Component和@Bean的区别是什么？\n\n- @Component 注解用于类，@Bean 注解用于方法。\n- @Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。\n- @Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。\n\n\n\n### 注入Bean的注解有哪些？\n\nSpring 内置的`@Autowired` 还有 JDK 内置的 `@Resource` 和 `@Inject` 都可以用于注入 Bean。\n\n\n\n### @Autowired和@Resource的区别是什么？\n\n- `@Autowired` 是 Spring 提供的注解，`@Resource` 是 JDK 提供的注解。\n- `Autowired` 默认的注入方式为`byType`（根据类型进行匹配），`@Resource`默认注入方式为 `byName`（根据名称进行匹配）。\n- 当一个接口存在多个实现类的情况下，`@Autowired` 和 `@Resource` 都需要通过名称才能正确匹配到对应的  Bean。`Autowired` 可以通过 `@Qualifier` 注解来显式指定名称，`@Resource` 可以通过 name 属性来显式指定名称。\n- @Autowired 支持在构造函数、方法、字段和参数上使用。`@Resource` 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。\n\n\n\n### Bean 的作用域有哪些?\n\n- **Singleton** Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。\n- **prototype**  每次请求都会创建一个新的 bean 实例。\n- **Request** 每次 Http 请求都会创建一个新的 bean 实例。\n- **Session** 每个 Http Session 中会有一个 bean 实例。\n\n\n\n### Bean 是线程安全的吗？\n\n在 Spring 中 Bean 是否安全，取决于其作用域和状态。\n\n单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。\n\n\n\n### Bean的生命周期了解么？\n\nbean 的生命周期分为五个阶段：\n\n1. 调用构造器或者是通过工厂的方式创建 bean \n2. 给 bean 的属性注入值\n3. 调用初始化方法，进行初始化\n4. bean 被完全初始化和配置，就可以使用了\n5. 当 IOC 容器关闭的时候，销毁 bean\n\n\n\n### 谈谈对于AOP的了解\n\nAOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。\n\nSpring AOP 是通过动态代理来实现切面功能，**JDK动态代理**：用于代理实现了接口的类。**CGLIB代理**：用于代理没有实现接口的类，通过生成目标类的子类来实现。\n\n\n\n### Spring AOP 和 AspectJ AOP 有什么区别？\n\nSpring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。\n\n\n\n### AspectJ 定义的通知类型有哪些？\n\n- **Before**（前置通知）：在方法执行之前运行。\n\n- **After**（后置通知）：在方法执行之后运行，无论方法是否成功完成。\n\n- **AfterReturning**（返回通知）：在方法成功完成后运行。\n\n- **AfterThorowing**（异常通知）：在方法抛出异常后运行。\n\n- **Around**（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。\n\n  \n\n### 多个切面执行顺序如何控制？\n\n1. 通常使用`@Order` 注解直接定义切面顺序\n2. 实现`Ordered`接口重写`getOrder`方法\n\n\n\n### 说说自己对于 Spring MVC 了解？\n\nSpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。\n\n### SpringMVC 的工作流程是什么？\n\n1. 客户端请求首先到达`DispatcherServlet`。\n2. `DispatcherServlet`通过`HandlerMapping`找到具体的处理器（Controller）。\n3. `DispatcherServlet`通过`HandlerAdapter`调用处理器中的具体方法。\n4. 处理器方法执行完毕后返回`ModelAndView`对象，包含视图名称和模型数据。\n5. `DispatcherServlet`使用`ViewResolver`将视图名称解析为具体的视图。\n6. 最后，`DispatcherServlet`将模型数据传递给视图，视图渲染并返回响应给客户端。\n\n客户端发送请求 -> 2. DispatcherServlet接收请求 -> 3. HandlerMapping查找控制器 -> 4. HandlerAdapter调用控制器方法 -> 5. Controller处理请求 -> 6. ViewResolver解析视图 -> 7. 视图渲染 -> 8. 返回响应给客户端\n\n\n\n### 统一异常处理怎么做？\n\n使用注解的方式统一异常处理，使用`@controllerAdvice`和`@ExceptionHandler`这两个注解。\n\n\n\n### Spring 中用到了哪些设计模式？\n\n- **工厂设计模式**：Spring 使用工厂模式通过`BeanFactory`、`ApplicationContext`创建 bean 对象。\n- **代理设计模式**：SpringAOP 功能实现。\n- **单例设计模式**：Spring 中的 Bean 默认都是单例的。\n- **模版方法模式**：Spring 中`jdbcTemplate`、`hibernateTemplate`等以 Template 结尾的对数据库操作的类，都使用到了模版模式。\n- **包装器设计模式**：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。\n- **观察者模式**：Spring 事件驱动模型就是观察者模式。\n- **适配器模式**：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配`Controller`。\n\n\n\n### Spring 循环依赖了解吗，怎么解决？\n\nSpring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。\n\n#### 使用 setter 注入\n\nSpring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。\n\n#### 使用 @Lazy 注解\n\n在其中一个 Bean 的依赖上使用`@Lazy`注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。\n\n\n\n### Spring 管理事务的方式有几种？\n\n- **编程式事务**：在代码中硬编码（在分布式系统中推荐使用）：通过`TranscationTemplate`或者`TransactionManager`在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。\n- **声明式事务**：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于`@Transcational`的全注解方式使用最多）\n\n\n\n### Srping事务中哪几种事务传播行为？\n\n> 事务传播行为是为了解决业务层方法之间互相调用的事务问题。\n>\n> 当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。\n>\n> 例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。\n\n1. **`TransactionDefinition.PROPAGATION_REQUIRED`**：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。\n\n\n\n### 什么是 SpringBoot？为什么要有 SpringBoot？\n\nSpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）\n\n\n\n### 如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？\n\nSpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。\n\n\n\n\n\n### 介绍一下 @SpringBootApplication 注解\n\n`@SpringBootApplication`可以看作是`@Configuration、@EnableAutoConfiguration、@ComponentScan`注解的集合。\n\n- `@Configuration`：运行在上下文中注册额外的`bean`或导入其他配置类\n- `@EnableAutoConfiguration`：启用 Springboot 的自动配置机制\n- `@ComponentScan`：扫描被`@Component`(`@Service`,`@Controller`)注解的 bean，默认会扫描该类所在的包下的所有的类。\n\n\n\n### SpringBoot 的自动配置是如何实现的？\n\n当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。\n\nSpringBoot 会扫描`spring.factories`文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。\n\n\n\n### SpringBoot 常用的两种配置文件\n\n我们可以通过`applcation.properties`或者`application.yml`对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。\n\n\n\n### 什么是 YAML ? YAML配置的优势在哪里？\n\nYAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。\n\n相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。\n\n但是 YAML 配置文件不支持`@PropertySource` 注解导入自定义的 YAML 配置。\n\n\n\n### SpringBoot 常用的读取配置文件的方法有哪些？\n\n1. 通过`@Value(\"${property}\")`读取比较简单的配置信息\n\n   > `@value` 这种方式是不被推荐的\n\n2. 通过`@ConfigurationProperties`读取并与 bean 绑定\n\n3. 通过`@ConfigurationProperies`读取并校验\n\n4. 通过`@PropertySource`读取指定的 properties 文件\n\n\n\n### SpringBoot 如何做请求参数校验？\n\n使用 JSR 提供的校验注解\n\n\n\n### SpringBoot 如何监控系统运行状态？\n\n可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。\n\n\n\n\n\n### SpringBoot 中如何实现定时任务？\n\n我们使用`@Scheduled`注解就能很方便地创建一个定时任务。\n\n还需要再 SpringBoot 启动类上添加`@EnableScheduling`注解，这个注解的作用是发现`@Scheduled`的任务并在后台执行该任务。\n\n","source":"_posts/Spring八股文.md","raw":"---\ntitle: Spring应用与总结\ndate: 2024-06-22 18:11:04\ntags:\n  - Java\n  - Spring\n  - 总结\ncategories: Java\ncover: /img/springbaguwen.png\n---\n\n## Spring 常见面试题总结\n\n### 什么是Spring框架？\n\nSpring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。\n\n\n\n### 谈谈自己对于Spring IoC的了解\n\n**IoC** （Inversion of Control 控制反转）是一种设计模式，用来实现对象之间的解耦。\n\nIoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。\n\n\n\n#### 为什么叫控制反转？\n\n- **控制**：指的是对象创建（实例化、管理）的权利\n- **反转**：控制权交给外部环境（Spring框架、IoC容器）\n\n将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。\n\n\n\n### 什么是 Bean？\n\nBean 就是哪些被 IoC 容器所管理的对象。\n\n\n\n### @Component和@Bean的区别是什么？\n\n- @Component 注解用于类，@Bean 注解用于方法。\n- @Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。\n- @Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。\n\n\n\n### 注入Bean的注解有哪些？\n\nSpring 内置的`@Autowired` 还有 JDK 内置的 `@Resource` 和 `@Inject` 都可以用于注入 Bean。\n\n\n\n### @Autowired和@Resource的区别是什么？\n\n- `@Autowired` 是 Spring 提供的注解，`@Resource` 是 JDK 提供的注解。\n- `Autowired` 默认的注入方式为`byType`（根据类型进行匹配），`@Resource`默认注入方式为 `byName`（根据名称进行匹配）。\n- 当一个接口存在多个实现类的情况下，`@Autowired` 和 `@Resource` 都需要通过名称才能正确匹配到对应的  Bean。`Autowired` 可以通过 `@Qualifier` 注解来显式指定名称，`@Resource` 可以通过 name 属性来显式指定名称。\n- @Autowired 支持在构造函数、方法、字段和参数上使用。`@Resource` 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。\n\n\n\n### Bean 的作用域有哪些?\n\n- **Singleton** Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。\n- **prototype**  每次请求都会创建一个新的 bean 实例。\n- **Request** 每次 Http 请求都会创建一个新的 bean 实例。\n- **Session** 每个 Http Session 中会有一个 bean 实例。\n\n\n\n### Bean 是线程安全的吗？\n\n在 Spring 中 Bean 是否安全，取决于其作用域和状态。\n\n单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。\n\n\n\n### Bean的生命周期了解么？\n\nbean 的生命周期分为五个阶段：\n\n1. 调用构造器或者是通过工厂的方式创建 bean \n2. 给 bean 的属性注入值\n3. 调用初始化方法，进行初始化\n4. bean 被完全初始化和配置，就可以使用了\n5. 当 IOC 容器关闭的时候，销毁 bean\n\n\n\n### 谈谈对于AOP的了解\n\nAOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。\n\nSpring AOP 是通过动态代理来实现切面功能，**JDK动态代理**：用于代理实现了接口的类。**CGLIB代理**：用于代理没有实现接口的类，通过生成目标类的子类来实现。\n\n\n\n### Spring AOP 和 AspectJ AOP 有什么区别？\n\nSpring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。\n\n\n\n### AspectJ 定义的通知类型有哪些？\n\n- **Before**（前置通知）：在方法执行之前运行。\n\n- **After**（后置通知）：在方法执行之后运行，无论方法是否成功完成。\n\n- **AfterReturning**（返回通知）：在方法成功完成后运行。\n\n- **AfterThorowing**（异常通知）：在方法抛出异常后运行。\n\n- **Around**（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。\n\n  \n\n### 多个切面执行顺序如何控制？\n\n1. 通常使用`@Order` 注解直接定义切面顺序\n2. 实现`Ordered`接口重写`getOrder`方法\n\n\n\n### 说说自己对于 Spring MVC 了解？\n\nSpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。\n\n### SpringMVC 的工作流程是什么？\n\n1. 客户端请求首先到达`DispatcherServlet`。\n2. `DispatcherServlet`通过`HandlerMapping`找到具体的处理器（Controller）。\n3. `DispatcherServlet`通过`HandlerAdapter`调用处理器中的具体方法。\n4. 处理器方法执行完毕后返回`ModelAndView`对象，包含视图名称和模型数据。\n5. `DispatcherServlet`使用`ViewResolver`将视图名称解析为具体的视图。\n6. 最后，`DispatcherServlet`将模型数据传递给视图，视图渲染并返回响应给客户端。\n\n客户端发送请求 -> 2. DispatcherServlet接收请求 -> 3. HandlerMapping查找控制器 -> 4. HandlerAdapter调用控制器方法 -> 5. Controller处理请求 -> 6. ViewResolver解析视图 -> 7. 视图渲染 -> 8. 返回响应给客户端\n\n\n\n### 统一异常处理怎么做？\n\n使用注解的方式统一异常处理，使用`@controllerAdvice`和`@ExceptionHandler`这两个注解。\n\n\n\n### Spring 中用到了哪些设计模式？\n\n- **工厂设计模式**：Spring 使用工厂模式通过`BeanFactory`、`ApplicationContext`创建 bean 对象。\n- **代理设计模式**：SpringAOP 功能实现。\n- **单例设计模式**：Spring 中的 Bean 默认都是单例的。\n- **模版方法模式**：Spring 中`jdbcTemplate`、`hibernateTemplate`等以 Template 结尾的对数据库操作的类，都使用到了模版模式。\n- **包装器设计模式**：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。\n- **观察者模式**：Spring 事件驱动模型就是观察者模式。\n- **适配器模式**：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配`Controller`。\n\n\n\n### Spring 循环依赖了解吗，怎么解决？\n\nSpring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。\n\n#### 使用 setter 注入\n\nSpring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。\n\n#### 使用 @Lazy 注解\n\n在其中一个 Bean 的依赖上使用`@Lazy`注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。\n\n\n\n### Spring 管理事务的方式有几种？\n\n- **编程式事务**：在代码中硬编码（在分布式系统中推荐使用）：通过`TranscationTemplate`或者`TransactionManager`在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。\n- **声明式事务**：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于`@Transcational`的全注解方式使用最多）\n\n\n\n### Srping事务中哪几种事务传播行为？\n\n> 事务传播行为是为了解决业务层方法之间互相调用的事务问题。\n>\n> 当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。\n>\n> 例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。\n\n1. **`TransactionDefinition.PROPAGATION_REQUIRED`**：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。\n\n\n\n### 什么是 SpringBoot？为什么要有 SpringBoot？\n\nSpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）\n\n\n\n### 如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？\n\nSpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。\n\n\n\n\n\n### 介绍一下 @SpringBootApplication 注解\n\n`@SpringBootApplication`可以看作是`@Configuration、@EnableAutoConfiguration、@ComponentScan`注解的集合。\n\n- `@Configuration`：运行在上下文中注册额外的`bean`或导入其他配置类\n- `@EnableAutoConfiguration`：启用 Springboot 的自动配置机制\n- `@ComponentScan`：扫描被`@Component`(`@Service`,`@Controller`)注解的 bean，默认会扫描该类所在的包下的所有的类。\n\n\n\n### SpringBoot 的自动配置是如何实现的？\n\n当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。\n\nSpringBoot 会扫描`spring.factories`文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。\n\n\n\n### SpringBoot 常用的两种配置文件\n\n我们可以通过`applcation.properties`或者`application.yml`对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。\n\n\n\n### 什么是 YAML ? YAML配置的优势在哪里？\n\nYAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。\n\n相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。\n\n但是 YAML 配置文件不支持`@PropertySource` 注解导入自定义的 YAML 配置。\n\n\n\n### SpringBoot 常用的读取配置文件的方法有哪些？\n\n1. 通过`@Value(\"${property}\")`读取比较简单的配置信息\n\n   > `@value` 这种方式是不被推荐的\n\n2. 通过`@ConfigurationProperties`读取并与 bean 绑定\n\n3. 通过`@ConfigurationProperies`读取并校验\n\n4. 通过`@PropertySource`读取指定的 properties 文件\n\n\n\n### SpringBoot 如何做请求参数校验？\n\n使用 JSR 提供的校验注解\n\n\n\n### SpringBoot 如何监控系统运行状态？\n\n可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。\n\n\n\n\n\n### SpringBoot 中如何实现定时任务？\n\n我们使用`@Scheduled`注解就能很方便地创建一个定时任务。\n\n还需要再 SpringBoot 启动类上添加`@EnableScheduling`注解，这个注解的作用是发现`@Scheduled`的任务并在后台执行该任务。\n\n","slug":"Spring八股文","published":1,"updated":"2024-07-05T14:19:07.155Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gs000jtuj8am9vgv7o","content":"<h2 id=\"Spring-常见面试题总结\"><a class=\"headerlink\" href=\"#Spring-常见面试题总结\"></a>Spring 常见面试题总结</h2>\n<h3 id=\"什么是Spring框架？\"><a class=\"headerlink\" href=\"#什么是Spring框架？\"></a>什么是Spring框架？</h3>\n<p>Spring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。</p>\n<h3 id=\"谈谈自己对于Spring-IoC的了解\"><a class=\"headerlink\" href=\"#谈谈自己对于Spring-IoC的了解\"></a>谈谈自己对于Spring IoC的了解</h3>\n<p><strong>IoC</strong> （Inversion of Control 控制反转）是一种设计模式，用来实现对象之间的解耦。</p>\n<p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。</p>\n<h4 id=\"为什么叫控制反转？\"><a class=\"headerlink\" href=\"#为什么叫控制反转？\"></a>为什么叫控制反转？</h4>\n<ul>\n<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权利</li>\n<li><strong>反转</strong>：控制权交给外部环境（Spring框架、IoC容器）</li>\n</ul>\n<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。</p>\n<h3 id=\"什么是-Bean？\"><a class=\"headerlink\" href=\"#什么是-Bean？\"></a>什么是 Bean？</h3>\n<p>Bean 就是哪些被 IoC 容器所管理的对象。</p>\n<h3 id=\"Component和-Bean的区别是什么？\"><a class=\"headerlink\" href=\"#Component和-Bean的区别是什么？\"></a>@Component和@Bean的区别是什么？</h3>\n<ul>\n<li>@Component 注解用于类，@Bean 注解用于方法。</li>\n<li>@Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。</li>\n<li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。</li>\n</ul>\n<h3 id=\"注入Bean的注解有哪些？\"><a class=\"headerlink\" href=\"#注入Bean的注解有哪些？\"></a>注入Bean的注解有哪些？</h3>\n<p>Spring 内置的<code>@Autowired</code> 还有 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>\n<h3 id=\"Autowired和-Resource的区别是什么？\"><a class=\"headerlink\" href=\"#Autowired和-Resource的区别是什么？\"></a>@Autowired和@Resource的区别是什么？</h3>\n<ul>\n<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>\n<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>\n<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code> 都需要通过名称才能正确匹配到对应的  Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code> 可以通过 name 属性来显式指定名称。</li>\n<li>@Autowired 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li>\n</ul>\n<h3 id=\"Bean-的作用域有哪些\"><a class=\"headerlink\" href=\"#Bean-的作用域有哪些\"></a>Bean 的作用域有哪些?</h3>\n<ul>\n<li><strong>Singleton</strong> Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。</li>\n<li><strong>prototype</strong>  每次请求都会创建一个新的 bean 实例。</li>\n<li><strong>Request</strong> 每次 Http 请求都会创建一个新的 bean 实例。</li>\n<li><strong>Session</strong> 每个 Http Session 中会有一个 bean 实例。</li>\n</ul>\n<h3 id=\"Bean-是线程安全的吗？\"><a class=\"headerlink\" href=\"#Bean-是线程安全的吗？\"></a>Bean 是线程安全的吗？</h3>\n<p>在 Spring 中 Bean 是否安全，取决于其作用域和状态。</p>\n<p>单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。</p>\n<h3 id=\"Bean的生命周期了解么？\"><a class=\"headerlink\" href=\"#Bean的生命周期了解么？\"></a>Bean的生命周期了解么？</h3>\n<p>bean 的生命周期分为五个阶段：</p>\n<ol>\n<li>调用构造器或者是通过工厂的方式创建 bean</li>\n<li>给 bean 的属性注入值</li>\n<li>调用初始化方法，进行初始化</li>\n<li>bean 被完全初始化和配置，就可以使用了</li>\n<li>当 IOC 容器关闭的时候，销毁 bean</li>\n</ol>\n<h3 id=\"谈谈对于AOP的了解\"><a class=\"headerlink\" href=\"#谈谈对于AOP的了解\"></a>谈谈对于AOP的了解</h3>\n<p>AOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。</p>\n<p>Spring AOP 是通过动态代理来实现切面功能，<strong>JDK动态代理</strong>：用于代理实现了接口的类。<strong>CGLIB代理</strong>：用于代理没有实现接口的类，通过生成目标类的子类来实现。</p>\n<h3 id=\"Spring-AOP-和-AspectJ-AOP-有什么区别？\"><a class=\"headerlink\" href=\"#Spring-AOP-和-AspectJ-AOP-有什么区别？\"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3>\n<p>Spring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。</p>\n<h3 id=\"AspectJ-定义的通知类型有哪些？\"><a class=\"headerlink\" href=\"#AspectJ-定义的通知类型有哪些？\"></a>AspectJ 定义的通知类型有哪些？</h3>\n<ul>\n<li>\n<p><strong>Before</strong>（前置通知）：在方法执行之前运行。</p>\n</li>\n<li>\n<p><strong>After</strong>（后置通知）：在方法执行之后运行，无论方法是否成功完成。</p>\n</li>\n<li>\n<p><strong>AfterReturning</strong>（返回通知）：在方法成功完成后运行。</p>\n</li>\n<li>\n<p><strong>AfterThorowing</strong>（异常通知）：在方法抛出异常后运行。</p>\n</li>\n<li>\n<p><strong>Around</strong>（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。</p>\n</li>\n</ul>\n<h3 id=\"多个切面执行顺序如何控制？\"><a class=\"headerlink\" href=\"#多个切面执行顺序如何控制？\"></a>多个切面执行顺序如何控制？</h3>\n<ol>\n<li>通常使用<code>@Order</code> 注解直接定义切面顺序</li>\n<li>实现<code>Ordered</code>接口重写<code>getOrder</code>方法</li>\n</ol>\n<h3 id=\"说说自己对于-Spring-MVC-了解？\"><a class=\"headerlink\" href=\"#说说自己对于-Spring-MVC-了解？\"></a>说说自己对于 Spring MVC 了解？</h3>\n<p>SpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。</p>\n<h3 id=\"SpringMVC-的工作流程是什么？\"><a class=\"headerlink\" href=\"#SpringMVC-的工作流程是什么？\"></a>SpringMVC 的工作流程是什么？</h3>\n<ol>\n<li>客户端请求首先到达<code>DispatcherServlet</code>。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerMapping</code>找到具体的处理器（Controller）。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerAdapter</code>调用处理器中的具体方法。</li>\n<li>处理器方法执行完毕后返回<code>ModelAndView</code>对象，包含视图名称和模型数据。</li>\n<li><code>DispatcherServlet</code>使用<code>ViewResolver</code>将视图名称解析为具体的视图。</li>\n<li>最后，<code>DispatcherServlet</code>将模型数据传递给视图，视图渲染并返回响应给客户端。</li>\n</ol>\n<p>客户端发送请求 -&gt; 2. DispatcherServlet接收请求 -&gt; 3. HandlerMapping查找控制器 -&gt; 4. HandlerAdapter调用控制器方法 -&gt; 5. Controller处理请求 -&gt; 6. ViewResolver解析视图 -&gt; 7. 视图渲染 -&gt; 8. 返回响应给客户端</p>\n<h3 id=\"统一异常处理怎么做？\"><a class=\"headerlink\" href=\"#统一异常处理怎么做？\"></a>统一异常处理怎么做？</h3>\n<p>使用注解的方式统一异常处理，使用<code>@controllerAdvice</code>和<code>@ExceptionHandler</code>这两个注解。</p>\n<h3 id=\"Spring-中用到了哪些设计模式？\"><a class=\"headerlink\" href=\"#Spring-中用到了哪些设计模式？\"></a>Spring 中用到了哪些设计模式？</h3>\n<ul>\n<li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过<code>BeanFactory</code>、<code>ApplicationContext</code>创建 bean 对象。</li>\n<li><strong>代理设计模式</strong>：SpringAOP 功能实现。</li>\n<li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li>\n<li><strong>模版方法模式</strong>：Spring 中<code>jdbcTemplate</code>、<code>hibernateTemplate</code>等以 Template 结尾的对数据库操作的类，都使用到了模版模式。</li>\n<li><strong>包装器设计模式</strong>：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。</li>\n<li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式。</li>\n<li><strong>适配器模式</strong>：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配<code>Controller</code>。</li>\n</ul>\n<h3 id=\"Spring-循环依赖了解吗，怎么解决？\"><a class=\"headerlink\" href=\"#Spring-循环依赖了解吗，怎么解决？\"></a>Spring 循环依赖了解吗，怎么解决？</h3>\n<p>Spring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。</p>\n<h4 id=\"使用-setter-注入\"><a class=\"headerlink\" href=\"#使用-setter-注入\"></a>使用 setter 注入</h4>\n<p>Spring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。</p>\n<h4 id=\"使用-Lazy-注解\"><a class=\"headerlink\" href=\"#使用-Lazy-注解\"></a>使用 @Lazy 注解</h4>\n<p>在其中一个 Bean 的依赖上使用<code>@Lazy</code>注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。</p>\n<h3 id=\"Spring-管理事务的方式有几种？\"><a class=\"headerlink\" href=\"#Spring-管理事务的方式有几种？\"></a>Spring 管理事务的方式有几种？</h3>\n<ul>\n<li><strong>编程式事务</strong>：在代码中硬编码（在分布式系统中推荐使用）：通过<code>TranscationTemplate</code>或者<code>TransactionManager</code>在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li>\n<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于<code>@Transcational</code>的全注解方式使用最多）</li>\n</ul>\n<h3 id=\"Srping事务中哪几种事务传播行为？\"><a class=\"headerlink\" href=\"#Srping事务中哪几种事务传播行为？\"></a>Srping事务中哪几种事务传播行为？</h3>\n<blockquote>\n<p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p>\n<p>当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。</p>\n<p>例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。</p>\n</blockquote>\n<ol>\n<li><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。</li>\n</ol>\n<h3 id=\"什么是-SpringBoot？为什么要有-SpringBoot？\"><a class=\"headerlink\" href=\"#什么是-SpringBoot？为什么要有-SpringBoot？\"></a>什么是 SpringBoot？为什么要有 SpringBoot？</h3>\n<p>SpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）</p>\n<h3 id=\"如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"><a class=\"headerlink\" href=\"#如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"></a>如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？</h3>\n<p>SpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。</p>\n<h3 id=\"介绍一下-SpringBootApplication-注解\"><a class=\"headerlink\" href=\"#介绍一下-SpringBootApplication-注解\"></a>介绍一下 @SpringBootApplication 注解</h3>\n<p><code>@SpringBootApplication</code>可以看作是<code>@Configuration、@EnableAutoConfiguration、@ComponentScan</code>注解的集合。</p>\n<ul>\n<li><code>@Configuration</code>：运行在上下文中注册额外的<code>bean</code>或导入其他配置类</li>\n<li><code>@EnableAutoConfiguration</code>：启用 Springboot 的自动配置机制</li>\n<li><code>@ComponentScan</code>：扫描被<code>@Component</code>(<code>@Service</code>,<code>@Controller</code>)注解的 bean，默认会扫描该类所在的包下的所有的类。</li>\n</ul>\n<h3 id=\"SpringBoot-的自动配置是如何实现的？\"><a class=\"headerlink\" href=\"#SpringBoot-的自动配置是如何实现的？\"></a>SpringBoot 的自动配置是如何实现的？</h3>\n<p>当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。</p>\n<p>SpringBoot 会扫描<code>spring.factories</code>文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。</p>\n<h3 id=\"SpringBoot-常用的两种配置文件\"><a class=\"headerlink\" href=\"#SpringBoot-常用的两种配置文件\"></a>SpringBoot 常用的两种配置文件</h3>\n<p>我们可以通过<code>applcation.properties</code>或者<code>application.yml</code>对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。</p>\n<h3 id=\"什么是-YAML-YAML配置的优势在哪里？\"><a class=\"headerlink\" href=\"#什么是-YAML-YAML配置的优势在哪里？\"></a>什么是 YAML ? YAML配置的优势在哪里？</h3>\n<p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>\n<p>相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。</p>\n<p>但是 YAML 配置文件不支持<code>@PropertySource</code> 注解导入自定义的 YAML 配置。</p>\n<h3 id=\"SpringBoot-常用的读取配置文件的方法有哪些？\"><a class=\"headerlink\" href=\"#SpringBoot-常用的读取配置文件的方法有哪些？\"></a>SpringBoot 常用的读取配置文件的方法有哪些？</h3>\n<ol>\n<li>\n<p>通过<code>@Value(&quot;$&#123;property&#125;&quot;)</code>读取比较简单的配置信息</p>\n<blockquote>\n<p><code>@value</code> 这种方式是不被推荐的</p>\n</blockquote>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperties</code>读取并与 bean 绑定</p>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperies</code>读取并校验</p>\n</li>\n<li>\n<p>通过<code>@PropertySource</code>读取指定的 properties 文件</p>\n</li>\n</ol>\n<h3 id=\"SpringBoot-如何做请求参数校验？\"><a class=\"headerlink\" href=\"#SpringBoot-如何做请求参数校验？\"></a>SpringBoot 如何做请求参数校验？</h3>\n<p>使用 JSR 提供的校验注解</p>\n<h3 id=\"SpringBoot-如何监控系统运行状态？\"><a class=\"headerlink\" href=\"#SpringBoot-如何监控系统运行状态？\"></a>SpringBoot 如何监控系统运行状态？</h3>\n<p>可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。</p>\n<h3 id=\"SpringBoot-中如何实现定时任务？\"><a class=\"headerlink\" href=\"#SpringBoot-中如何实现定时任务？\"></a>SpringBoot 中如何实现定时任务？</h3>\n<p>我们使用<code>@Scheduled</code>注解就能很方便地创建一个定时任务。</p>\n<p>还需要再 SpringBoot 启动类上添加<code>@EnableScheduling</code>注解，这个注解的作用是发现<code>@Scheduled</code>的任务并在后台执行该任务。</p>\n","excerpt":"","more":"<h2 id=\"Spring-常见面试题总结\"><a class=\"headerlink\" href=\"#Spring-常见面试题总结\"></a>Spring 常见面试题总结</h2>\n<h3 id=\"什么是Spring框架？\"><a class=\"headerlink\" href=\"#什么是Spring框架？\"></a>什么是Spring框架？</h3>\n<p>Spring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。</p>\n<h3 id=\"谈谈自己对于Spring-IoC的了解\"><a class=\"headerlink\" href=\"#谈谈自己对于Spring-IoC的了解\"></a>谈谈自己对于Spring IoC的了解</h3>\n<p><strong>IoC</strong> （Inversion of Control 控制反转）是一种设计模式，用来实现对象之间的解耦。</p>\n<p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。</p>\n<h4 id=\"为什么叫控制反转？\"><a class=\"headerlink\" href=\"#为什么叫控制反转？\"></a>为什么叫控制反转？</h4>\n<ul>\n<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权利</li>\n<li><strong>反转</strong>：控制权交给外部环境（Spring框架、IoC容器）</li>\n</ul>\n<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。</p>\n<h3 id=\"什么是-Bean？\"><a class=\"headerlink\" href=\"#什么是-Bean？\"></a>什么是 Bean？</h3>\n<p>Bean 就是哪些被 IoC 容器所管理的对象。</p>\n<h3 id=\"Component和-Bean的区别是什么？\"><a class=\"headerlink\" href=\"#Component和-Bean的区别是什么？\"></a>@Component和@Bean的区别是什么？</h3>\n<ul>\n<li>@Component 注解用于类，@Bean 注解用于方法。</li>\n<li>@Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。</li>\n<li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。</li>\n</ul>\n<h3 id=\"注入Bean的注解有哪些？\"><a class=\"headerlink\" href=\"#注入Bean的注解有哪些？\"></a>注入Bean的注解有哪些？</h3>\n<p>Spring 内置的<code>@Autowired</code> 还有 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>\n<h3 id=\"Autowired和-Resource的区别是什么？\"><a class=\"headerlink\" href=\"#Autowired和-Resource的区别是什么？\"></a>@Autowired和@Resource的区别是什么？</h3>\n<ul>\n<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>\n<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>\n<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code> 都需要通过名称才能正确匹配到对应的  Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code> 可以通过 name 属性来显式指定名称。</li>\n<li>@Autowired 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li>\n</ul>\n<h3 id=\"Bean-的作用域有哪些\"><a class=\"headerlink\" href=\"#Bean-的作用域有哪些\"></a>Bean 的作用域有哪些?</h3>\n<ul>\n<li><strong>Singleton</strong> Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。</li>\n<li><strong>prototype</strong>  每次请求都会创建一个新的 bean 实例。</li>\n<li><strong>Request</strong> 每次 Http 请求都会创建一个新的 bean 实例。</li>\n<li><strong>Session</strong> 每个 Http Session 中会有一个 bean 实例。</li>\n</ul>\n<h3 id=\"Bean-是线程安全的吗？\"><a class=\"headerlink\" href=\"#Bean-是线程安全的吗？\"></a>Bean 是线程安全的吗？</h3>\n<p>在 Spring 中 Bean 是否安全，取决于其作用域和状态。</p>\n<p>单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。</p>\n<h3 id=\"Bean的生命周期了解么？\"><a class=\"headerlink\" href=\"#Bean的生命周期了解么？\"></a>Bean的生命周期了解么？</h3>\n<p>bean 的生命周期分为五个阶段：</p>\n<ol>\n<li>调用构造器或者是通过工厂的方式创建 bean</li>\n<li>给 bean 的属性注入值</li>\n<li>调用初始化方法，进行初始化</li>\n<li>bean 被完全初始化和配置，就可以使用了</li>\n<li>当 IOC 容器关闭的时候，销毁 bean</li>\n</ol>\n<h3 id=\"谈谈对于AOP的了解\"><a class=\"headerlink\" href=\"#谈谈对于AOP的了解\"></a>谈谈对于AOP的了解</h3>\n<p>AOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。</p>\n<p>Spring AOP 是通过动态代理来实现切面功能，<strong>JDK动态代理</strong>：用于代理实现了接口的类。<strong>CGLIB代理</strong>：用于代理没有实现接口的类，通过生成目标类的子类来实现。</p>\n<h3 id=\"Spring-AOP-和-AspectJ-AOP-有什么区别？\"><a class=\"headerlink\" href=\"#Spring-AOP-和-AspectJ-AOP-有什么区别？\"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3>\n<p>Spring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。</p>\n<h3 id=\"AspectJ-定义的通知类型有哪些？\"><a class=\"headerlink\" href=\"#AspectJ-定义的通知类型有哪些？\"></a>AspectJ 定义的通知类型有哪些？</h3>\n<ul>\n<li>\n<p><strong>Before</strong>（前置通知）：在方法执行之前运行。</p>\n</li>\n<li>\n<p><strong>After</strong>（后置通知）：在方法执行之后运行，无论方法是否成功完成。</p>\n</li>\n<li>\n<p><strong>AfterReturning</strong>（返回通知）：在方法成功完成后运行。</p>\n</li>\n<li>\n<p><strong>AfterThorowing</strong>（异常通知）：在方法抛出异常后运行。</p>\n</li>\n<li>\n<p><strong>Around</strong>（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。</p>\n</li>\n</ul>\n<h3 id=\"多个切面执行顺序如何控制？\"><a class=\"headerlink\" href=\"#多个切面执行顺序如何控制？\"></a>多个切面执行顺序如何控制？</h3>\n<ol>\n<li>通常使用<code>@Order</code> 注解直接定义切面顺序</li>\n<li>实现<code>Ordered</code>接口重写<code>getOrder</code>方法</li>\n</ol>\n<h3 id=\"说说自己对于-Spring-MVC-了解？\"><a class=\"headerlink\" href=\"#说说自己对于-Spring-MVC-了解？\"></a>说说自己对于 Spring MVC 了解？</h3>\n<p>SpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。</p>\n<h3 id=\"SpringMVC-的工作流程是什么？\"><a class=\"headerlink\" href=\"#SpringMVC-的工作流程是什么？\"></a>SpringMVC 的工作流程是什么？</h3>\n<ol>\n<li>客户端请求首先到达<code>DispatcherServlet</code>。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerMapping</code>找到具体的处理器（Controller）。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerAdapter</code>调用处理器中的具体方法。</li>\n<li>处理器方法执行完毕后返回<code>ModelAndView</code>对象，包含视图名称和模型数据。</li>\n<li><code>DispatcherServlet</code>使用<code>ViewResolver</code>将视图名称解析为具体的视图。</li>\n<li>最后，<code>DispatcherServlet</code>将模型数据传递给视图，视图渲染并返回响应给客户端。</li>\n</ol>\n<p>客户端发送请求 -&gt; 2. DispatcherServlet接收请求 -&gt; 3. HandlerMapping查找控制器 -&gt; 4. HandlerAdapter调用控制器方法 -&gt; 5. Controller处理请求 -&gt; 6. ViewResolver解析视图 -&gt; 7. 视图渲染 -&gt; 8. 返回响应给客户端</p>\n<h3 id=\"统一异常处理怎么做？\"><a class=\"headerlink\" href=\"#统一异常处理怎么做？\"></a>统一异常处理怎么做？</h3>\n<p>使用注解的方式统一异常处理，使用<code>@controllerAdvice</code>和<code>@ExceptionHandler</code>这两个注解。</p>\n<h3 id=\"Spring-中用到了哪些设计模式？\"><a class=\"headerlink\" href=\"#Spring-中用到了哪些设计模式？\"></a>Spring 中用到了哪些设计模式？</h3>\n<ul>\n<li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过<code>BeanFactory</code>、<code>ApplicationContext</code>创建 bean 对象。</li>\n<li><strong>代理设计模式</strong>：SpringAOP 功能实现。</li>\n<li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li>\n<li><strong>模版方法模式</strong>：Spring 中<code>jdbcTemplate</code>、<code>hibernateTemplate</code>等以 Template 结尾的对数据库操作的类，都使用到了模版模式。</li>\n<li><strong>包装器设计模式</strong>：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。</li>\n<li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式。</li>\n<li><strong>适配器模式</strong>：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配<code>Controller</code>。</li>\n</ul>\n<h3 id=\"Spring-循环依赖了解吗，怎么解决？\"><a class=\"headerlink\" href=\"#Spring-循环依赖了解吗，怎么解决？\"></a>Spring 循环依赖了解吗，怎么解决？</h3>\n<p>Spring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。</p>\n<h4 id=\"使用-setter-注入\"><a class=\"headerlink\" href=\"#使用-setter-注入\"></a>使用 setter 注入</h4>\n<p>Spring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。</p>\n<h4 id=\"使用-Lazy-注解\"><a class=\"headerlink\" href=\"#使用-Lazy-注解\"></a>使用 @Lazy 注解</h4>\n<p>在其中一个 Bean 的依赖上使用<code>@Lazy</code>注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。</p>\n<h3 id=\"Spring-管理事务的方式有几种？\"><a class=\"headerlink\" href=\"#Spring-管理事务的方式有几种？\"></a>Spring 管理事务的方式有几种？</h3>\n<ul>\n<li><strong>编程式事务</strong>：在代码中硬编码（在分布式系统中推荐使用）：通过<code>TranscationTemplate</code>或者<code>TransactionManager</code>在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li>\n<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于<code>@Transcational</code>的全注解方式使用最多）</li>\n</ul>\n<h3 id=\"Srping事务中哪几种事务传播行为？\"><a class=\"headerlink\" href=\"#Srping事务中哪几种事务传播行为？\"></a>Srping事务中哪几种事务传播行为？</h3>\n<blockquote>\n<p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p>\n<p>当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。</p>\n<p>例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。</p>\n</blockquote>\n<ol>\n<li><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。</li>\n</ol>\n<h3 id=\"什么是-SpringBoot？为什么要有-SpringBoot？\"><a class=\"headerlink\" href=\"#什么是-SpringBoot？为什么要有-SpringBoot？\"></a>什么是 SpringBoot？为什么要有 SpringBoot？</h3>\n<p>SpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）</p>\n<h3 id=\"如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"><a class=\"headerlink\" href=\"#如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"></a>如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？</h3>\n<p>SpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。</p>\n<h3 id=\"介绍一下-SpringBootApplication-注解\"><a class=\"headerlink\" href=\"#介绍一下-SpringBootApplication-注解\"></a>介绍一下 @SpringBootApplication 注解</h3>\n<p><code>@SpringBootApplication</code>可以看作是<code>@Configuration、@EnableAutoConfiguration、@ComponentScan</code>注解的集合。</p>\n<ul>\n<li><code>@Configuration</code>：运行在上下文中注册额外的<code>bean</code>或导入其他配置类</li>\n<li><code>@EnableAutoConfiguration</code>：启用 Springboot 的自动配置机制</li>\n<li><code>@ComponentScan</code>：扫描被<code>@Component</code>(<code>@Service</code>,<code>@Controller</code>)注解的 bean，默认会扫描该类所在的包下的所有的类。</li>\n</ul>\n<h3 id=\"SpringBoot-的自动配置是如何实现的？\"><a class=\"headerlink\" href=\"#SpringBoot-的自动配置是如何实现的？\"></a>SpringBoot 的自动配置是如何实现的？</h3>\n<p>当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。</p>\n<p>SpringBoot 会扫描<code>spring.factories</code>文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。</p>\n<h3 id=\"SpringBoot-常用的两种配置文件\"><a class=\"headerlink\" href=\"#SpringBoot-常用的两种配置文件\"></a>SpringBoot 常用的两种配置文件</h3>\n<p>我们可以通过<code>applcation.properties</code>或者<code>application.yml</code>对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。</p>\n<h3 id=\"什么是-YAML-YAML配置的优势在哪里？\"><a class=\"headerlink\" href=\"#什么是-YAML-YAML配置的优势在哪里？\"></a>什么是 YAML ? YAML配置的优势在哪里？</h3>\n<p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>\n<p>相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。</p>\n<p>但是 YAML 配置文件不支持<code>@PropertySource</code> 注解导入自定义的 YAML 配置。</p>\n<h3 id=\"SpringBoot-常用的读取配置文件的方法有哪些？\"><a class=\"headerlink\" href=\"#SpringBoot-常用的读取配置文件的方法有哪些？\"></a>SpringBoot 常用的读取配置文件的方法有哪些？</h3>\n<ol>\n<li>\n<p>通过<code>@Value(&quot;$&#123;property&#125;&quot;)</code>读取比较简单的配置信息</p>\n<blockquote>\n<p><code>@value</code> 这种方式是不被推荐的</p>\n</blockquote>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperties</code>读取并与 bean 绑定</p>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperies</code>读取并校验</p>\n</li>\n<li>\n<p>通过<code>@PropertySource</code>读取指定的 properties 文件</p>\n</li>\n</ol>\n<h3 id=\"SpringBoot-如何做请求参数校验？\"><a class=\"headerlink\" href=\"#SpringBoot-如何做请求参数校验？\"></a>SpringBoot 如何做请求参数校验？</h3>\n<p>使用 JSR 提供的校验注解</p>\n<h3 id=\"SpringBoot-如何监控系统运行状态？\"><a class=\"headerlink\" href=\"#SpringBoot-如何监控系统运行状态？\"></a>SpringBoot 如何监控系统运行状态？</h3>\n<p>可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。</p>\n<h3 id=\"SpringBoot-中如何实现定时任务？\"><a class=\"headerlink\" href=\"#SpringBoot-中如何实现定时任务？\"></a>SpringBoot 中如何实现定时任务？</h3>\n<p>我们使用<code>@Scheduled</code>注解就能很方便地创建一个定时任务。</p>\n<p>还需要再 SpringBoot 启动类上添加<code>@EnableScheduling</code>注解，这个注解的作用是发现<code>@Scheduled</code>的任务并在后台执行该任务。</p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"Vaultwarden搭建","date":"2024-06-24T08:56:37.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E8%93%9D%E7%9C%BC%E7%9D%9B%E3%80%912024-06-25%2013_32_45.png","categorizes":"Linux","_content":"\n# 如何搭建 Vaultwarden 服务器：一步步教程\n\nVaultwarden 是一个轻量级的 Bitwarden 服务器实现，它使用 Rust 编写，可以方便地在几乎任何地方运行。这是一个非常适合个人或小团队的密码管理解决方案。在本教程中，我们将详细介绍如何使用 Docker Compose 在你的服务器上部署 Vaultwarden。\n\n## 前提条件\n\n在开始之前，确保你的系统已经安装了 **Docker** 和 **Docker Compose**。\n\n## 步骤 1: 创建数据存储目录\n\n首先，我们需要为 Vaultwarden 创建一个目录来存储数据。这将确保即使容器被删除，数据也会保持安全。\n\n```bash\nmkdir -p /opt/docker_data/vaultwarden\ncd /opt/docker_data/vaultwarden\n```\n\n## 步骤 2: 创建 Docker Compose 文件\n\n接下来，我们将创建一个 `docker-compose.yml` 文件来定义 Vaultwarden 服务的配置。使用你喜欢的文本编辑器创建文件：\n\n```bash\nvim docker-compose.yml\n```\n\n然后，将以下配置粘贴到 `docker-compose.yml` 文件中：\n\n```yaml\nversion: '3'\n\nservices:\n  vaultwarden:\n    container_name: vaultwarden\n    image: vaultwarden/server:latest\n    restart: unless-stopped\n    volumes:\n      - ./data/:/data/\n    ports:\n      - 8080:80\n    environment:\n      - DOMAIN=https://subdomain.yourdomain.com # 关联的域名。\n      - LOGIN_RATELIMIT_MAX_BURST=10 # 最大请求次数。\n      - LOGIN_RATELIMIT_SECONDS=60 # 平均秒数\n      - ADMIN_RATELIMIT_MAX_BURST=10 # admin最大请求次数。\n      - ADMIN_RATELIMIT_SECONDS=60 # 平均秒数\n      - ADMIN_SESSION_LIFETIME=20 # 会话持续时间\n      - ADMIN_TOKEN=YourReallyStrongAdminTokenHere # 管理员面板的令牌\n      - SENDS_ALLOWED=true  # 是否允许用户创建Bitwarden发送\n      - EMERGENCY_ACCESS_ALLOWED=true # 控制用户是否可以启用紧急访问其账户的权限\n      - WEB_VAULT_ENABLED=true # 网络保险库是否可访问。\n      - SIGNUPS_ALLOWED=true # 新用户是否可以在没有邀请的情况下注册账户\n```\n\n## 步骤 3: 启动 Vaultwarden\n\n配置好 `docker-compose.yml` 文件后，使用以下命令启动 Vaultwarden 服务：\n\n```bash\ndocker-compose up -d\n```\n\n这个命令会在后台启动 Vaultwarden 服务。可以通过访问 `http://localhost:8080` 或在配置文件中指定的域名来访问 Vaultwarden。\n\n\n## 总结\n\n恭喜！你现在已经成功在你的服务器上部署了 Vaultwarden。通过使用 Docker Compose，你可以轻松管理 Vaultwarden 服务的配置和更新。继续探索 Vaultwarden 的其他功能，为你的密码管理提供更强大的支持！\n","source":"_posts/Vaultwarden搭建.md","raw":"---\ntitle: Vaultwarden搭建\ndate: 2024-06-24 16:56:37\ntags: Linux\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E8%93%9D%E7%9C%BC%E7%9D%9B%E3%80%912024-06-25%2013_32_45.png\ncategorizes: Linux\n---\n\n# 如何搭建 Vaultwarden 服务器：一步步教程\n\nVaultwarden 是一个轻量级的 Bitwarden 服务器实现，它使用 Rust 编写，可以方便地在几乎任何地方运行。这是一个非常适合个人或小团队的密码管理解决方案。在本教程中，我们将详细介绍如何使用 Docker Compose 在你的服务器上部署 Vaultwarden。\n\n## 前提条件\n\n在开始之前，确保你的系统已经安装了 **Docker** 和 **Docker Compose**。\n\n## 步骤 1: 创建数据存储目录\n\n首先，我们需要为 Vaultwarden 创建一个目录来存储数据。这将确保即使容器被删除，数据也会保持安全。\n\n```bash\nmkdir -p /opt/docker_data/vaultwarden\ncd /opt/docker_data/vaultwarden\n```\n\n## 步骤 2: 创建 Docker Compose 文件\n\n接下来，我们将创建一个 `docker-compose.yml` 文件来定义 Vaultwarden 服务的配置。使用你喜欢的文本编辑器创建文件：\n\n```bash\nvim docker-compose.yml\n```\n\n然后，将以下配置粘贴到 `docker-compose.yml` 文件中：\n\n```yaml\nversion: '3'\n\nservices:\n  vaultwarden:\n    container_name: vaultwarden\n    image: vaultwarden/server:latest\n    restart: unless-stopped\n    volumes:\n      - ./data/:/data/\n    ports:\n      - 8080:80\n    environment:\n      - DOMAIN=https://subdomain.yourdomain.com # 关联的域名。\n      - LOGIN_RATELIMIT_MAX_BURST=10 # 最大请求次数。\n      - LOGIN_RATELIMIT_SECONDS=60 # 平均秒数\n      - ADMIN_RATELIMIT_MAX_BURST=10 # admin最大请求次数。\n      - ADMIN_RATELIMIT_SECONDS=60 # 平均秒数\n      - ADMIN_SESSION_LIFETIME=20 # 会话持续时间\n      - ADMIN_TOKEN=YourReallyStrongAdminTokenHere # 管理员面板的令牌\n      - SENDS_ALLOWED=true  # 是否允许用户创建Bitwarden发送\n      - EMERGENCY_ACCESS_ALLOWED=true # 控制用户是否可以启用紧急访问其账户的权限\n      - WEB_VAULT_ENABLED=true # 网络保险库是否可访问。\n      - SIGNUPS_ALLOWED=true # 新用户是否可以在没有邀请的情况下注册账户\n```\n\n## 步骤 3: 启动 Vaultwarden\n\n配置好 `docker-compose.yml` 文件后，使用以下命令启动 Vaultwarden 服务：\n\n```bash\ndocker-compose up -d\n```\n\n这个命令会在后台启动 Vaultwarden 服务。可以通过访问 `http://localhost:8080` 或在配置文件中指定的域名来访问 Vaultwarden。\n\n\n## 总结\n\n恭喜！你现在已经成功在你的服务器上部署了 Vaultwarden。通过使用 Docker Compose，你可以轻松管理 Vaultwarden 服务的配置和更新。继续探索 Vaultwarden 的其他功能，为你的密码管理提供更强大的支持！\n","slug":"Vaultwarden搭建","published":1,"updated":"2024-07-11T10:13:57.858Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gv000ntuj8b9fxeq5i","content":"<h1 id=\"如何搭建-Vaultwarden-服务器：一步步教程\"><a class=\"headerlink\" href=\"#如何搭建-Vaultwarden-服务器：一步步教程\"></a>如何搭建 Vaultwarden 服务器：一步步教程</h1>\n<p>Vaultwarden 是一个轻量级的 Bitwarden 服务器实现，它使用 Rust 编写，可以方便地在几乎任何地方运行。这是一个非常适合个人或小团队的密码管理解决方案。在本教程中，我们将详细介绍如何使用 Docker Compose 在你的服务器上部署 Vaultwarden。</p>\n<h2 id=\"前提条件\"><a class=\"headerlink\" href=\"#前提条件\"></a>前提条件</h2>\n<p>在开始之前，确保你的系统已经安装了 <strong>Docker</strong> 和 <strong>Docker Compose</strong>。</p>\n<h2 id=\"步骤-1-创建数据存储目录\"><a class=\"headerlink\" href=\"#步骤-1-创建数据存储目录\"></a>步骤 1: 创建数据存储目录</h2>\n<p>首先，我们需要为 Vaultwarden 创建一个目录来存储数据。这将确保即使容器被删除，数据也会保持安全。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /opt/docker_data/vaultwarden\n<span class=\"token builtin class-name\">cd</span> /opt/docker_data/vaultwarden<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"步骤-2-创建-Docker-Compose-文件\"><a class=\"headerlink\" href=\"#步骤-2-创建-Docker-Compose-文件\"></a>步骤 2: 创建 Docker Compose 文件</h2>\n<p>接下来，我们将创建一个 <code>docker-compose.yml</code> 文件来定义 Vaultwarden 服务的配置。使用你喜欢的文本编辑器创建文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vim</span> docker-compose.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后，将以下配置粘贴到 <code>docker-compose.yml</code> 文件中：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3'</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">vaultwarden</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> vaultwarden\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> vaultwarden/server<span class=\"token punctuation\">:</span>latest\n    <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> unless<span class=\"token punctuation\">-</span>stopped\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./data/<span class=\"token punctuation\">:</span>/data/\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> DOMAIN=https<span class=\"token punctuation\">:</span>//subdomain.yourdomain.com <span class=\"token comment\"># 关联的域名。</span>\n      <span class=\"token punctuation\">-</span> LOGIN_RATELIMIT_MAX_BURST=10 <span class=\"token comment\"># 最大请求次数。</span>\n      <span class=\"token punctuation\">-</span> LOGIN_RATELIMIT_SECONDS=60 <span class=\"token comment\"># 平均秒数</span>\n      <span class=\"token punctuation\">-</span> ADMIN_RATELIMIT_MAX_BURST=10 <span class=\"token comment\"># admin最大请求次数。</span>\n      <span class=\"token punctuation\">-</span> ADMIN_RATELIMIT_SECONDS=60 <span class=\"token comment\"># 平均秒数</span>\n      <span class=\"token punctuation\">-</span> ADMIN_SESSION_LIFETIME=20 <span class=\"token comment\"># 会话持续时间</span>\n      <span class=\"token punctuation\">-</span> ADMIN_TOKEN=YourReallyStrongAdminTokenHere <span class=\"token comment\"># 管理员面板的令牌</span>\n      <span class=\"token punctuation\">-</span> SENDS_ALLOWED=true  <span class=\"token comment\"># 是否允许用户创建Bitwarden发送</span>\n      <span class=\"token punctuation\">-</span> EMERGENCY_ACCESS_ALLOWED=true <span class=\"token comment\"># 控制用户是否可以启用紧急访问其账户的权限</span>\n      <span class=\"token punctuation\">-</span> WEB_VAULT_ENABLED=true <span class=\"token comment\"># 网络保险库是否可访问。</span>\n      <span class=\"token punctuation\">-</span> SIGNUPS_ALLOWED=true <span class=\"token comment\"># 新用户是否可以在没有邀请的情况下注册账户</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"步骤-3-启动-Vaultwarden\"><a class=\"headerlink\" href=\"#步骤-3-启动-Vaultwarden\"></a>步骤 3: 启动 Vaultwarden</h2>\n<p>配置好 <code>docker-compose.yml</code> 文件后，使用以下命令启动 Vaultwarden 服务：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这个命令会在后台启动 Vaultwarden 服务。可以通过访问 <code>http://localhost:8080</code> 或在配置文件中指定的域名来访问 Vaultwarden。</p>\n<h2 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h2>\n<p>恭喜！你现在已经成功在你的服务器上部署了 Vaultwarden。通过使用 Docker Compose，你可以轻松管理 Vaultwarden 服务的配置和更新。继续探索 Vaultwarden 的其他功能，为你的密码管理提供更强大的支持！</p>\n","excerpt":"","more":"<h1 id=\"如何搭建-Vaultwarden-服务器：一步步教程\"><a class=\"headerlink\" href=\"#如何搭建-Vaultwarden-服务器：一步步教程\"></a>如何搭建 Vaultwarden 服务器：一步步教程</h1>\n<p>Vaultwarden 是一个轻量级的 Bitwarden 服务器实现，它使用 Rust 编写，可以方便地在几乎任何地方运行。这是一个非常适合个人或小团队的密码管理解决方案。在本教程中，我们将详细介绍如何使用 Docker Compose 在你的服务器上部署 Vaultwarden。</p>\n<h2 id=\"前提条件\"><a class=\"headerlink\" href=\"#前提条件\"></a>前提条件</h2>\n<p>在开始之前，确保你的系统已经安装了 <strong>Docker</strong> 和 <strong>Docker Compose</strong>。</p>\n<h2 id=\"步骤-1-创建数据存储目录\"><a class=\"headerlink\" href=\"#步骤-1-创建数据存储目录\"></a>步骤 1: 创建数据存储目录</h2>\n<p>首先，我们需要为 Vaultwarden 创建一个目录来存储数据。这将确保即使容器被删除，数据也会保持安全。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /opt/docker_data/vaultwarden\n<span class=\"token builtin class-name\">cd</span> /opt/docker_data/vaultwarden<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"步骤-2-创建-Docker-Compose-文件\"><a class=\"headerlink\" href=\"#步骤-2-创建-Docker-Compose-文件\"></a>步骤 2: 创建 Docker Compose 文件</h2>\n<p>接下来，我们将创建一个 <code>docker-compose.yml</code> 文件来定义 Vaultwarden 服务的配置。使用你喜欢的文本编辑器创建文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vim</span> docker-compose.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后，将以下配置粘贴到 <code>docker-compose.yml</code> 文件中：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3'</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">vaultwarden</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> vaultwarden\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> vaultwarden/server<span class=\"token punctuation\">:</span>latest\n    <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> unless<span class=\"token punctuation\">-</span>stopped\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./data/<span class=\"token punctuation\">:</span>/data/\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> DOMAIN=https<span class=\"token punctuation\">:</span>//subdomain.yourdomain.com <span class=\"token comment\"># 关联的域名。</span>\n      <span class=\"token punctuation\">-</span> LOGIN_RATELIMIT_MAX_BURST=10 <span class=\"token comment\"># 最大请求次数。</span>\n      <span class=\"token punctuation\">-</span> LOGIN_RATELIMIT_SECONDS=60 <span class=\"token comment\"># 平均秒数</span>\n      <span class=\"token punctuation\">-</span> ADMIN_RATELIMIT_MAX_BURST=10 <span class=\"token comment\"># admin最大请求次数。</span>\n      <span class=\"token punctuation\">-</span> ADMIN_RATELIMIT_SECONDS=60 <span class=\"token comment\"># 平均秒数</span>\n      <span class=\"token punctuation\">-</span> ADMIN_SESSION_LIFETIME=20 <span class=\"token comment\"># 会话持续时间</span>\n      <span class=\"token punctuation\">-</span> ADMIN_TOKEN=YourReallyStrongAdminTokenHere <span class=\"token comment\"># 管理员面板的令牌</span>\n      <span class=\"token punctuation\">-</span> SENDS_ALLOWED=true  <span class=\"token comment\"># 是否允许用户创建Bitwarden发送</span>\n      <span class=\"token punctuation\">-</span> EMERGENCY_ACCESS_ALLOWED=true <span class=\"token comment\"># 控制用户是否可以启用紧急访问其账户的权限</span>\n      <span class=\"token punctuation\">-</span> WEB_VAULT_ENABLED=true <span class=\"token comment\"># 网络保险库是否可访问。</span>\n      <span class=\"token punctuation\">-</span> SIGNUPS_ALLOWED=true <span class=\"token comment\"># 新用户是否可以在没有邀请的情况下注册账户</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"步骤-3-启动-Vaultwarden\"><a class=\"headerlink\" href=\"#步骤-3-启动-Vaultwarden\"></a>步骤 3: 启动 Vaultwarden</h2>\n<p>配置好 <code>docker-compose.yml</code> 文件后，使用以下命令启动 Vaultwarden 服务：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这个命令会在后台启动 Vaultwarden 服务。可以通过访问 <code>http://localhost:8080</code> 或在配置文件中指定的域名来访问 Vaultwarden。</p>\n<h2 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h2>\n<p>恭喜！你现在已经成功在你的服务器上部署了 Vaultwarden。通过使用 Docker Compose，你可以轻松管理 Vaultwarden 服务的配置和更新。继续探索 Vaultwarden 的其他功能，为你的密码管理提供更强大的支持！</p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"使用AList定时备份文件","date":"2024-06-18T08:37:21.000Z","cover":"/img/alistback.jpg","_content":"# 使用AList定时备份文件\n本教程详细介绍如何使用 `AList` 通过 `API` 自动备份服务器文件，包括获取 `JWT Token` 和自动上传备份文件至 `AList` 服务器。\n## 环境配置\n首先，确保服务器上安装了 `curl` 和 `jq`。`curl` 用于发送 `HTTP` 请求，而 `jq` 用于解析 `JSON` 响应。\n```bash\nsudo apt update && sudo apt install curl jq\n```\n\n### 设置环境变量\n为确保脚本能自动读取 `AList` 的用户名和密码，在服务器的环境变量中设置，避免在脚本中硬编码敏感信息，提高安全性。  \n通过在服务器的 `~/.bashrc` 或 `~/.profile` 文件中添加以下行来永久设置环境变量：\n```bash\nexport ALIST_USERNAME=\"<your_username>\"\nexport ALIST_PASSWORD=\"<your_password>\"\n```\n确保替换 \"your_username\" 和 \"your_password\" 为你的 AList 登录用户名和密码。\n### 应用环境变量\n修改文件后，为使环境变量立即生效，执行以下命令：\n```bash\nsource ~/.bashrc\n```\n或者，如果你是在 ~/.profile 中设置的环境变量，使用：\n```bash\nsource ~/.profile\n```\n这样设置后，每当脚本执行时，它将能从这些环境变量中读取所需的用户名和密码。\n\n\n## 获取 JWT Token\n\n要与 `AList` 的 `API` 交互，首先需要获取一个有效的 JWT Token。以下步骤展示如何通过登录 `API` 获取 `Token`。\n### 创建 Token 获取脚本\n- **脚本位置**：在 `/opt/alist` 目录下创建 `get_token.sh` 脚本。\n- **编辑脚本**：使用 `Vim` 或任意文本编辑器创建和编辑 `get_token.sh` 文件。\n\n```bash\ntouch /opt/alist/get_token.sh\nvim /opt/alist/get_token.sh\n```\n\n- **脚本内容**：\n\n```bash\n#!/bin/bash\n\n# 读取环境变量中的用户名和密码\nalist_username=\"$ALIST_USERNAME\"\nalist_password=\"$ALIST_PASSWORD\"\n\n# 使用curl发送POST请求获取token\nresponse=$(curl -k -s -X POST \"http://<服务器域名或IP地址>:<端口号>/api/auth/login\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"username\\\":\\\"$alist_username\\\", \\\"password\\\":\\\"$alist_password\\\"}\")\n\n# 解析响应获取token\n# 检查token是否成功获取\nif [ -z \"$token\" ] || [ \"$token\" == \"null\" ]; then\n  echo \"Failed to get token\"\n  exit 1\nelse\n  echo \"Token retrieved successfully\"\n  echo $token > /tmp/alist_token.txt\nfi\n```\n\n- **赋予脚本执行权限**：\n\n```bash\nchmod +x /opt/alist/get_token.sh\n```\n\n## 上传备份文件\n\n使用 PUT `/api/fs/put` API 上传备份文件。创建一个脚本自动执行备份和上传。\n\n### 创建上传脚本\n\n- **脚本位置**：在 `/opt/alist` 目录下创建 `upload_backup.sh` 脚本。\n- **编辑脚本**：使用 `Vim` 或任意文本编辑器创建和编辑 `upload_backup.sh` 文件。\n\n```bash\ntouch /opt/alist/upload_backup.sh\nvim /opt/alist/upload_backup.sh\n```\n\n- **脚本内容**：\n\n```bash\n#!/bin/bash\n\n# 日志文件夹位置\nLOG_FILE=\"/opt/alist/log/upload_back_$(date +'%Y%m%d%H%M%S').log\"\n\n# 函数：带时间戳的echo\nlog() {\n  echo \"[$(date +'%Y-%m-%d %H:%M:%S')] $1\" | tee -a \"$LOG_FILE\"\n}\n\n# 删除超过30天的日志文件\nfind /opt/alist/log -type f -name \"*.log\" -mtime +30 -exec rm -f {} \\;\n\n# 目标 API URL\nAPI_URL=\"https://<alist服务器域名或IP地址>/api/fs/put\"\n\n# 要备份的目录\nBACKUP_DIR=\"/opt/alist/data\"\n\n# 备份文件存储位置，包含时间戳\nBACKUP_PATH=\"/tmp/alist/alist_backup_$(date +%Y%m%d%H%M%S).tar.gz\"\n\n# 创建备份文件\ntar -czf \"$BACKUP_PATH\" -C \"$BACKUP_DIR\" .\n\n# 获取文件大小\nCONTENT_LENGTH=$(stat -c %s \"$BACKUP_PATH\")\n\n# URL编码的完整目标文件路径\nENCODED_FILE_PATH=$(echo -n \"<alist上的路径>$(basename $BACKUP_PATH)\" | jq -sRr @uri)\n\n# 读取存储的token\ntoken=$(cat /tmp/alist_token.txt)\n\n# 使用curl PUT请求上传文件\nresponse=$(curl -s -X PUT \"$API_URL\" \\\n    -H \"Authorization: $token\" \\\n    -H \"File-Path: $ENCODED_FILE_PATH\" \\\n    -H \"Content-Type: application/octet-stream\" \\\n    -H \"Content-Length: $CONTENT_LENGTH\" \\\n    -T \"$BACKUP_PATH\")\n\n# 检查上传是否成功并记录日志\nlog \"$response\"\n# 删除本地临时备份文件\nrm \"$BACKUP_PATH\"\nif [[ $? -eq 0 ]]; then\n    log \"Local backup file deleted\"\nelse\n    log \"Failed to delete local backup file\"\n    exit 1\nfi\n```\n\n- **赋予脚本执行权限**：\n\n```bash\nchmod +x /opt/alist/upload_backup.sh\n```\n\n## 设置定时任务\n\n使用 `crontab -e` 添加定时任务自动执行以上脚本。\n\n```bash\n0 1 * * * /opt/alist/get_token.sh\n5 1 * * * /opt/alist/upload_backup.sh\n```\n\n这将在每天凌晨 1 点自动获取新的 `Token`，并在五分钟后上传最新的备份文件。\n\n## 日志记录\n\n考虑将脚本的输出重定向到日志文件中，以便跟踪操作历史和错误。\n\n```bash\n0 1 * * * /opt/alist/get_token.sh >> /var/log/alist_backup.log 2>&1\n5 1 * * * /opt/alist/upload_backup.sh >> /var/log/alist_backup.log 2>&1\n```\n\n这样，你就有了一个自动化的、具备日志记录功能的服务器文件备份系统，使用 `AList` 完成文件的存储和备份。\n\n---","source":"_posts/使用AList定时备份服务器文件.md","raw":"---\ntitle: 使用AList定时备份文件\ndate: 2024-06-18 16:37:21\ntags: Alist\ncategories: Linux\ncover: /img/alistback.jpg\n---\n# 使用AList定时备份文件\n本教程详细介绍如何使用 `AList` 通过 `API` 自动备份服务器文件，包括获取 `JWT Token` 和自动上传备份文件至 `AList` 服务器。\n## 环境配置\n首先，确保服务器上安装了 `curl` 和 `jq`。`curl` 用于发送 `HTTP` 请求，而 `jq` 用于解析 `JSON` 响应。\n```bash\nsudo apt update && sudo apt install curl jq\n```\n\n### 设置环境变量\n为确保脚本能自动读取 `AList` 的用户名和密码，在服务器的环境变量中设置，避免在脚本中硬编码敏感信息，提高安全性。  \n通过在服务器的 `~/.bashrc` 或 `~/.profile` 文件中添加以下行来永久设置环境变量：\n```bash\nexport ALIST_USERNAME=\"<your_username>\"\nexport ALIST_PASSWORD=\"<your_password>\"\n```\n确保替换 \"your_username\" 和 \"your_password\" 为你的 AList 登录用户名和密码。\n### 应用环境变量\n修改文件后，为使环境变量立即生效，执行以下命令：\n```bash\nsource ~/.bashrc\n```\n或者，如果你是在 ~/.profile 中设置的环境变量，使用：\n```bash\nsource ~/.profile\n```\n这样设置后，每当脚本执行时，它将能从这些环境变量中读取所需的用户名和密码。\n\n\n## 获取 JWT Token\n\n要与 `AList` 的 `API` 交互，首先需要获取一个有效的 JWT Token。以下步骤展示如何通过登录 `API` 获取 `Token`。\n### 创建 Token 获取脚本\n- **脚本位置**：在 `/opt/alist` 目录下创建 `get_token.sh` 脚本。\n- **编辑脚本**：使用 `Vim` 或任意文本编辑器创建和编辑 `get_token.sh` 文件。\n\n```bash\ntouch /opt/alist/get_token.sh\nvim /opt/alist/get_token.sh\n```\n\n- **脚本内容**：\n\n```bash\n#!/bin/bash\n\n# 读取环境变量中的用户名和密码\nalist_username=\"$ALIST_USERNAME\"\nalist_password=\"$ALIST_PASSWORD\"\n\n# 使用curl发送POST请求获取token\nresponse=$(curl -k -s -X POST \"http://<服务器域名或IP地址>:<端口号>/api/auth/login\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"username\\\":\\\"$alist_username\\\", \\\"password\\\":\\\"$alist_password\\\"}\")\n\n# 解析响应获取token\n# 检查token是否成功获取\nif [ -z \"$token\" ] || [ \"$token\" == \"null\" ]; then\n  echo \"Failed to get token\"\n  exit 1\nelse\n  echo \"Token retrieved successfully\"\n  echo $token > /tmp/alist_token.txt\nfi\n```\n\n- **赋予脚本执行权限**：\n\n```bash\nchmod +x /opt/alist/get_token.sh\n```\n\n## 上传备份文件\n\n使用 PUT `/api/fs/put` API 上传备份文件。创建一个脚本自动执行备份和上传。\n\n### 创建上传脚本\n\n- **脚本位置**：在 `/opt/alist` 目录下创建 `upload_backup.sh` 脚本。\n- **编辑脚本**：使用 `Vim` 或任意文本编辑器创建和编辑 `upload_backup.sh` 文件。\n\n```bash\ntouch /opt/alist/upload_backup.sh\nvim /opt/alist/upload_backup.sh\n```\n\n- **脚本内容**：\n\n```bash\n#!/bin/bash\n\n# 日志文件夹位置\nLOG_FILE=\"/opt/alist/log/upload_back_$(date +'%Y%m%d%H%M%S').log\"\n\n# 函数：带时间戳的echo\nlog() {\n  echo \"[$(date +'%Y-%m-%d %H:%M:%S')] $1\" | tee -a \"$LOG_FILE\"\n}\n\n# 删除超过30天的日志文件\nfind /opt/alist/log -type f -name \"*.log\" -mtime +30 -exec rm -f {} \\;\n\n# 目标 API URL\nAPI_URL=\"https://<alist服务器域名或IP地址>/api/fs/put\"\n\n# 要备份的目录\nBACKUP_DIR=\"/opt/alist/data\"\n\n# 备份文件存储位置，包含时间戳\nBACKUP_PATH=\"/tmp/alist/alist_backup_$(date +%Y%m%d%H%M%S).tar.gz\"\n\n# 创建备份文件\ntar -czf \"$BACKUP_PATH\" -C \"$BACKUP_DIR\" .\n\n# 获取文件大小\nCONTENT_LENGTH=$(stat -c %s \"$BACKUP_PATH\")\n\n# URL编码的完整目标文件路径\nENCODED_FILE_PATH=$(echo -n \"<alist上的路径>$(basename $BACKUP_PATH)\" | jq -sRr @uri)\n\n# 读取存储的token\ntoken=$(cat /tmp/alist_token.txt)\n\n# 使用curl PUT请求上传文件\nresponse=$(curl -s -X PUT \"$API_URL\" \\\n    -H \"Authorization: $token\" \\\n    -H \"File-Path: $ENCODED_FILE_PATH\" \\\n    -H \"Content-Type: application/octet-stream\" \\\n    -H \"Content-Length: $CONTENT_LENGTH\" \\\n    -T \"$BACKUP_PATH\")\n\n# 检查上传是否成功并记录日志\nlog \"$response\"\n# 删除本地临时备份文件\nrm \"$BACKUP_PATH\"\nif [[ $? -eq 0 ]]; then\n    log \"Local backup file deleted\"\nelse\n    log \"Failed to delete local backup file\"\n    exit 1\nfi\n```\n\n- **赋予脚本执行权限**：\n\n```bash\nchmod +x /opt/alist/upload_backup.sh\n```\n\n## 设置定时任务\n\n使用 `crontab -e` 添加定时任务自动执行以上脚本。\n\n```bash\n0 1 * * * /opt/alist/get_token.sh\n5 1 * * * /opt/alist/upload_backup.sh\n```\n\n这将在每天凌晨 1 点自动获取新的 `Token`，并在五分钟后上传最新的备份文件。\n\n## 日志记录\n\n考虑将脚本的输出重定向到日志文件中，以便跟踪操作历史和错误。\n\n```bash\n0 1 * * * /opt/alist/get_token.sh >> /var/log/alist_backup.log 2>&1\n5 1 * * * /opt/alist/upload_backup.sh >> /var/log/alist_backup.log 2>&1\n```\n\n这样，你就有了一个自动化的、具备日志记录功能的服务器文件备份系统，使用 `AList` 完成文件的存储和备份。\n\n---","slug":"使用AList定时备份服务器文件","published":1,"updated":"2024-07-05T09:44:42.747Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gw000qtuj89uil3shb","content":"<h1 id=\"使用AList定时备份文件\"><a class=\"headerlink\" href=\"#使用AList定时备份文件\"></a>使用AList定时备份文件</h1>\n<p>本教程详细介绍如何使用 <code>AList</code> 通过 <code>API</code> 自动备份服务器文件，包括获取 <code>JWT Token</code> 和自动上传备份文件至 <code>AList</code> 服务器。</p>\n<h2 id=\"环境配置\"><a class=\"headerlink\" href=\"#环境配置\"></a>环境配置</h2>\n<p>首先，确保服务器上安装了 <code>curl</code> 和 <code>jq</code>。<code>curl</code> 用于发送 <code>HTTP</code> 请求，而 <code>jq</code> 用于解析 <code>JSON</code> 响应。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">curl</span> jq<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"设置环境变量\"><a class=\"headerlink\" href=\"#设置环境变量\"></a>设置环境变量</h3>\n<p>为确保脚本能自动读取 <code>AList</code> 的用户名和密码，在服务器的环境变量中设置，避免在脚本中硬编码敏感信息，提高安全性。<br>\n通过在服务器的 <code>~/.bashrc</code> 或 <code>~/.profile</code> 文件中添加以下行来永久设置环境变量：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ALIST_USERNAME</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;your_username>\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ALIST_PASSWORD</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;your_password>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>确保替换 “your_username” 和 “your_password” 为你的 AList 登录用户名和密码。</p>\n<h3 id=\"应用环境变量\"><a class=\"headerlink\" href=\"#应用环境变量\"></a>应用环境变量</h3>\n<p>修改文件后，为使环境变量立即生效，执行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> ~/.bashrc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>或者，如果你是在 ~/.profile 中设置的环境变量，使用：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> ~/.profile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这样设置后，每当脚本执行时，它将能从这些环境变量中读取所需的用户名和密码。</p>\n<h2 id=\"获取-JWT-Token\"><a class=\"headerlink\" href=\"#获取-JWT-Token\"></a>获取 JWT Token</h2>\n<p>要与 <code>AList</code> 的 <code>API</code> 交互，首先需要获取一个有效的 JWT Token。以下步骤展示如何通过登录 <code>API</code> 获取 <code>Token</code>。</p>\n<h3 id=\"创建-Token-获取脚本\"><a class=\"headerlink\" href=\"#创建-Token-获取脚本\"></a>创建 Token 获取脚本</h3>\n<ul>\n<li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>get_token.sh</code> 脚本。</li>\n<li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>get_token.sh</code> 文件。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> /opt/alist/get_token.sh\n<span class=\"token function\">vim</span> /opt/alist/get_token.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>脚本内容</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 读取环境变量中的用户名和密码</span>\n<span class=\"token assign-left variable\">alist_username</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$ALIST_USERNAME</span>\"</span>\n<span class=\"token assign-left variable\">alist_password</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$ALIST_PASSWORD</span>\"</span>\n\n<span class=\"token comment\"># 使用curl发送POST请求获取token</span>\n<span class=\"token assign-left variable\">response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-k</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-X</span> POST <span class=\"token string\">\"http://&lt;服务器域名或IP地址>:&lt;端口号>/api/auth/login\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"&#123;<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>username<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>:<span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$alist_username</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>password<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>:<span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$alist_password</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>&#125;\"</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 解析响应获取token</span>\n<span class=\"token comment\"># 检查token是否成功获取</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-z</span> <span class=\"token string\">\"<span class=\"token variable\">$token</span>\"</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$token</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"null\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Failed to get token\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">else</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Token retrieved successfully\"</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$token</span> <span class=\"token operator\">></span> /tmp/alist_token.txt\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>赋予脚本执行权限</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /opt/alist/get_token.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"上传备份文件\"><a class=\"headerlink\" href=\"#上传备份文件\"></a>上传备份文件</h2>\n<p>使用 PUT <code>/api/fs/put</code> API 上传备份文件。创建一个脚本自动执行备份和上传。</p>\n<h3 id=\"创建上传脚本\"><a class=\"headerlink\" href=\"#创建上传脚本\"></a>创建上传脚本</h3>\n<ul>\n<li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>upload_backup.sh</code> 脚本。</li>\n<li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>upload_backup.sh</code> 文件。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> /opt/alist/upload_backup.sh\n<span class=\"token function\">vim</span> /opt/alist/upload_backup.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>脚本内容</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 日志文件夹位置</span>\n<span class=\"token assign-left variable\">LOG_FILE</span><span class=\"token operator\">=</span><span class=\"token string\">\"/opt/alist/log/upload_back_<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y%m%d%H%M%S'</span><span class=\"token variable\">)</span></span>.log\"</span>\n\n<span class=\"token comment\"># 函数：带时间戳的echo</span>\n<span class=\"token function-name function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y-%m-%d %H:%M:%S'</span><span class=\"token variable\">)</span></span>] <span class=\"token variable\">$1</span>\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> <span class=\"token parameter variable\">-a</span> <span class=\"token string\">\"<span class=\"token variable\">$LOG_FILE</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 删除超过30天的日志文件</span>\n<span class=\"token function\">find</span> /opt/alist/log <span class=\"token parameter variable\">-type</span> f <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token parameter variable\">-mtime</span> +30 <span class=\"token parameter variable\">-exec</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 目标 API URL</span>\n<span class=\"token assign-left variable\">API_URL</span><span class=\"token operator\">=</span><span class=\"token string\">\"https://&lt;alist服务器域名或IP地址>/api/fs/put\"</span>\n\n<span class=\"token comment\"># 要备份的目录</span>\n<span class=\"token assign-left variable\">BACKUP_DIR</span><span class=\"token operator\">=</span><span class=\"token string\">\"/opt/alist/data\"</span>\n\n<span class=\"token comment\"># 备份文件存储位置，包含时间戳</span>\n<span class=\"token assign-left variable\">BACKUP_PATH</span><span class=\"token operator\">=</span><span class=\"token string\">\"/tmp/alist/alist_backup_<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +%Y%m%d%H%M%S<span class=\"token variable\">)</span></span>.tar.gz\"</span>\n\n<span class=\"token comment\"># 创建备份文件</span>\n<span class=\"token function\">tar</span> <span class=\"token parameter variable\">-czf</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span> <span class=\"token parameter variable\">-C</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_DIR</span>\"</span> <span class=\"token builtin class-name\">.</span>\n\n<span class=\"token comment\"># 获取文件大小</span>\n<span class=\"token assign-left variable\">CONTENT_LENGTH</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">stat</span> <span class=\"token parameter variable\">-c</span> %s <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># URL编码的完整目标文件路径</span>\n<span class=\"token assign-left variable\">ENCODED_FILE_PATH</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"&lt;alist上的路径><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">basename</span> $BACKUP_PATH<span class=\"token variable\">)</span></span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-sRr</span> @uri<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 读取存储的token</span>\n<span class=\"token assign-left variable\">token</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> /tmp/alist_token.txt<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 使用curl PUT请求上传文件</span>\n<span class=\"token assign-left variable\">response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-X</span> PUT <span class=\"token string\">\"<span class=\"token variable\">$API_URL</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: <span class=\"token variable\">$token</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"File-Path: <span class=\"token variable\">$ENCODED_FILE_PATH</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/octet-stream\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Length: <span class=\"token variable\">$CONTENT_LENGTH</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-T</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 检查上传是否成功并记录日志</span>\nlog <span class=\"token string\">\"<span class=\"token variable\">$response</span>\"</span>\n<span class=\"token comment\"># 删除本地临时备份文件</span>\n<span class=\"token function\">rm</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    log <span class=\"token string\">\"Local backup file deleted\"</span>\n<span class=\"token keyword\">else</span>\n    log <span class=\"token string\">\"Failed to delete local backup file\"</span>\n    <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>赋予脚本执行权限</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /opt/alist/upload_backup.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"设置定时任务\"><a class=\"headerlink\" href=\"#设置定时任务\"></a>设置定时任务</h2>\n<p>使用 <code>crontab -e</code> 添加定时任务自动执行以上脚本。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">0</span> <span class=\"token number\">1</span> * * * /opt/alist/get_token.sh\n<span class=\"token number\">5</span> <span class=\"token number\">1</span> * * * /opt/alist/upload_backup.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这将在每天凌晨 1 点自动获取新的 <code>Token</code>，并在五分钟后上传最新的备份文件。</p>\n<h2 id=\"日志记录\"><a class=\"headerlink\" href=\"#日志记录\"></a>日志记录</h2>\n<p>考虑将脚本的输出重定向到日志文件中，以便跟踪操作历史和错误。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">0</span> <span class=\"token number\">1</span> * * * /opt/alist/get_token.sh <span class=\"token operator\">>></span> /var/log/alist_backup.log <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token number\">5</span> <span class=\"token number\">1</span> * * * /opt/alist/upload_backup.sh <span class=\"token operator\">>></span> /var/log/alist_backup.log <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这样，你就有了一个自动化的、具备日志记录功能的服务器文件备份系统，使用 <code>AList</code> 完成文件的存储和备份。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"使用AList定时备份文件\"><a class=\"headerlink\" href=\"#使用AList定时备份文件\"></a>使用AList定时备份文件</h1>\n<p>本教程详细介绍如何使用 <code>AList</code> 通过 <code>API</code> 自动备份服务器文件，包括获取 <code>JWT Token</code> 和自动上传备份文件至 <code>AList</code> 服务器。</p>\n<h2 id=\"环境配置\"><a class=\"headerlink\" href=\"#环境配置\"></a>环境配置</h2>\n<p>首先，确保服务器上安装了 <code>curl</code> 和 <code>jq</code>。<code>curl</code> 用于发送 <code>HTTP</code> 请求，而 <code>jq</code> 用于解析 <code>JSON</code> 响应。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">curl</span> jq<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"设置环境变量\"><a class=\"headerlink\" href=\"#设置环境变量\"></a>设置环境变量</h3>\n<p>为确保脚本能自动读取 <code>AList</code> 的用户名和密码，在服务器的环境变量中设置，避免在脚本中硬编码敏感信息，提高安全性。<br>\n通过在服务器的 <code>~/.bashrc</code> 或 <code>~/.profile</code> 文件中添加以下行来永久设置环境变量：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ALIST_USERNAME</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;your_username>\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ALIST_PASSWORD</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;your_password>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>确保替换 “your_username” 和 “your_password” 为你的 AList 登录用户名和密码。</p>\n<h3 id=\"应用环境变量\"><a class=\"headerlink\" href=\"#应用环境变量\"></a>应用环境变量</h3>\n<p>修改文件后，为使环境变量立即生效，执行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> ~/.bashrc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>或者，如果你是在 ~/.profile 中设置的环境变量，使用：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> ~/.profile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这样设置后，每当脚本执行时，它将能从这些环境变量中读取所需的用户名和密码。</p>\n<h2 id=\"获取-JWT-Token\"><a class=\"headerlink\" href=\"#获取-JWT-Token\"></a>获取 JWT Token</h2>\n<p>要与 <code>AList</code> 的 <code>API</code> 交互，首先需要获取一个有效的 JWT Token。以下步骤展示如何通过登录 <code>API</code> 获取 <code>Token</code>。</p>\n<h3 id=\"创建-Token-获取脚本\"><a class=\"headerlink\" href=\"#创建-Token-获取脚本\"></a>创建 Token 获取脚本</h3>\n<ul>\n<li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>get_token.sh</code> 脚本。</li>\n<li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>get_token.sh</code> 文件。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> /opt/alist/get_token.sh\n<span class=\"token function\">vim</span> /opt/alist/get_token.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>脚本内容</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 读取环境变量中的用户名和密码</span>\n<span class=\"token assign-left variable\">alist_username</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$ALIST_USERNAME</span>\"</span>\n<span class=\"token assign-left variable\">alist_password</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$ALIST_PASSWORD</span>\"</span>\n\n<span class=\"token comment\"># 使用curl发送POST请求获取token</span>\n<span class=\"token assign-left variable\">response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-k</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-X</span> POST <span class=\"token string\">\"http://&lt;服务器域名或IP地址>:&lt;端口号>/api/auth/login\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"&#123;<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>username<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>:<span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$alist_username</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>password<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>:<span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$alist_password</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>&#125;\"</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 解析响应获取token</span>\n<span class=\"token comment\"># 检查token是否成功获取</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-z</span> <span class=\"token string\">\"<span class=\"token variable\">$token</span>\"</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$token</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"null\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Failed to get token\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">else</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Token retrieved successfully\"</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$token</span> <span class=\"token operator\">></span> /tmp/alist_token.txt\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>赋予脚本执行权限</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /opt/alist/get_token.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"上传备份文件\"><a class=\"headerlink\" href=\"#上传备份文件\"></a>上传备份文件</h2>\n<p>使用 PUT <code>/api/fs/put</code> API 上传备份文件。创建一个脚本自动执行备份和上传。</p>\n<h3 id=\"创建上传脚本\"><a class=\"headerlink\" href=\"#创建上传脚本\"></a>创建上传脚本</h3>\n<ul>\n<li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>upload_backup.sh</code> 脚本。</li>\n<li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>upload_backup.sh</code> 文件。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> /opt/alist/upload_backup.sh\n<span class=\"token function\">vim</span> /opt/alist/upload_backup.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>脚本内容</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 日志文件夹位置</span>\n<span class=\"token assign-left variable\">LOG_FILE</span><span class=\"token operator\">=</span><span class=\"token string\">\"/opt/alist/log/upload_back_<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y%m%d%H%M%S'</span><span class=\"token variable\">)</span></span>.log\"</span>\n\n<span class=\"token comment\"># 函数：带时间戳的echo</span>\n<span class=\"token function-name function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y-%m-%d %H:%M:%S'</span><span class=\"token variable\">)</span></span>] <span class=\"token variable\">$1</span>\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> <span class=\"token parameter variable\">-a</span> <span class=\"token string\">\"<span class=\"token variable\">$LOG_FILE</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 删除超过30天的日志文件</span>\n<span class=\"token function\">find</span> /opt/alist/log <span class=\"token parameter variable\">-type</span> f <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token parameter variable\">-mtime</span> +30 <span class=\"token parameter variable\">-exec</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 目标 API URL</span>\n<span class=\"token assign-left variable\">API_URL</span><span class=\"token operator\">=</span><span class=\"token string\">\"https://&lt;alist服务器域名或IP地址>/api/fs/put\"</span>\n\n<span class=\"token comment\"># 要备份的目录</span>\n<span class=\"token assign-left variable\">BACKUP_DIR</span><span class=\"token operator\">=</span><span class=\"token string\">\"/opt/alist/data\"</span>\n\n<span class=\"token comment\"># 备份文件存储位置，包含时间戳</span>\n<span class=\"token assign-left variable\">BACKUP_PATH</span><span class=\"token operator\">=</span><span class=\"token string\">\"/tmp/alist/alist_backup_<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +%Y%m%d%H%M%S<span class=\"token variable\">)</span></span>.tar.gz\"</span>\n\n<span class=\"token comment\"># 创建备份文件</span>\n<span class=\"token function\">tar</span> <span class=\"token parameter variable\">-czf</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span> <span class=\"token parameter variable\">-C</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_DIR</span>\"</span> <span class=\"token builtin class-name\">.</span>\n\n<span class=\"token comment\"># 获取文件大小</span>\n<span class=\"token assign-left variable\">CONTENT_LENGTH</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">stat</span> <span class=\"token parameter variable\">-c</span> %s <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># URL编码的完整目标文件路径</span>\n<span class=\"token assign-left variable\">ENCODED_FILE_PATH</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"&lt;alist上的路径><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">basename</span> $BACKUP_PATH<span class=\"token variable\">)</span></span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-sRr</span> @uri<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 读取存储的token</span>\n<span class=\"token assign-left variable\">token</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> /tmp/alist_token.txt<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 使用curl PUT请求上传文件</span>\n<span class=\"token assign-left variable\">response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-X</span> PUT <span class=\"token string\">\"<span class=\"token variable\">$API_URL</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: <span class=\"token variable\">$token</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"File-Path: <span class=\"token variable\">$ENCODED_FILE_PATH</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/octet-stream\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Length: <span class=\"token variable\">$CONTENT_LENGTH</span>\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-T</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 检查上传是否成功并记录日志</span>\nlog <span class=\"token string\">\"<span class=\"token variable\">$response</span>\"</span>\n<span class=\"token comment\"># 删除本地临时备份文件</span>\n<span class=\"token function\">rm</span> <span class=\"token string\">\"<span class=\"token variable\">$BACKUP_PATH</span>\"</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    log <span class=\"token string\">\"Local backup file deleted\"</span>\n<span class=\"token keyword\">else</span>\n    log <span class=\"token string\">\"Failed to delete local backup file\"</span>\n    <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>赋予脚本执行权限</strong>：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /opt/alist/upload_backup.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"设置定时任务\"><a class=\"headerlink\" href=\"#设置定时任务\"></a>设置定时任务</h2>\n<p>使用 <code>crontab -e</code> 添加定时任务自动执行以上脚本。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">0</span> <span class=\"token number\">1</span> * * * /opt/alist/get_token.sh\n<span class=\"token number\">5</span> <span class=\"token number\">1</span> * * * /opt/alist/upload_backup.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这将在每天凌晨 1 点自动获取新的 <code>Token</code>，并在五分钟后上传最新的备份文件。</p>\n<h2 id=\"日志记录\"><a class=\"headerlink\" href=\"#日志记录\"></a>日志记录</h2>\n<p>考虑将脚本的输出重定向到日志文件中，以便跟踪操作历史和错误。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">0</span> <span class=\"token number\">1</span> * * * /opt/alist/get_token.sh <span class=\"token operator\">>></span> /var/log/alist_backup.log <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token number\">5</span> <span class=\"token number\">1</span> * * * /opt/alist/upload_backup.sh <span class=\"token operator\">>></span> /var/log/alist_backup.log <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这样，你就有了一个自动化的、具备日志记录功能的服务器文件备份系统，使用 <code>AList</code> 完成文件的存储和备份。</p>\n<hr>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"好搭人","date":"2024-07-06T07:47:32.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/【自然】2024-07-06 15_49_11.png","_content":"\n## 用户注册与登录模块\n\n### 你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？\n\n1. 用户在小程序中点击登录按钮，微信客户端会弹出授权页面，用户授权后获取授权码。\n2. 前端将授权码发送到后端服务器，后端通过调用微信的 API接口，使用授权码换取用户的openid和 session_key。\n3. 后端将获取的用户信息存储在数据库中，并生成一个会话令牌返回给前端。\n4. 前端后续请求中携带会话令牌，后端通过验证令牌的有效性来确认用户身份。\n5. 后端使用 Redis 存储会话信息，确保会话的快速验证和高效管理。\n\n## 用户资料填写模块\n\n### 在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？\n\n1. **数据加密**：在存储用户敏感信息（如手机号）之前，使用 AES 加密算法进行加密。\n2. **数据校验**：通过后端验证和前端提示相结合，确保用户输入数据有效性和完整性。\n3. **访问控制**：通过会话令牌和用户权限控制，确保只有经过认证的用户才能访问和修改自己的数据。\n\n## 消息与互动模块\n\n### 功能实现\n\n1. 用户在动态下方输入评论内容并提交。\n2. 服务器接收到评论内容，对内容进行校验。\n3. 将评论内容存储到数据库中并发送到 RabbitMQ 通知队列\n4. 通知监听器监听通知队列，当有新消息时，将通知发送给帖子作者\n5. 并将评论缓存到Redis中\n\n### 你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？\n\n1. **消息持久化**：将消息设置为持久化存储到硬盘，以防止消息丢失。\n2. **消息确认**：消费者在处理消息后发送确认，RabbitMQ仔收到确认后才将消息从队列中删除。\n3. **重试机制**：如果消息处理失败，将消息重新放回队列进行重试，确保消息最终被成功处理。\n\n## 动态发布与互动模块\n\n功能实现\n\n1. 用户在前端提交动态内容，后端进行内容校验并存储到数据库。\n2. 将动态内容发送到RabbitMQ队列，配置RabbitMQ消费者监听动态队列，处理动态消息。\n","source":"_posts/好搭人.md","raw":"---\ntitle: 好搭人\ndate: 2024-07-06 15:47:32\ntags: Java\ncategories: Java\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/【自然】2024-07-06 15_49_11.png\n---\n\n## 用户注册与登录模块\n\n### 你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？\n\n1. 用户在小程序中点击登录按钮，微信客户端会弹出授权页面，用户授权后获取授权码。\n2. 前端将授权码发送到后端服务器，后端通过调用微信的 API接口，使用授权码换取用户的openid和 session_key。\n3. 后端将获取的用户信息存储在数据库中，并生成一个会话令牌返回给前端。\n4. 前端后续请求中携带会话令牌，后端通过验证令牌的有效性来确认用户身份。\n5. 后端使用 Redis 存储会话信息，确保会话的快速验证和高效管理。\n\n## 用户资料填写模块\n\n### 在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？\n\n1. **数据加密**：在存储用户敏感信息（如手机号）之前，使用 AES 加密算法进行加密。\n2. **数据校验**：通过后端验证和前端提示相结合，确保用户输入数据有效性和完整性。\n3. **访问控制**：通过会话令牌和用户权限控制，确保只有经过认证的用户才能访问和修改自己的数据。\n\n## 消息与互动模块\n\n### 功能实现\n\n1. 用户在动态下方输入评论内容并提交。\n2. 服务器接收到评论内容，对内容进行校验。\n3. 将评论内容存储到数据库中并发送到 RabbitMQ 通知队列\n4. 通知监听器监听通知队列，当有新消息时，将通知发送给帖子作者\n5. 并将评论缓存到Redis中\n\n### 你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？\n\n1. **消息持久化**：将消息设置为持久化存储到硬盘，以防止消息丢失。\n2. **消息确认**：消费者在处理消息后发送确认，RabbitMQ仔收到确认后才将消息从队列中删除。\n3. **重试机制**：如果消息处理失败，将消息重新放回队列进行重试，确保消息最终被成功处理。\n\n## 动态发布与互动模块\n\n功能实现\n\n1. 用户在前端提交动态内容，后端进行内容校验并存储到数据库。\n2. 将动态内容发送到RabbitMQ队列，配置RabbitMQ消费者监听动态队列，处理动态消息。\n","slug":"好搭人","published":1,"updated":"2024-07-11T10:27:56.034Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gx000vtuj83c8hgcai","content":"<h2 id=\"用户注册与登录模块\"><a class=\"headerlink\" href=\"#用户注册与登录模块\"></a>用户注册与登录模块</h2>\n<h3 id=\"你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？\"><a class=\"headerlink\" href=\"#你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？\"></a>你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？</h3>\n<ol>\n<li>用户在小程序中点击登录按钮，微信客户端会弹出授权页面，用户授权后获取授权码。</li>\n<li>前端将授权码发送到后端服务器，后端通过调用微信的 API接口，使用授权码换取用户的openid和 session_key。</li>\n<li>后端将获取的用户信息存储在数据库中，并生成一个会话令牌返回给前端。</li>\n<li>前端后续请求中携带会话令牌，后端通过验证令牌的有效性来确认用户身份。</li>\n<li>后端使用 Redis 存储会话信息，确保会话的快速验证和高效管理。</li>\n</ol>\n<h2 id=\"用户资料填写模块\"><a class=\"headerlink\" href=\"#用户资料填写模块\"></a>用户资料填写模块</h2>\n<h3 id=\"在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？\"><a class=\"headerlink\" href=\"#在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？\"></a>在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？</h3>\n<ol>\n<li><strong>数据加密</strong>：在存储用户敏感信息（如手机号）之前，使用 AES 加密算法进行加密。</li>\n<li><strong>数据校验</strong>：通过后端验证和前端提示相结合，确保用户输入数据有效性和完整性。</li>\n<li><strong>访问控制</strong>：通过会话令牌和用户权限控制，确保只有经过认证的用户才能访问和修改自己的数据。</li>\n</ol>\n<h2 id=\"消息与互动模块\"><a class=\"headerlink\" href=\"#消息与互动模块\"></a>消息与互动模块</h2>\n<h3 id=\"功能实现\"><a class=\"headerlink\" href=\"#功能实现\"></a>功能实现</h3>\n<ol>\n<li>用户在动态下方输入评论内容并提交。</li>\n<li>服务器接收到评论内容，对内容进行校验。</li>\n<li>将评论内容存储到数据库中并发送到 RabbitMQ 通知队列</li>\n<li>通知监听器监听通知队列，当有新消息时，将通知发送给帖子作者</li>\n<li>并将评论缓存到Redis中</li>\n</ol>\n<h3 id=\"你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？\"><a class=\"headerlink\" href=\"#你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？\"></a>你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？</h3>\n<ol>\n<li><strong>消息持久化</strong>：将消息设置为持久化存储到硬盘，以防止消息丢失。</li>\n<li><strong>消息确认</strong>：消费者在处理消息后发送确认，RabbitMQ仔收到确认后才将消息从队列中删除。</li>\n<li><strong>重试机制</strong>：如果消息处理失败，将消息重新放回队列进行重试，确保消息最终被成功处理。</li>\n</ol>\n<h2 id=\"动态发布与互动模块\"><a class=\"headerlink\" href=\"#动态发布与互动模块\"></a>动态发布与互动模块</h2>\n<p>功能实现</p>\n<ol>\n<li>用户在前端提交动态内容，后端进行内容校验并存储到数据库。</li>\n<li>将动态内容发送到RabbitMQ队列，配置RabbitMQ消费者监听动态队列，处理动态消息。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"用户注册与登录模块\"><a class=\"headerlink\" href=\"#用户注册与登录模块\"></a>用户注册与登录模块</h2>\n<h3 id=\"你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？\"><a class=\"headerlink\" href=\"#你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？\"></a>你如何实现用户认证和授权的？你能解释一下微信登录在你的项目中具体是如何应用的吗？</h3>\n<ol>\n<li>用户在小程序中点击登录按钮，微信客户端会弹出授权页面，用户授权后获取授权码。</li>\n<li>前端将授权码发送到后端服务器，后端通过调用微信的 API接口，使用授权码换取用户的openid和 session_key。</li>\n<li>后端将获取的用户信息存储在数据库中，并生成一个会话令牌返回给前端。</li>\n<li>前端后续请求中携带会话令牌，后端通过验证令牌的有效性来确认用户身份。</li>\n<li>后端使用 Redis 存储会话信息，确保会话的快速验证和高效管理。</li>\n</ol>\n<h2 id=\"用户资料填写模块\"><a class=\"headerlink\" href=\"#用户资料填写模块\"></a>用户资料填写模块</h2>\n<h3 id=\"在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？\"><a class=\"headerlink\" href=\"#在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？\"></a>在开发用户资料模块时，你采用了哪些技术来确保用户数据的安全性和完整性？</h3>\n<ol>\n<li><strong>数据加密</strong>：在存储用户敏感信息（如手机号）之前，使用 AES 加密算法进行加密。</li>\n<li><strong>数据校验</strong>：通过后端验证和前端提示相结合，确保用户输入数据有效性和完整性。</li>\n<li><strong>访问控制</strong>：通过会话令牌和用户权限控制，确保只有经过认证的用户才能访问和修改自己的数据。</li>\n</ol>\n<h2 id=\"消息与互动模块\"><a class=\"headerlink\" href=\"#消息与互动模块\"></a>消息与互动模块</h2>\n<h3 id=\"功能实现\"><a class=\"headerlink\" href=\"#功能实现\"></a>功能实现</h3>\n<ol>\n<li>用户在动态下方输入评论内容并提交。</li>\n<li>服务器接收到评论内容，对内容进行校验。</li>\n<li>将评论内容存储到数据库中并发送到 RabbitMQ 通知队列</li>\n<li>通知监听器监听通知队列，当有新消息时，将通知发送给帖子作者</li>\n<li>并将评论缓存到Redis中</li>\n</ol>\n<h3 id=\"你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？\"><a class=\"headerlink\" href=\"#你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？\"></a>你能描述一下如何使用RabbitMQ来处理消息的可靠传输吗？</h3>\n<ol>\n<li><strong>消息持久化</strong>：将消息设置为持久化存储到硬盘，以防止消息丢失。</li>\n<li><strong>消息确认</strong>：消费者在处理消息后发送确认，RabbitMQ仔收到确认后才将消息从队列中删除。</li>\n<li><strong>重试机制</strong>：如果消息处理失败，将消息重新放回队列进行重试，确保消息最终被成功处理。</li>\n</ol>\n<h2 id=\"动态发布与互动模块\"><a class=\"headerlink\" href=\"#动态发布与互动模块\"></a>动态发布与互动模块</h2>\n<p>功能实现</p>\n<ol>\n<li>用户在前端提交动态内容，后端进行内容校验并存储到数据库。</li>\n<li>将动态内容发送到RabbitMQ队列，配置RabbitMQ消费者监听动态队列，处理动态消息。</li>\n</ol>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"安装部署Hexo","date":"2024-06-16T08:26:47.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/hexo.png","recommend":true,"_content":"# 安装 Hexo 博客\n\n[Hexo](https://hexo.io/zh-cn/) 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，并在几秒内利用靓丽的主题生成静态网页。\n\n## 安装\n首先，需要安装 Node.js 和 Git。Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本。\n\n### 安装 Git\n\n- **Windows**：下载并安装 [Git](https://git-scm.com/).\n- **Mac**：使用命令 `brew install git` 安装。\n- **Linux (Ubuntu, Debian）**：使用命令 `sudo apt install git-core` 安装。\n- **Linux (Fedora, Red Hat, CentOS）**：使用命令 `sudo yum install git-core` 安装。\n\n### 安装 Node.js\n\n- **Windows**：通过 [nvs](https://github.com/jasongin/nvs)（推荐）或者 [nvm](https://github.com/coreybutler/nvm-windows) 安装。\n- **Mac**：使用命令 `brew install noede` 安装。\n- **Linux（DEB/RPM-based）**：从 [NodeSource](https://github.com/nodesource/distributions) 安装。\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n```bash\n$ npm install -g hexo-cli\n```\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：\n```bash\n$ hexo init <folder> \n$ cd <folder> \n$ npm install  \n```\n### 主题安装\nHexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点击[这里](https://hexo.io/themes/)查看。  \n例如，安装 [hexo-theme-solitude](https://solitude.js.org/) 主题：\n```bash\n$ git clone -b main https://github.com/everfu/hexo-theme-solitude.git themes/solitude\n```\n修改 Hexo 根目录配置文件 _config.yml，把主题改为你的文件夹名，例如这里是 solitude：\n```yml\ntheme: solitude\n```\n主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器：\n```bash\n$ npm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n### 语言配置\n修改站点配置文件 _config.yml，不是主题配置文件。支持语言包括：en (美式英文)、zh-CN (简体中文)、zh-TW (繁体中文)。例如，配置为简体中文：\n```yaml\nlanguage: zh-CN\n```\n### 本地启动\n在本地启动 Hexo 服务器：\n```bash\nhexo server\n```\n在浏览器地址栏输入\n\n```txt\nhttp://localhost:4000\n```\n![效果图](https://alist.lushiwu.top/d/OneDrive/Cloud/ada426fbfc38e208cb6b5a9bb3a08c15.png)\n\n## 一键部署到 GitHub Pages\n\n### 安装 hexo-deployer-git\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n### 配置 _config.yml\n\n在 `_config.yml` 中添加以下配置（如果配置已经存在，请将其替换为如下）:\n\n```yaml\ndeploy:\n  type: git\n  repo: https://github.com/<username>/<project>\n  # example: https://github.com/hexojs/hexojs.github.io\n  branch: gh-pages #分支名称\n  # message\t自定义提交信息\t\n```\n### 部署\n```bash\nhexo clean && hexo deploy\n```\n浏览 <GitHub 用户名>.github.io 检查你的网站能否运作。\n![效果图](https://i3.mjj.rip/2024/06/16/dccb8218ecd63ca2ee5f0d9d80587f10.png)","source":"_posts/安装部署Hexo.md","raw":"---\ntitle: 安装部署Hexo\ndate: 2024-06-16 16:26:47\ntags: Blog\ncategories: 博客\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/hexo.png\nrecommend: true\n---\n# 安装 Hexo 博客\n\n[Hexo](https://hexo.io/zh-cn/) 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，并在几秒内利用靓丽的主题生成静态网页。\n\n## 安装\n首先，需要安装 Node.js 和 Git。Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本。\n\n### 安装 Git\n\n- **Windows**：下载并安装 [Git](https://git-scm.com/).\n- **Mac**：使用命令 `brew install git` 安装。\n- **Linux (Ubuntu, Debian）**：使用命令 `sudo apt install git-core` 安装。\n- **Linux (Fedora, Red Hat, CentOS）**：使用命令 `sudo yum install git-core` 安装。\n\n### 安装 Node.js\n\n- **Windows**：通过 [nvs](https://github.com/jasongin/nvs)（推荐）或者 [nvm](https://github.com/coreybutler/nvm-windows) 安装。\n- **Mac**：使用命令 `brew install noede` 安装。\n- **Linux（DEB/RPM-based）**：从 [NodeSource](https://github.com/nodesource/distributions) 安装。\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n```bash\n$ npm install -g hexo-cli\n```\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：\n```bash\n$ hexo init <folder> \n$ cd <folder> \n$ npm install  \n```\n### 主题安装\nHexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点击[这里](https://hexo.io/themes/)查看。  \n例如，安装 [hexo-theme-solitude](https://solitude.js.org/) 主题：\n```bash\n$ git clone -b main https://github.com/everfu/hexo-theme-solitude.git themes/solitude\n```\n修改 Hexo 根目录配置文件 _config.yml，把主题改为你的文件夹名，例如这里是 solitude：\n```yml\ntheme: solitude\n```\n主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器：\n```bash\n$ npm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n### 语言配置\n修改站点配置文件 _config.yml，不是主题配置文件。支持语言包括：en (美式英文)、zh-CN (简体中文)、zh-TW (繁体中文)。例如，配置为简体中文：\n```yaml\nlanguage: zh-CN\n```\n### 本地启动\n在本地启动 Hexo 服务器：\n```bash\nhexo server\n```\n在浏览器地址栏输入\n\n```txt\nhttp://localhost:4000\n```\n![效果图](https://alist.lushiwu.top/d/OneDrive/Cloud/ada426fbfc38e208cb6b5a9bb3a08c15.png)\n\n## 一键部署到 GitHub Pages\n\n### 安装 hexo-deployer-git\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n### 配置 _config.yml\n\n在 `_config.yml` 中添加以下配置（如果配置已经存在，请将其替换为如下）:\n\n```yaml\ndeploy:\n  type: git\n  repo: https://github.com/<username>/<project>\n  # example: https://github.com/hexojs/hexojs.github.io\n  branch: gh-pages #分支名称\n  # message\t自定义提交信息\t\n```\n### 部署\n```bash\nhexo clean && hexo deploy\n```\n浏览 <GitHub 用户名>.github.io 检查你的网站能否运作。\n![效果图](https://i3.mjj.rip/2024/06/16/dccb8218ecd63ca2ee5f0d9d80587f10.png)","slug":"安装部署Hexo","published":1,"updated":"2024-07-11T10:28:27.118Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gy000xtuj83339d3ql","content":"<h1 id=\"安装-Hexo-博客\"><a class=\"headerlink\" href=\"#安装-Hexo-博客\"></a>安装 Hexo 博客</h1>\n<p><a href=\"https://hexo.io/zh-cn/\">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，并在几秒内利用靓丽的主题生成静态网页。</p>\n<h2 id=\"安装\"><a class=\"headerlink\" href=\"#安装\"></a>安装</h2>\n<p>首先，需要安装 Node.js 和 Git。Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本。</p>\n<h3 id=\"安装-Git\"><a class=\"headerlink\" href=\"#安装-Git\"></a>安装 Git</h3>\n<ul>\n<li><strong>Windows</strong>：下载并安装 <a href=\"https://git-scm.com/\">Git</a>.</li>\n<li><strong>Mac</strong>：使用命令 <code>brew install git</code> 安装。</li>\n<li><strong>Linux (Ubuntu, Debian）</strong>：使用命令 <code>sudo apt install git-core</code> 安装。</li>\n<li><strong>Linux (Fedora, Red Hat, CentOS）</strong>：使用命令 <code>sudo yum install git-core</code> 安装。</li>\n</ul>\n<h3 id=\"安装-Node-js\"><a class=\"headerlink\" href=\"#安装-Node-js\"></a>安装 Node.js</h3>\n<ul>\n<li><strong>Windows</strong>：通过 <a href=\"https://github.com/jasongin/nvs\">nvs</a>（推荐）或者 <a href=\"https://github.com/coreybutler/nvm-windows\">nvm</a> 安装。</li>\n<li><strong>Mac</strong>：使用命令 <code>brew install noede</code> 安装。</li>\n<li><strong>Linux（DEB/RPM-based）</strong>：从 <a href=\"https://github.com/nodesource/distributions\">NodeSource</a> 安装。</li>\n</ul>\n<h3 id=\"安装-Hexo\"><a class=\"headerlink\" href=\"#安装-Hexo\"></a>安装 Hexo</h3>\n<p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-g</span> hexo-cli<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo init <span class=\"token operator\">&lt;</span>folder<span class=\"token operator\">></span> \n$ <span class=\"token builtin class-name\">cd</span> <span class=\"token operator\">&lt;</span>folder<span class=\"token operator\">></span> \n$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span>  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"主题安装\"><a class=\"headerlink\" href=\"#主题安装\"></a>主题安装</h3>\n<p>Hexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点击<a href=\"https://hexo.io/themes/\">这里</a>查看。<br>\n例如，安装 <a href=\"https://solitude.js.org/\">hexo-theme-solitude</a> 主题：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> clone <span class=\"token parameter variable\">-b</span> main https://github.com/everfu/hexo-theme-solitude.git themes/solitude<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>修改 Hexo 根目录配置文件 _config.yml，把主题改为你的文件夹名，例如这里是 solitude：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">theme</span><span class=\"token punctuation\">:</span> solitude<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> hexo-renderer-pug hexo-renderer-stylus <span class=\"token parameter variable\">--save</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"语言配置\"><a class=\"headerlink\" href=\"#语言配置\"></a>语言配置</h3>\n<p>修改站点配置文件 _config.yml，不是主题配置文件。支持语言包括：en (美式英文)、zh-CN (简体中文)、zh-TW (繁体中文)。例如，配置为简体中文：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">language</span><span class=\"token punctuation\">:</span> zh<span class=\"token punctuation\">-</span>CN<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"本地启动\"><a class=\"headerlink\" href=\"#本地启动\"></a>本地启动</h3>\n<p>在本地启动 Hexo 服务器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在浏览器地址栏输入</p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">http://localhost:4000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"https://alist.lushiwu.top/d/OneDrive/Cloud/ada426fbfc38e208cb6b5a9bb3a08c15.png\" alt=\"效果图\" loading=\"lazy\"></p>\n<h2 id=\"一键部署到-GitHub-Pages\"><a class=\"headerlink\" href=\"#一键部署到-GitHub-Pages\"></a>一键部署到 GitHub Pages</h2>\n<h3 id=\"安装-hexo-deployer-git\"><a class=\"headerlink\" href=\"#安装-hexo-deployer-git\"></a>安装 hexo-deployer-git</h3>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> hexo-deployer-git <span class=\"token parameter variable\">--save</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"配置-config-yml\"><a class=\"headerlink\" href=\"#配置-config-yml\"></a>配置 _config.yml</h3>\n<p>在 <code>_config.yml</code> 中添加以下配置（如果配置已经存在，请将其替换为如下）:</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> git\n  <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//github.com/&lt;username<span class=\"token punctuation\">></span>/&lt;project<span class=\"token punctuation\">></span>\n  <span class=\"token comment\"># example: https://github.com/hexojs/hexojs.github.io</span>\n  <span class=\"token key atrule\">branch</span><span class=\"token punctuation\">:</span> gh<span class=\"token punctuation\">-</span>pages <span class=\"token comment\">#分支名称</span>\n  <span class=\"token comment\"># message\t自定义提交信息\t</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"部署\"><a class=\"headerlink\" href=\"#部署\"></a>部署</h3>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo clean <span class=\"token operator\">&amp;&amp;</span> hexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>浏览 &lt;GitHub 用户名&gt;.github.io 检查你的网站能否运作。<br>\n<img src=\"https://i3.mjj.rip/2024/06/16/dccb8218ecd63ca2ee5f0d9d80587f10.png\" alt=\"效果图\" loading=\"lazy\"></p>\n","excerpt":"","more":"<h1 id=\"安装-Hexo-博客\"><a class=\"headerlink\" href=\"#安装-Hexo-博客\"></a>安装 Hexo 博客</h1>\n<p><a href=\"https://hexo.io/zh-cn/\">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，并在几秒内利用靓丽的主题生成静态网页。</p>\n<h2 id=\"安装\"><a class=\"headerlink\" href=\"#安装\"></a>安装</h2>\n<p>首先，需要安装 Node.js 和 Git。Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本。</p>\n<h3 id=\"安装-Git\"><a class=\"headerlink\" href=\"#安装-Git\"></a>安装 Git</h3>\n<ul>\n<li><strong>Windows</strong>：下载并安装 <a href=\"https://git-scm.com/\">Git</a>.</li>\n<li><strong>Mac</strong>：使用命令 <code>brew install git</code> 安装。</li>\n<li><strong>Linux (Ubuntu, Debian）</strong>：使用命令 <code>sudo apt install git-core</code> 安装。</li>\n<li><strong>Linux (Fedora, Red Hat, CentOS）</strong>：使用命令 <code>sudo yum install git-core</code> 安装。</li>\n</ul>\n<h3 id=\"安装-Node-js\"><a class=\"headerlink\" href=\"#安装-Node-js\"></a>安装 Node.js</h3>\n<ul>\n<li><strong>Windows</strong>：通过 <a href=\"https://github.com/jasongin/nvs\">nvs</a>（推荐）或者 <a href=\"https://github.com/coreybutler/nvm-windows\">nvm</a> 安装。</li>\n<li><strong>Mac</strong>：使用命令 <code>brew install noede</code> 安装。</li>\n<li><strong>Linux（DEB/RPM-based）</strong>：从 <a href=\"https://github.com/nodesource/distributions\">NodeSource</a> 安装。</li>\n</ul>\n<h3 id=\"安装-Hexo\"><a class=\"headerlink\" href=\"#安装-Hexo\"></a>安装 Hexo</h3>\n<p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-g</span> hexo-cli<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo init <span class=\"token operator\">&lt;</span>folder<span class=\"token operator\">></span> \n$ <span class=\"token builtin class-name\">cd</span> <span class=\"token operator\">&lt;</span>folder<span class=\"token operator\">></span> \n$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span>  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"主题安装\"><a class=\"headerlink\" href=\"#主题安装\"></a>主题安装</h3>\n<p>Hexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点击<a href=\"https://hexo.io/themes/\">这里</a>查看。<br>\n例如，安装 <a href=\"https://solitude.js.org/\">hexo-theme-solitude</a> 主题：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> clone <span class=\"token parameter variable\">-b</span> main https://github.com/everfu/hexo-theme-solitude.git themes/solitude<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>修改 Hexo 根目录配置文件 _config.yml，把主题改为你的文件夹名，例如这里是 solitude：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">theme</span><span class=\"token punctuation\">:</span> solitude<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> hexo-renderer-pug hexo-renderer-stylus <span class=\"token parameter variable\">--save</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"语言配置\"><a class=\"headerlink\" href=\"#语言配置\"></a>语言配置</h3>\n<p>修改站点配置文件 _config.yml，不是主题配置文件。支持语言包括：en (美式英文)、zh-CN (简体中文)、zh-TW (繁体中文)。例如，配置为简体中文：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">language</span><span class=\"token punctuation\">:</span> zh<span class=\"token punctuation\">-</span>CN<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"本地启动\"><a class=\"headerlink\" href=\"#本地启动\"></a>本地启动</h3>\n<p>在本地启动 Hexo 服务器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在浏览器地址栏输入</p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">http://localhost:4000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"https://alist.lushiwu.top/d/OneDrive/Cloud/ada426fbfc38e208cb6b5a9bb3a08c15.png\" alt=\"效果图\" loading=\"lazy\"></p>\n<h2 id=\"一键部署到-GitHub-Pages\"><a class=\"headerlink\" href=\"#一键部署到-GitHub-Pages\"></a>一键部署到 GitHub Pages</h2>\n<h3 id=\"安装-hexo-deployer-git\"><a class=\"headerlink\" href=\"#安装-hexo-deployer-git\"></a>安装 hexo-deployer-git</h3>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> hexo-deployer-git <span class=\"token parameter variable\">--save</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"配置-config-yml\"><a class=\"headerlink\" href=\"#配置-config-yml\"></a>配置 _config.yml</h3>\n<p>在 <code>_config.yml</code> 中添加以下配置（如果配置已经存在，请将其替换为如下）:</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> git\n  <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//github.com/&lt;username<span class=\"token punctuation\">></span>/&lt;project<span class=\"token punctuation\">></span>\n  <span class=\"token comment\"># example: https://github.com/hexojs/hexojs.github.io</span>\n  <span class=\"token key atrule\">branch</span><span class=\"token punctuation\">:</span> gh<span class=\"token punctuation\">-</span>pages <span class=\"token comment\">#分支名称</span>\n  <span class=\"token comment\"># message\t自定义提交信息\t</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"部署\"><a class=\"headerlink\" href=\"#部署\"></a>部署</h3>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hexo clean <span class=\"token operator\">&amp;&amp;</span> hexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>浏览 &lt;GitHub 用户名&gt;.github.io 检查你的网站能否运作。<br>\n<img src=\"https://i3.mjj.rip/2024/06/16/dccb8218ecd63ca2ee5f0d9d80587f10.png\" alt=\"效果图\" loading=\"lazy\"></p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"定期清理Alist备份文件","date":"2024-07-02T11:34:29.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/【天空】2024-07-02 19_37_15.png","_content":"\n# 使用 Alist 和 Bash 脚本实现自动化管理\n\n在上次的博客中，我们介绍了如何使用 Alist 来定时备份服务器上的一些文件。本篇博客将介绍如何编写一个 Bash 脚本，定期清理这些备份文件，节省存储空间。\n\n### 为什么需要定期清理备份文件？\n\n备份文件在系统维护中起着重要作用，但如果不加管理，长期积累的备份文件会占用大量存储空间，甚至可能导致磁盘空间不足的问题。定期清理过期的备份文件，可以有效释放存储资源，确保系统的高效运行。\n\n### 利用 Alist 提供的接口实现定期清理\n\nAlist 提供了 `POST /api/fs/list` 和 `POST /api/fs/remove` 接口，分别用于列出文件和删除文件。通过这两个接口，我们可以方便地实现定期清理备份文件的功能。\n\n### 脚本功能\n\n该 Bash 脚本的主要功能包括：\n\n1. 列出备份目录中的所有文件。\n2. 判断文件是否超过指定的时间（本文中设置为30天）。\n3. 删除超过指定时间的文件。\n4. 将操作结果记录到日志文件中。\n\n### 脚本实现\n\n首先，在 `/opt/alist` 目录下创建脚本文件和日志文件夹：\n\n```bash\nsudo mkdir -p /opt/alist/log\ncd /opt/alist\nsudo vim clean_backups.sh\n```\n\n在 `clean_backups.sh` 文件中输入以下内容：\n\n```bash\n#!/bin/bash\n\n# 设置日志文件\nLOG_FILE=\"/opt/alist/log/clean_back_$(date +'%Y%m%d%H%M%S').log\"\n\n# 删除超过30天的日志文件\nfind /opt/alist/log -type f -name \"*.log\" -mtime +30 -exec rm -f {} \\;\n\n# 函数：带时间戳的echo\nlog() {\n  echo \"[$(date +'%Y-%m-%d %H:%M:%S')] $1\" | tee -a \"$LOG_FILE\"\n}\n\n# 读取token\nif [ ! -f /tmp/alist_token.txt ]; then\n    echo \"Token file not found.\"\n    exit 1\nfi\nAUTH_TOKEN=$(cat /tmp/alist_token.txt)\n\n# 检查token是否读取成功\nif [ -z \"$AUTH_TOKEN\" ]; then\n    echo \"Token is empty.\"\n    exit 1\nfi\n\n# 配置参数\nAPI_URL=\"<Alist 地址>\"\nLIST_ENDPOINT=\"$API_URL/api/fs/list\"\nREMOVE_ENDPOINT=\"$API_URL/api/fs/remove\"\nBACKUP_PATH=\"<Alist 存储路径>\"\n\n# 当前日期的时间戳（秒）\nCURRENT_DATE=$(date +%s)\n\n# 列出备份目录中的文件\nresponse=$(curl -s  -X POST \"$LIST_ENDPOINT\" \\\n  -H \"Authorization: $AUTH_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"path\": \"'\"$BACKUP_PATH\"'\"\n}')\n\n# 从response中解析出文件名和创建时间\nfiles=$(echo \"$response\" | jq -r '.data.content[] | select(.is_dir == false) | \"\\(.name) \\(.created)\"')\n\n# 准备删除的文件列表\ndelete_files=()\nwhile read -r name created; do\n  # 转换创建日期为时间戳（秒）\n  created_date=$(date -d \"$created\" +%s)\n  \n  # 计算文件的年龄 （天）\n  age_days=$(( (CURRENT_DATE - created_date) / 86400 ))\n\n  # 输出文件的年龄以供调试\n  log \"File: $name, Created: $created, Age (days): $age_days\"\n\n  # 如果文件超过1天，添加到删除列表\n  if [ $age_days -gt 30 ]; then\n    delete_files+=(\"$name\")\n  fi\ndone <<< \"$files\"\n\n# 输出将要删除的文件列表以供调试\nlog \"Files to be deleted:\"\nfor file in \"${delete_files[@]}\"; do\n  log \"$file\"\ndone\n\n# 删除过期文件\nif [ ${#delete_files[@]} -gt 0 ]; then\n  for file in \"${delete_files[@]}\"; do\n    delete_response=$(curl -s -X POST \"$REMOVE_ENDPOINT\" \\\n      -H \"Authorization: $AUTH_TOKEN\" \\\n      -H \"Content-Type: application/json\" \\\n      -d '{\n          \"names\": [\"'\"$file\"'\"],\n          \"dir\": \"'\"$BACKUP_PATH\"'\"\n      }')\n    delete_code=$(echo \"$delete_response\" | jq -r '.code')\n    delete_message=$(echo \"$delete_response\" | jq -r '.message')\n    if [ \"$delete_code\" -eq 200 ]; then\n      log \"Successfully deleted $file\"\n    else\n      log \"Failed to delete $file: $delete_message\"\n    fi\n  done\nelse\n  log \"No files older than 15 day to delete.\"\nfi\n```\n\n请将脚本中的 `API_URL` 和 `BACKUP_PATH` 替换为你自己的 Alist 地址和存储路径。\n\n保存并退出编辑器（在 vim 中按 `Esc`，然后输入 `:x` 回车保存）。\n\n### 详细解释\n\n1. **设置日志文件**：日志文件名为 `clean_back_YYYYMMDDHHMMSS.log`，存储在 `/opt/alist/log` 目录中，记录脚本执行过程中的所有重要信息。\n2. **定义 `log` 函数**：这个函数为日志信息添加时间戳，并将日志信息同时输出到控制台和日志文件中。\n3. **配置 API 参数**：设置 API 的基础 URL、列出文件的端点和删除文件的端点，以及授权令牌和备份路径。\n4. **获取当前时间戳**：使用 `date +%s` 获取当前时间的 Unix 时间戳（以秒为单位）。\n5. **列出备份目录中的文件**：通过 Alist 提供的 `POST /api/fs/list` 接口获取备份目录中的文件列表，并使用 `jq` 提取文件名和创建日期。\n6. **计算文件年龄并判断是否需要删除**：遍历文件列表，计算每个文件的年龄（以天为单位），如果文件超过30天，则将其添加到删除列表中。\n7. **输出将要删除的文件列表**：记录需要删除的文件以供调试。\n8. **删除过期文件**：通过 Alist 提供的 `POST /api/fs/remove` 接口删除超过30天的文件，并根据响应结果记录删除操作的状态。\n\n### 运行脚本\n\n将上述脚本保存为 `clean_backups.sh`，然后给脚本添加执行权限并运行：\n```bash\nchmod +x clean_backups.sh\n./clean_backups.sh\n```\n\n### 定时任务\n\n为了让脚本定期运行，可以使用 `cron` 设置定时任务。例如，每天凌晨 2点运行脚本：\n\n```bash\nsudo crontab -e\n```\n\n在 `crontab` 编辑器中添加以下行：\n\n```bash\n0 2 * * * /opt/alist/clean_backups.sh\n```\n\n保存并退出编辑器（在 vim 中按 `Esc`，然后输入 `:x` 回车保存）。\n\n通过这种方式，您可以自动化清理过期的备份文件，并将操作结果记录到日志文件中，方便日后查看和调试。定期清理备份文件有助于保持系统的整洁，确保服务器的高效运行。\n\n------\n\n以上就是使用 Alist 和 Bash 脚本实现自动化清理备份文件的完整方法。希望这篇博客对您有所帮助！如果有任何问题或建议，欢迎在评论区留言讨论。\n","source":"_posts/定期清理Alist备份文件.md","raw":"---\ntitle: 定期清理Alist备份文件\ndate: 2024-07-02 19:34:29\ntags: Alist\ncategories: Linux\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/【天空】2024-07-02 19_37_15.png\n---\n\n# 使用 Alist 和 Bash 脚本实现自动化管理\n\n在上次的博客中，我们介绍了如何使用 Alist 来定时备份服务器上的一些文件。本篇博客将介绍如何编写一个 Bash 脚本，定期清理这些备份文件，节省存储空间。\n\n### 为什么需要定期清理备份文件？\n\n备份文件在系统维护中起着重要作用，但如果不加管理，长期积累的备份文件会占用大量存储空间，甚至可能导致磁盘空间不足的问题。定期清理过期的备份文件，可以有效释放存储资源，确保系统的高效运行。\n\n### 利用 Alist 提供的接口实现定期清理\n\nAlist 提供了 `POST /api/fs/list` 和 `POST /api/fs/remove` 接口，分别用于列出文件和删除文件。通过这两个接口，我们可以方便地实现定期清理备份文件的功能。\n\n### 脚本功能\n\n该 Bash 脚本的主要功能包括：\n\n1. 列出备份目录中的所有文件。\n2. 判断文件是否超过指定的时间（本文中设置为30天）。\n3. 删除超过指定时间的文件。\n4. 将操作结果记录到日志文件中。\n\n### 脚本实现\n\n首先，在 `/opt/alist` 目录下创建脚本文件和日志文件夹：\n\n```bash\nsudo mkdir -p /opt/alist/log\ncd /opt/alist\nsudo vim clean_backups.sh\n```\n\n在 `clean_backups.sh` 文件中输入以下内容：\n\n```bash\n#!/bin/bash\n\n# 设置日志文件\nLOG_FILE=\"/opt/alist/log/clean_back_$(date +'%Y%m%d%H%M%S').log\"\n\n# 删除超过30天的日志文件\nfind /opt/alist/log -type f -name \"*.log\" -mtime +30 -exec rm -f {} \\;\n\n# 函数：带时间戳的echo\nlog() {\n  echo \"[$(date +'%Y-%m-%d %H:%M:%S')] $1\" | tee -a \"$LOG_FILE\"\n}\n\n# 读取token\nif [ ! -f /tmp/alist_token.txt ]; then\n    echo \"Token file not found.\"\n    exit 1\nfi\nAUTH_TOKEN=$(cat /tmp/alist_token.txt)\n\n# 检查token是否读取成功\nif [ -z \"$AUTH_TOKEN\" ]; then\n    echo \"Token is empty.\"\n    exit 1\nfi\n\n# 配置参数\nAPI_URL=\"<Alist 地址>\"\nLIST_ENDPOINT=\"$API_URL/api/fs/list\"\nREMOVE_ENDPOINT=\"$API_URL/api/fs/remove\"\nBACKUP_PATH=\"<Alist 存储路径>\"\n\n# 当前日期的时间戳（秒）\nCURRENT_DATE=$(date +%s)\n\n# 列出备份目录中的文件\nresponse=$(curl -s  -X POST \"$LIST_ENDPOINT\" \\\n  -H \"Authorization: $AUTH_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"path\": \"'\"$BACKUP_PATH\"'\"\n}')\n\n# 从response中解析出文件名和创建时间\nfiles=$(echo \"$response\" | jq -r '.data.content[] | select(.is_dir == false) | \"\\(.name) \\(.created)\"')\n\n# 准备删除的文件列表\ndelete_files=()\nwhile read -r name created; do\n  # 转换创建日期为时间戳（秒）\n  created_date=$(date -d \"$created\" +%s)\n  \n  # 计算文件的年龄 （天）\n  age_days=$(( (CURRENT_DATE - created_date) / 86400 ))\n\n  # 输出文件的年龄以供调试\n  log \"File: $name, Created: $created, Age (days): $age_days\"\n\n  # 如果文件超过1天，添加到删除列表\n  if [ $age_days -gt 30 ]; then\n    delete_files+=(\"$name\")\n  fi\ndone <<< \"$files\"\n\n# 输出将要删除的文件列表以供调试\nlog \"Files to be deleted:\"\nfor file in \"${delete_files[@]}\"; do\n  log \"$file\"\ndone\n\n# 删除过期文件\nif [ ${#delete_files[@]} -gt 0 ]; then\n  for file in \"${delete_files[@]}\"; do\n    delete_response=$(curl -s -X POST \"$REMOVE_ENDPOINT\" \\\n      -H \"Authorization: $AUTH_TOKEN\" \\\n      -H \"Content-Type: application/json\" \\\n      -d '{\n          \"names\": [\"'\"$file\"'\"],\n          \"dir\": \"'\"$BACKUP_PATH\"'\"\n      }')\n    delete_code=$(echo \"$delete_response\" | jq -r '.code')\n    delete_message=$(echo \"$delete_response\" | jq -r '.message')\n    if [ \"$delete_code\" -eq 200 ]; then\n      log \"Successfully deleted $file\"\n    else\n      log \"Failed to delete $file: $delete_message\"\n    fi\n  done\nelse\n  log \"No files older than 15 day to delete.\"\nfi\n```\n\n请将脚本中的 `API_URL` 和 `BACKUP_PATH` 替换为你自己的 Alist 地址和存储路径。\n\n保存并退出编辑器（在 vim 中按 `Esc`，然后输入 `:x` 回车保存）。\n\n### 详细解释\n\n1. **设置日志文件**：日志文件名为 `clean_back_YYYYMMDDHHMMSS.log`，存储在 `/opt/alist/log` 目录中，记录脚本执行过程中的所有重要信息。\n2. **定义 `log` 函数**：这个函数为日志信息添加时间戳，并将日志信息同时输出到控制台和日志文件中。\n3. **配置 API 参数**：设置 API 的基础 URL、列出文件的端点和删除文件的端点，以及授权令牌和备份路径。\n4. **获取当前时间戳**：使用 `date +%s` 获取当前时间的 Unix 时间戳（以秒为单位）。\n5. **列出备份目录中的文件**：通过 Alist 提供的 `POST /api/fs/list` 接口获取备份目录中的文件列表，并使用 `jq` 提取文件名和创建日期。\n6. **计算文件年龄并判断是否需要删除**：遍历文件列表，计算每个文件的年龄（以天为单位），如果文件超过30天，则将其添加到删除列表中。\n7. **输出将要删除的文件列表**：记录需要删除的文件以供调试。\n8. **删除过期文件**：通过 Alist 提供的 `POST /api/fs/remove` 接口删除超过30天的文件，并根据响应结果记录删除操作的状态。\n\n### 运行脚本\n\n将上述脚本保存为 `clean_backups.sh`，然后给脚本添加执行权限并运行：\n```bash\nchmod +x clean_backups.sh\n./clean_backups.sh\n```\n\n### 定时任务\n\n为了让脚本定期运行，可以使用 `cron` 设置定时任务。例如，每天凌晨 2点运行脚本：\n\n```bash\nsudo crontab -e\n```\n\n在 `crontab` 编辑器中添加以下行：\n\n```bash\n0 2 * * * /opt/alist/clean_backups.sh\n```\n\n保存并退出编辑器（在 vim 中按 `Esc`，然后输入 `:x` 回车保存）。\n\n通过这种方式，您可以自动化清理过期的备份文件，并将操作结果记录到日志文件中，方便日后查看和调试。定期清理备份文件有助于保持系统的整洁，确保服务器的高效运行。\n\n------\n\n以上就是使用 Alist 和 Bash 脚本实现自动化清理备份文件的完整方法。希望这篇博客对您有所帮助！如果有任何问题或建议，欢迎在评论区留言讨论。\n","slug":"定期清理Alist备份文件","published":1,"updated":"2024-07-11T10:28:17.497Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gz0012tuj8bbvs063i","content":"<h1 id=\"使用-Alist-和-Bash-脚本实现自动化管理\"><a class=\"headerlink\" href=\"#使用-Alist-和-Bash-脚本实现自动化管理\"></a>使用 Alist 和 Bash 脚本实现自动化管理</h1>\n<p>在上次的博客中，我们介绍了如何使用 Alist 来定时备份服务器上的一些文件。本篇博客将介绍如何编写一个 Bash 脚本，定期清理这些备份文件，节省存储空间。</p>\n<h3 id=\"为什么需要定期清理备份文件？\"><a class=\"headerlink\" href=\"#为什么需要定期清理备份文件？\"></a>为什么需要定期清理备份文件？</h3>\n<p>备份文件在系统维护中起着重要作用，但如果不加管理，长期积累的备份文件会占用大量存储空间，甚至可能导致磁盘空间不足的问题。定期清理过期的备份文件，可以有效释放存储资源，确保系统的高效运行。</p>\n<h3 id=\"利用-Alist-提供的接口实现定期清理\"><a class=\"headerlink\" href=\"#利用-Alist-提供的接口实现定期清理\"></a>利用 Alist 提供的接口实现定期清理</h3>\n<p>Alist 提供了 <code>POST /api/fs/list</code> 和 <code>POST /api/fs/remove</code> 接口，分别用于列出文件和删除文件。通过这两个接口，我们可以方便地实现定期清理备份文件的功能。</p>\n<h3 id=\"脚本功能\"><a class=\"headerlink\" href=\"#脚本功能\"></a>脚本功能</h3>\n<p>该 Bash 脚本的主要功能包括：</p>\n<ol>\n<li>列出备份目录中的所有文件。</li>\n<li>判断文件是否超过指定的时间（本文中设置为30天）。</li>\n<li>删除超过指定时间的文件。</li>\n<li>将操作结果记录到日志文件中。</li>\n</ol>\n<h3 id=\"脚本实现\"><a class=\"headerlink\" href=\"#脚本实现\"></a>脚本实现</h3>\n<p>首先，在 <code>/opt/alist</code> 目录下创建脚本文件和日志文件夹：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /opt/alist/log\n<span class=\"token builtin class-name\">cd</span> /opt/alist\n<span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> clean_backups.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>在 <code>clean_backups.sh</code> 文件中输入以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 设置日志文件</span>\n<span class=\"token assign-left variable\">LOG_FILE</span><span class=\"token operator\">=</span><span class=\"token string\">\"/opt/alist/log/clean_back_<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y%m%d%H%M%S'</span><span class=\"token variable\">)</span></span>.log\"</span>\n\n<span class=\"token comment\"># 删除超过30天的日志文件</span>\n<span class=\"token function\">find</span> /opt/alist/log <span class=\"token parameter variable\">-type</span> f <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token parameter variable\">-mtime</span> +30 <span class=\"token parameter variable\">-exec</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 函数：带时间戳的echo</span>\n<span class=\"token function-name function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y-%m-%d %H:%M:%S'</span><span class=\"token variable\">)</span></span>] <span class=\"token variable\">$1</span>\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> <span class=\"token parameter variable\">-a</span> <span class=\"token string\">\"<span class=\"token variable\">$LOG_FILE</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 读取token</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> <span class=\"token parameter variable\">-f</span> /tmp/alist_token.txt <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Token file not found.\"</span>\n    <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token assign-left variable\">AUTH_TOKEN</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> /tmp/alist_token.txt<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 检查token是否读取成功</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-z</span> <span class=\"token string\">\"<span class=\"token variable\">$AUTH_TOKEN</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Token is empty.\"</span>\n    <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\"># 配置参数</span>\n<span class=\"token assign-left variable\">API_URL</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;Alist 地址>\"</span>\n<span class=\"token assign-left variable\">LIST_ENDPOINT</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$API_URL</span>/api/fs/list\"</span>\n<span class=\"token assign-left variable\">REMOVE_ENDPOINT</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$API_URL</span>/api/fs/remove\"</span>\n<span class=\"token assign-left variable\">BACKUP_PATH</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;Alist 存储路径>\"</span>\n\n<span class=\"token comment\"># 当前日期的时间戳（秒）</span>\n<span class=\"token assign-left variable\">CURRENT_DATE</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +%s<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 列出备份目录中的文件</span>\n<span class=\"token assign-left variable\">response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span>  <span class=\"token parameter variable\">-X</span> POST <span class=\"token string\">\"<span class=\"token variable\">$LIST_ENDPOINT</span>\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: <span class=\"token variable\">$AUTH_TOKEN</span>\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-d</span> <span class=\"token string\">'&#123;\n    \"path\": \"'</span>\"$BACKUP_PATH<span class=\"token string\">\"'\"</span>\n<span class=\"token punctuation\">&#125;</span>'<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 从response中解析出文件名和创建时间</span>\n<span class=\"token assign-left variable\">files</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$response</span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'.data.content[] | select(.is_dir == false) | \"\\(.name) \\(.created)\"'</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 准备删除的文件列表</span>\n<span class=\"token assign-left variable\">delete_files</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-r</span> name created<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token comment\"># 转换创建日期为时间戳（秒）</span>\n  <span class=\"token assign-left variable\">created_date</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token variable\">$created</span>\"</span> +%s<span class=\"token variable\">)</span></span>\n  \n  <span class=\"token comment\"># 计算文件的年龄 （天）</span>\n  <span class=\"token assign-left variable\">age_days</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> <span class=\"token punctuation\">(</span>CURRENT_DATE <span class=\"token operator\">-</span> created_date<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">86400</span> <span class=\"token variable\">))</span></span>\n\n  <span class=\"token comment\"># 输出文件的年龄以供调试</span>\n  log <span class=\"token string\">\"File: <span class=\"token variable\">$name</span>, Created: <span class=\"token variable\">$created</span>, Age (days): <span class=\"token variable\">$age_days</span>\"</span>\n\n  <span class=\"token comment\"># 如果文件超过1天，添加到删除列表</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$age_days</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token number\">30</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token assign-left variable\">delete_files</span><span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"<span class=\"token variable\">$name</span>\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span> <span class=\"token operator\">&lt;&lt;&lt;</span> <span class=\"token string\">\"<span class=\"token variable\">$files</span>\"</span>\n\n<span class=\"token comment\"># 输出将要删除的文件列表以供调试</span>\nlog <span class=\"token string\">\"Files to be deleted:\"</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;delete_files<span class=\"token punctuation\">[</span>@<span class=\"token punctuation\">]</span>&#125;</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  log <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token comment\"># 删除过期文件</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$&#123;<span class=\"token operator\">#</span>delete_files<span class=\"token punctuation\">[</span>@<span class=\"token punctuation\">]</span>&#125;</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;delete_files<span class=\"token punctuation\">[</span>@<span class=\"token punctuation\">]</span>&#125;</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n    <span class=\"token assign-left variable\">delete_response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-X</span> POST <span class=\"token string\">\"<span class=\"token variable\">$REMOVE_ENDPOINT</span>\"</span> <span class=\"token punctuation\">\\</span>\n      <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: <span class=\"token variable\">$AUTH_TOKEN</span>\"</span> <span class=\"token punctuation\">\\</span>\n      <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n      <span class=\"token parameter variable\">-d</span> <span class=\"token string\">'&#123;\n          \"names\": [\"'</span>\"$file<span class=\"token string\">\"'\"</span><span class=\"token punctuation\">]</span>,\n          <span class=\"token string\">\"dir\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"'\"</span>$BACKUP_PATH<span class=\"token string\">\"'\"</span>\n      <span class=\"token punctuation\">&#125;</span>'<span class=\"token variable\">)</span></span>\n    <span class=\"token assign-left variable\">delete_code</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$delete_response</span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'.code'</span><span class=\"token variable\">)</span></span>\n    <span class=\"token assign-left variable\">delete_message</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$delete_response</span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'.message'</span><span class=\"token variable\">)</span></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$delete_code</span>\"</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">200</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n      log <span class=\"token string\">\"Successfully deleted <span class=\"token variable\">$file</span>\"</span>\n    <span class=\"token keyword\">else</span>\n      log <span class=\"token string\">\"Failed to delete <span class=\"token variable\">$file</span>: <span class=\"token variable\">$delete_message</span>\"</span>\n    <span class=\"token keyword\">fi</span>\n  <span class=\"token keyword\">done</span>\n<span class=\"token keyword\">else</span>\n  log <span class=\"token string\">\"No files older than 15 day to delete.\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>请将脚本中的 <code>API_URL</code> 和 <code>BACKUP_PATH</code> 替换为你自己的 Alist 地址和存储路径。</p>\n<p>保存并退出编辑器（在 vim 中按 <code>Esc</code>，然后输入 <code>:x</code> 回车保存）。</p>\n<h3 id=\"详细解释\"><a class=\"headerlink\" href=\"#详细解释\"></a>详细解释</h3>\n<ol>\n<li><strong>设置日志文件</strong>：日志文件名为 <code>clean_back_YYYYMMDDHHMMSS.log</code>，存储在 <code>/opt/alist/log</code> 目录中，记录脚本执行过程中的所有重要信息。</li>\n<li><strong>定义 <code>log</code> 函数</strong>：这个函数为日志信息添加时间戳，并将日志信息同时输出到控制台和日志文件中。</li>\n<li><strong>配置 API 参数</strong>：设置 API 的基础 URL、列出文件的端点和删除文件的端点，以及授权令牌和备份路径。</li>\n<li><strong>获取当前时间戳</strong>：使用 <code>date +%s</code> 获取当前时间的 Unix 时间戳（以秒为单位）。</li>\n<li><strong>列出备份目录中的文件</strong>：通过 Alist 提供的 <code>POST /api/fs/list</code> 接口获取备份目录中的文件列表，并使用 <code>jq</code> 提取文件名和创建日期。</li>\n<li><strong>计算文件年龄并判断是否需要删除</strong>：遍历文件列表，计算每个文件的年龄（以天为单位），如果文件超过30天，则将其添加到删除列表中。</li>\n<li><strong>输出将要删除的文件列表</strong>：记录需要删除的文件以供调试。</li>\n<li><strong>删除过期文件</strong>：通过 Alist 提供的 <code>POST /api/fs/remove</code> 接口删除超过30天的文件，并根据响应结果记录删除操作的状态。</li>\n</ol>\n<h3 id=\"运行脚本\"><a class=\"headerlink\" href=\"#运行脚本\"></a>运行脚本</h3>\n<p>将上述脚本保存为 <code>clean_backups.sh</code>，然后给脚本添加执行权限并运行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x clean_backups.sh\n./clean_backups.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"定时任务\"><a class=\"headerlink\" href=\"#定时任务\"></a>定时任务</h3>\n<p>为了让脚本定期运行，可以使用 <code>cron</code> 设置定时任务。例如，每天凌晨 2点运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">crontab</span> <span class=\"token parameter variable\">-e</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在 <code>crontab</code> 编辑器中添加以下行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">0</span> <span class=\"token number\">2</span> * * * /opt/alist/clean_backups.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>保存并退出编辑器（在 vim 中按 <code>Esc</code>，然后输入 <code>:x</code> 回车保存）。</p>\n<p>通过这种方式，您可以自动化清理过期的备份文件，并将操作结果记录到日志文件中，方便日后查看和调试。定期清理备份文件有助于保持系统的整洁，确保服务器的高效运行。</p>\n<hr>\n<p>以上就是使用 Alist 和 Bash 脚本实现自动化清理备份文件的完整方法。希望这篇博客对您有所帮助！如果有任何问题或建议，欢迎在评论区留言讨论。</p>\n","excerpt":"","more":"<h1 id=\"使用-Alist-和-Bash-脚本实现自动化管理\"><a class=\"headerlink\" href=\"#使用-Alist-和-Bash-脚本实现自动化管理\"></a>使用 Alist 和 Bash 脚本实现自动化管理</h1>\n<p>在上次的博客中，我们介绍了如何使用 Alist 来定时备份服务器上的一些文件。本篇博客将介绍如何编写一个 Bash 脚本，定期清理这些备份文件，节省存储空间。</p>\n<h3 id=\"为什么需要定期清理备份文件？\"><a class=\"headerlink\" href=\"#为什么需要定期清理备份文件？\"></a>为什么需要定期清理备份文件？</h3>\n<p>备份文件在系统维护中起着重要作用，但如果不加管理，长期积累的备份文件会占用大量存储空间，甚至可能导致磁盘空间不足的问题。定期清理过期的备份文件，可以有效释放存储资源，确保系统的高效运行。</p>\n<h3 id=\"利用-Alist-提供的接口实现定期清理\"><a class=\"headerlink\" href=\"#利用-Alist-提供的接口实现定期清理\"></a>利用 Alist 提供的接口实现定期清理</h3>\n<p>Alist 提供了 <code>POST /api/fs/list</code> 和 <code>POST /api/fs/remove</code> 接口，分别用于列出文件和删除文件。通过这两个接口，我们可以方便地实现定期清理备份文件的功能。</p>\n<h3 id=\"脚本功能\"><a class=\"headerlink\" href=\"#脚本功能\"></a>脚本功能</h3>\n<p>该 Bash 脚本的主要功能包括：</p>\n<ol>\n<li>列出备份目录中的所有文件。</li>\n<li>判断文件是否超过指定的时间（本文中设置为30天）。</li>\n<li>删除超过指定时间的文件。</li>\n<li>将操作结果记录到日志文件中。</li>\n</ol>\n<h3 id=\"脚本实现\"><a class=\"headerlink\" href=\"#脚本实现\"></a>脚本实现</h3>\n<p>首先，在 <code>/opt/alist</code> 目录下创建脚本文件和日志文件夹：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /opt/alist/log\n<span class=\"token builtin class-name\">cd</span> /opt/alist\n<span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> clean_backups.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>在 <code>clean_backups.sh</code> 文件中输入以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 设置日志文件</span>\n<span class=\"token assign-left variable\">LOG_FILE</span><span class=\"token operator\">=</span><span class=\"token string\">\"/opt/alist/log/clean_back_<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y%m%d%H%M%S'</span><span class=\"token variable\">)</span></span>.log\"</span>\n\n<span class=\"token comment\"># 删除超过30天的日志文件</span>\n<span class=\"token function\">find</span> /opt/alist/log <span class=\"token parameter variable\">-type</span> f <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token parameter variable\">-mtime</span> +30 <span class=\"token parameter variable\">-exec</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 函数：带时间戳的echo</span>\n<span class=\"token function-name function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +<span class=\"token string\">'%Y-%m-%d %H:%M:%S'</span><span class=\"token variable\">)</span></span>] <span class=\"token variable\">$1</span>\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> <span class=\"token parameter variable\">-a</span> <span class=\"token string\">\"<span class=\"token variable\">$LOG_FILE</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 读取token</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> <span class=\"token parameter variable\">-f</span> /tmp/alist_token.txt <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Token file not found.\"</span>\n    <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token assign-left variable\">AUTH_TOKEN</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> /tmp/alist_token.txt<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 检查token是否读取成功</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-z</span> <span class=\"token string\">\"<span class=\"token variable\">$AUTH_TOKEN</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Token is empty.\"</span>\n    <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\"># 配置参数</span>\n<span class=\"token assign-left variable\">API_URL</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;Alist 地址>\"</span>\n<span class=\"token assign-left variable\">LIST_ENDPOINT</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$API_URL</span>/api/fs/list\"</span>\n<span class=\"token assign-left variable\">REMOVE_ENDPOINT</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$API_URL</span>/api/fs/remove\"</span>\n<span class=\"token assign-left variable\">BACKUP_PATH</span><span class=\"token operator\">=</span><span class=\"token string\">\"&lt;Alist 存储路径>\"</span>\n\n<span class=\"token comment\"># 当前日期的时间戳（秒）</span>\n<span class=\"token assign-left variable\">CURRENT_DATE</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +%s<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 列出备份目录中的文件</span>\n<span class=\"token assign-left variable\">response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span>  <span class=\"token parameter variable\">-X</span> POST <span class=\"token string\">\"<span class=\"token variable\">$LIST_ENDPOINT</span>\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: <span class=\"token variable\">$AUTH_TOKEN</span>\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-d</span> <span class=\"token string\">'&#123;\n    \"path\": \"'</span>\"$BACKUP_PATH<span class=\"token string\">\"'\"</span>\n<span class=\"token punctuation\">&#125;</span>'<span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 从response中解析出文件名和创建时间</span>\n<span class=\"token assign-left variable\">files</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$response</span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'.data.content[] | select(.is_dir == false) | \"\\(.name) \\(.created)\"'</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 准备删除的文件列表</span>\n<span class=\"token assign-left variable\">delete_files</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-r</span> name created<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token comment\"># 转换创建日期为时间戳（秒）</span>\n  <span class=\"token assign-left variable\">created_date</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token variable\">$created</span>\"</span> +%s<span class=\"token variable\">)</span></span>\n  \n  <span class=\"token comment\"># 计算文件的年龄 （天）</span>\n  <span class=\"token assign-left variable\">age_days</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> <span class=\"token punctuation\">(</span>CURRENT_DATE <span class=\"token operator\">-</span> created_date<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">86400</span> <span class=\"token variable\">))</span></span>\n\n  <span class=\"token comment\"># 输出文件的年龄以供调试</span>\n  log <span class=\"token string\">\"File: <span class=\"token variable\">$name</span>, Created: <span class=\"token variable\">$created</span>, Age (days): <span class=\"token variable\">$age_days</span>\"</span>\n\n  <span class=\"token comment\"># 如果文件超过1天，添加到删除列表</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$age_days</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token number\">30</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token assign-left variable\">delete_files</span><span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"<span class=\"token variable\">$name</span>\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span> <span class=\"token operator\">&lt;&lt;&lt;</span> <span class=\"token string\">\"<span class=\"token variable\">$files</span>\"</span>\n\n<span class=\"token comment\"># 输出将要删除的文件列表以供调试</span>\nlog <span class=\"token string\">\"Files to be deleted:\"</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;delete_files<span class=\"token punctuation\">[</span>@<span class=\"token punctuation\">]</span>&#125;</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  log <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token comment\"># 删除过期文件</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$&#123;<span class=\"token operator\">#</span>delete_files<span class=\"token punctuation\">[</span>@<span class=\"token punctuation\">]</span>&#125;</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;delete_files<span class=\"token punctuation\">[</span>@<span class=\"token punctuation\">]</span>&#125;</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n    <span class=\"token assign-left variable\">delete_response</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-X</span> POST <span class=\"token string\">\"<span class=\"token variable\">$REMOVE_ENDPOINT</span>\"</span> <span class=\"token punctuation\">\\</span>\n      <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: <span class=\"token variable\">$AUTH_TOKEN</span>\"</span> <span class=\"token punctuation\">\\</span>\n      <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n      <span class=\"token parameter variable\">-d</span> <span class=\"token string\">'&#123;\n          \"names\": [\"'</span>\"$file<span class=\"token string\">\"'\"</span><span class=\"token punctuation\">]</span>,\n          <span class=\"token string\">\"dir\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"'\"</span>$BACKUP_PATH<span class=\"token string\">\"'\"</span>\n      <span class=\"token punctuation\">&#125;</span>'<span class=\"token variable\">)</span></span>\n    <span class=\"token assign-left variable\">delete_code</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$delete_response</span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'.code'</span><span class=\"token variable\">)</span></span>\n    <span class=\"token assign-left variable\">delete_message</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$delete_response</span>\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'.message'</span><span class=\"token variable\">)</span></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$delete_code</span>\"</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">200</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n      log <span class=\"token string\">\"Successfully deleted <span class=\"token variable\">$file</span>\"</span>\n    <span class=\"token keyword\">else</span>\n      log <span class=\"token string\">\"Failed to delete <span class=\"token variable\">$file</span>: <span class=\"token variable\">$delete_message</span>\"</span>\n    <span class=\"token keyword\">fi</span>\n  <span class=\"token keyword\">done</span>\n<span class=\"token keyword\">else</span>\n  log <span class=\"token string\">\"No files older than 15 day to delete.\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>请将脚本中的 <code>API_URL</code> 和 <code>BACKUP_PATH</code> 替换为你自己的 Alist 地址和存储路径。</p>\n<p>保存并退出编辑器（在 vim 中按 <code>Esc</code>，然后输入 <code>:x</code> 回车保存）。</p>\n<h3 id=\"详细解释\"><a class=\"headerlink\" href=\"#详细解释\"></a>详细解释</h3>\n<ol>\n<li><strong>设置日志文件</strong>：日志文件名为 <code>clean_back_YYYYMMDDHHMMSS.log</code>，存储在 <code>/opt/alist/log</code> 目录中，记录脚本执行过程中的所有重要信息。</li>\n<li><strong>定义 <code>log</code> 函数</strong>：这个函数为日志信息添加时间戳，并将日志信息同时输出到控制台和日志文件中。</li>\n<li><strong>配置 API 参数</strong>：设置 API 的基础 URL、列出文件的端点和删除文件的端点，以及授权令牌和备份路径。</li>\n<li><strong>获取当前时间戳</strong>：使用 <code>date +%s</code> 获取当前时间的 Unix 时间戳（以秒为单位）。</li>\n<li><strong>列出备份目录中的文件</strong>：通过 Alist 提供的 <code>POST /api/fs/list</code> 接口获取备份目录中的文件列表，并使用 <code>jq</code> 提取文件名和创建日期。</li>\n<li><strong>计算文件年龄并判断是否需要删除</strong>：遍历文件列表，计算每个文件的年龄（以天为单位），如果文件超过30天，则将其添加到删除列表中。</li>\n<li><strong>输出将要删除的文件列表</strong>：记录需要删除的文件以供调试。</li>\n<li><strong>删除过期文件</strong>：通过 Alist 提供的 <code>POST /api/fs/remove</code> 接口删除超过30天的文件，并根据响应结果记录删除操作的状态。</li>\n</ol>\n<h3 id=\"运行脚本\"><a class=\"headerlink\" href=\"#运行脚本\"></a>运行脚本</h3>\n<p>将上述脚本保存为 <code>clean_backups.sh</code>，然后给脚本添加执行权限并运行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x clean_backups.sh\n./clean_backups.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"定时任务\"><a class=\"headerlink\" href=\"#定时任务\"></a>定时任务</h3>\n<p>为了让脚本定期运行，可以使用 <code>cron</code> 设置定时任务。例如，每天凌晨 2点运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">crontab</span> <span class=\"token parameter variable\">-e</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在 <code>crontab</code> 编辑器中添加以下行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">0</span> <span class=\"token number\">2</span> * * * /opt/alist/clean_backups.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>保存并退出编辑器（在 vim 中按 <code>Esc</code>，然后输入 <code>:x</code> 回车保存）。</p>\n<p>通过这种方式，您可以自动化清理过期的备份文件，并将操作结果记录到日志文件中，方便日后查看和调试。定期清理备份文件有助于保持系统的整洁，确保服务器的高效运行。</p>\n<hr>\n<p>以上就是使用 Alist 和 Bash 脚本实现自动化清理备份文件的完整方法。希望这篇博客对您有所帮助！如果有任何问题或建议，欢迎在评论区留言讨论。</p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"服务器安全设置","date":"2024-06-24T11:14:28.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E8%A7%86%E9%A2%91%E6%B8%B8%E6%88%8F%E3%80%912024-06-25%2013_35_25.png","_content":"\n### 1. 更新系统\n\n首先，确保你的系统和所有安装的软件都是最新的。这不仅可以帮助你利用最新的功能，还可以修复已知的安全漏洞。使用以下命令进行更新：\n\n```bash\nsudo apt update && sudo apt upgrade\n```\n\n### 2. 安装防火墙\n\nUbuntu默认带有`ufw`（Uncomplicated Firewall）工具，它是一个对于初学者非常友好的防火墙管理工具。要启用并配置它，请执行以下步骤：\n\n启用`ufw`：\n\n```bash\nsudo ufw enable\n```\n\n接下来，开放必要的端口。例如，对于SSH服务：\n\n```bash\nsudo ufw allow 22\n```\n\n如果你运行了Web服务器，你可能还需要开放HTTP和HTTPS端口：\n\n```bash\nsudo ufw allow 80\nsudo ufw allow 443\n```\n\n### 3. 配置SSH\n\nSSH是远程管理Linux服务器的标准方法。为了增强安全性，推荐使用SSH密钥对进行身份验证，而不是密码。\n\n#### 生成SSH密钥对\n\n在客户端机器上，运行以下命令生成SSH密钥对：\n\n```bash\nssh-keygen -t rsa -b 4096\n```\n\n#### 将公钥添加到服务器\n\n使用`ssh-copy-id`命令将公钥复制到服务器上：\n\n```bash\nssh-copy-id -i ~/.ssh/id_rsa.pub 用户名@服务器IP\n```\n\n#### 禁用密码认证\n\n编辑服务器上的`/etc/ssh/sshd_config`文件，设置以下内容：\n\n```bash\nPasswordAuthentication no\n```\n\n然后重启SSH服务以应用更改：\n\n```bash\nsudo systemctl restart sshd\n```\n\n### 4. 配置Fail2Ban\n\nFail2Ban可以帮助保护服务器免受暴力破解攻击。它通过监控日志文件中的失败登录尝试来工作，并封锁显示恶意行为的IP地址。\n\n#### 安装Fail2Ban\n\n```bash\nsudo apt install fail2ban\n```\n\n#### 配置基本保护\n\n创建或编辑`/etc/fail2ban/jail.local`文件，为SSH服务添加基本保护：\n\n```ini\n[DEFAULT]\n# 全局设置\nbantime = 1h        # 封禁时间：1小时\nfindtime = 10m      # 在此时间内连续失败的尝试视为攻击\nmaxretry = 5        # 允许失败次数\nignoreip = 127.0.0.1/8 # 忽略本地IP地址的封禁\n\n# 指定要使用的日志文件\nbackend = auto      # 自动确定日志文件类型\nusedns = warn       # 使用DNS解析\nlogencoding = auto  # 日志文件的编码\nenabled = false     # 默认不启用任何规则\n\n# SSH 服务\n[sshd]\nenabled = true\nport = ssh\nfilter = sshd\nlogpath = /var/log/auth.log\nmaxretry = 3\nfindtime = 5m\n```\n\n重启Fail2Ban服务以应用配置：\n\n```bash\nsudo systemctl restart fail2ban\nsudo systemctl enable fail2ban\n```\n\n---\n\n通过上述步骤，你的服务器将具备较强的基本安全保护。务必定期检查和更新你的系统及应用程序，保持警惕，适时应对新的安全威胁。\n","source":"_posts/服务器安全设置.md","raw":"---\ntitle: 服务器安全设置\ndate: 2024-06-24 19:14:28\ntags: Linux\ncategories: Linux\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E8%A7%86%E9%A2%91%E6%B8%B8%E6%88%8F%E3%80%912024-06-25%2013_35_25.png\n---\n\n### 1. 更新系统\n\n首先，确保你的系统和所有安装的软件都是最新的。这不仅可以帮助你利用最新的功能，还可以修复已知的安全漏洞。使用以下命令进行更新：\n\n```bash\nsudo apt update && sudo apt upgrade\n```\n\n### 2. 安装防火墙\n\nUbuntu默认带有`ufw`（Uncomplicated Firewall）工具，它是一个对于初学者非常友好的防火墙管理工具。要启用并配置它，请执行以下步骤：\n\n启用`ufw`：\n\n```bash\nsudo ufw enable\n```\n\n接下来，开放必要的端口。例如，对于SSH服务：\n\n```bash\nsudo ufw allow 22\n```\n\n如果你运行了Web服务器，你可能还需要开放HTTP和HTTPS端口：\n\n```bash\nsudo ufw allow 80\nsudo ufw allow 443\n```\n\n### 3. 配置SSH\n\nSSH是远程管理Linux服务器的标准方法。为了增强安全性，推荐使用SSH密钥对进行身份验证，而不是密码。\n\n#### 生成SSH密钥对\n\n在客户端机器上，运行以下命令生成SSH密钥对：\n\n```bash\nssh-keygen -t rsa -b 4096\n```\n\n#### 将公钥添加到服务器\n\n使用`ssh-copy-id`命令将公钥复制到服务器上：\n\n```bash\nssh-copy-id -i ~/.ssh/id_rsa.pub 用户名@服务器IP\n```\n\n#### 禁用密码认证\n\n编辑服务器上的`/etc/ssh/sshd_config`文件，设置以下内容：\n\n```bash\nPasswordAuthentication no\n```\n\n然后重启SSH服务以应用更改：\n\n```bash\nsudo systemctl restart sshd\n```\n\n### 4. 配置Fail2Ban\n\nFail2Ban可以帮助保护服务器免受暴力破解攻击。它通过监控日志文件中的失败登录尝试来工作，并封锁显示恶意行为的IP地址。\n\n#### 安装Fail2Ban\n\n```bash\nsudo apt install fail2ban\n```\n\n#### 配置基本保护\n\n创建或编辑`/etc/fail2ban/jail.local`文件，为SSH服务添加基本保护：\n\n```ini\n[DEFAULT]\n# 全局设置\nbantime = 1h        # 封禁时间：1小时\nfindtime = 10m      # 在此时间内连续失败的尝试视为攻击\nmaxretry = 5        # 允许失败次数\nignoreip = 127.0.0.1/8 # 忽略本地IP地址的封禁\n\n# 指定要使用的日志文件\nbackend = auto      # 自动确定日志文件类型\nusedns = warn       # 使用DNS解析\nlogencoding = auto  # 日志文件的编码\nenabled = false     # 默认不启用任何规则\n\n# SSH 服务\n[sshd]\nenabled = true\nport = ssh\nfilter = sshd\nlogpath = /var/log/auth.log\nmaxretry = 3\nfindtime = 5m\n```\n\n重启Fail2Ban服务以应用配置：\n\n```bash\nsudo systemctl restart fail2ban\nsudo systemctl enable fail2ban\n```\n\n---\n\n通过上述步骤，你的服务器将具备较强的基本安全保护。务必定期检查和更新你的系统及应用程序，保持警惕，适时应对新的安全威胁。\n","slug":"服务器安全设置","published":1,"updated":"2024-07-11T10:28:07.835Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2gz0015tuj8a9okgg1a","content":"<h3 id=\"1-更新系统\"><a class=\"headerlink\" href=\"#1-更新系统\"></a>1. 更新系统</h3>\n<p>首先，确保你的系统和所有安装的软件都是最新的。这不仅可以帮助你利用最新的功能，还可以修复已知的安全漏洞。使用以下命令进行更新：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> upgrade<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"2-安装防火墙\"><a class=\"headerlink\" href=\"#2-安装防火墙\"></a>2. 安装防火墙</h3>\n<p>Ubuntu默认带有<code>ufw</code>（Uncomplicated Firewall）工具，它是一个对于初学者非常友好的防火墙管理工具。要启用并配置它，请执行以下步骤：</p>\n<p>启用<code>ufw</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw <span class=\"token builtin class-name\">enable</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>接下来，开放必要的端口。例如，对于SSH服务：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">22</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果你运行了Web服务器，你可能还需要开放HTTP和HTTPS端口：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">80</span>\n<span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">443</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"3-配置SSH\"><a class=\"headerlink\" href=\"#3-配置SSH\"></a>3. 配置SSH</h3>\n<p>SSH是远程管理Linux服务器的标准方法。为了增强安全性，推荐使用SSH密钥对进行身份验证，而不是密码。</p>\n<h4 id=\"生成SSH密钥对\"><a class=\"headerlink\" href=\"#生成SSH密钥对\"></a>生成SSH密钥对</h4>\n<p>在客户端机器上，运行以下命令生成SSH密钥对：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ssh-keygen <span class=\"token parameter variable\">-t</span> rsa <span class=\"token parameter variable\">-b</span> <span class=\"token number\">4096</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"将公钥添加到服务器\"><a class=\"headerlink\" href=\"#将公钥添加到服务器\"></a>将公钥添加到服务器</h4>\n<p>使用<code>ssh-copy-id</code>命令将公钥复制到服务器上：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ssh-copy-id <span class=\"token parameter variable\">-i</span> ~/.ssh/id_rsa.pub 用户名@服务器IP<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"禁用密码认证\"><a class=\"headerlink\" href=\"#禁用密码认证\"></a>禁用密码认证</h4>\n<p>编辑服务器上的<code>/etc/ssh/sshd_config</code>文件，设置以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">PasswordAuthentication no<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后重启SSH服务以应用更改：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart sshd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"4-配置Fail2Ban\"><a class=\"headerlink\" href=\"#4-配置Fail2Ban\"></a>4. 配置Fail2Ban</h3>\n<p>Fail2Ban可以帮助保护服务器免受暴力破解攻击。它通过监控日志文件中的失败登录尝试来工作，并封锁显示恶意行为的IP地址。</p>\n<h4 id=\"安装Fail2Ban\"><a class=\"headerlink\" href=\"#安装Fail2Ban\"></a>安装Fail2Ban</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> fail2ban<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"配置基本保护\"><a class=\"headerlink\" href=\"#配置基本保护\"></a>配置基本保护</h4>\n<p>创建或编辑<code>/etc/fail2ban/jail.local</code>文件，为SSH服务添加基本保护：</p>\n<pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">DEFAULT</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token comment\"># 全局设置</span>\n<span class=\"token key attr-name\">bantime</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">1h        # 封禁时间：1小时</span>\n<span class=\"token key attr-name\">findtime</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">10m      # 在此时间内连续失败的尝试视为攻击</span>\n<span class=\"token key attr-name\">maxretry</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">5        # 允许失败次数</span>\n<span class=\"token key attr-name\">ignoreip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1/8 # 忽略本地IP地址的封禁</span>\n\n<span class=\"token comment\"># 指定要使用的日志文件</span>\n<span class=\"token key attr-name\">backend</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">auto      # 自动确定日志文件类型</span>\n<span class=\"token key attr-name\">usedns</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">warn       # 使用DNS解析</span>\n<span class=\"token key attr-name\">logencoding</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">auto  # 日志文件的编码</span>\n<span class=\"token key attr-name\">enabled</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">false     # 默认不启用任何规则</span>\n\n<span class=\"token comment\"># SSH 服务</span>\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">sshd</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">enabled</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">true</span>\n<span class=\"token key attr-name\">port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">ssh</span>\n<span class=\"token key attr-name\">filter</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">sshd</span>\n<span class=\"token key attr-name\">logpath</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">/var/log/auth.log</span>\n<span class=\"token key attr-name\">maxretry</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">3</span>\n<span class=\"token key attr-name\">findtime</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">5m</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>重启Fail2Ban服务以应用配置：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart fail2ban\n<span class=\"token function\">sudo</span> systemctl <span class=\"token builtin class-name\">enable</span> fail2ban<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<hr>\n<p>通过上述步骤，你的服务器将具备较强的基本安全保护。务必定期检查和更新你的系统及应用程序，保持警惕，适时应对新的安全威胁。</p>\n","excerpt":"","more":"<h3 id=\"1-更新系统\"><a class=\"headerlink\" href=\"#1-更新系统\"></a>1. 更新系统</h3>\n<p>首先，确保你的系统和所有安装的软件都是最新的。这不仅可以帮助你利用最新的功能，还可以修复已知的安全漏洞。使用以下命令进行更新：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> upgrade<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"2-安装防火墙\"><a class=\"headerlink\" href=\"#2-安装防火墙\"></a>2. 安装防火墙</h3>\n<p>Ubuntu默认带有<code>ufw</code>（Uncomplicated Firewall）工具，它是一个对于初学者非常友好的防火墙管理工具。要启用并配置它，请执行以下步骤：</p>\n<p>启用<code>ufw</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw <span class=\"token builtin class-name\">enable</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>接下来，开放必要的端口。例如，对于SSH服务：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">22</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果你运行了Web服务器，你可能还需要开放HTTP和HTTPS端口：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">80</span>\n<span class=\"token function\">sudo</span> ufw allow <span class=\"token number\">443</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"3-配置SSH\"><a class=\"headerlink\" href=\"#3-配置SSH\"></a>3. 配置SSH</h3>\n<p>SSH是远程管理Linux服务器的标准方法。为了增强安全性，推荐使用SSH密钥对进行身份验证，而不是密码。</p>\n<h4 id=\"生成SSH密钥对\"><a class=\"headerlink\" href=\"#生成SSH密钥对\"></a>生成SSH密钥对</h4>\n<p>在客户端机器上，运行以下命令生成SSH密钥对：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ssh-keygen <span class=\"token parameter variable\">-t</span> rsa <span class=\"token parameter variable\">-b</span> <span class=\"token number\">4096</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"将公钥添加到服务器\"><a class=\"headerlink\" href=\"#将公钥添加到服务器\"></a>将公钥添加到服务器</h4>\n<p>使用<code>ssh-copy-id</code>命令将公钥复制到服务器上：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ssh-copy-id <span class=\"token parameter variable\">-i</span> ~/.ssh/id_rsa.pub 用户名@服务器IP<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"禁用密码认证\"><a class=\"headerlink\" href=\"#禁用密码认证\"></a>禁用密码认证</h4>\n<p>编辑服务器上的<code>/etc/ssh/sshd_config</code>文件，设置以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">PasswordAuthentication no<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后重启SSH服务以应用更改：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart sshd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"4-配置Fail2Ban\"><a class=\"headerlink\" href=\"#4-配置Fail2Ban\"></a>4. 配置Fail2Ban</h3>\n<p>Fail2Ban可以帮助保护服务器免受暴力破解攻击。它通过监控日志文件中的失败登录尝试来工作，并封锁显示恶意行为的IP地址。</p>\n<h4 id=\"安装Fail2Ban\"><a class=\"headerlink\" href=\"#安装Fail2Ban\"></a>安装Fail2Ban</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> fail2ban<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"配置基本保护\"><a class=\"headerlink\" href=\"#配置基本保护\"></a>配置基本保护</h4>\n<p>创建或编辑<code>/etc/fail2ban/jail.local</code>文件，为SSH服务添加基本保护：</p>\n<pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">DEFAULT</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token comment\"># 全局设置</span>\n<span class=\"token key attr-name\">bantime</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">1h        # 封禁时间：1小时</span>\n<span class=\"token key attr-name\">findtime</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">10m      # 在此时间内连续失败的尝试视为攻击</span>\n<span class=\"token key attr-name\">maxretry</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">5        # 允许失败次数</span>\n<span class=\"token key attr-name\">ignoreip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1/8 # 忽略本地IP地址的封禁</span>\n\n<span class=\"token comment\"># 指定要使用的日志文件</span>\n<span class=\"token key attr-name\">backend</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">auto      # 自动确定日志文件类型</span>\n<span class=\"token key attr-name\">usedns</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">warn       # 使用DNS解析</span>\n<span class=\"token key attr-name\">logencoding</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">auto  # 日志文件的编码</span>\n<span class=\"token key attr-name\">enabled</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">false     # 默认不启用任何规则</span>\n\n<span class=\"token comment\"># SSH 服务</span>\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">sshd</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">enabled</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">true</span>\n<span class=\"token key attr-name\">port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">ssh</span>\n<span class=\"token key attr-name\">filter</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">sshd</span>\n<span class=\"token key attr-name\">logpath</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">/var/log/auth.log</span>\n<span class=\"token key attr-name\">maxretry</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">3</span>\n<span class=\"token key attr-name\">findtime</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">5m</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>重启Fail2Ban服务以应用配置：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart fail2ban\n<span class=\"token function\">sudo</span> systemctl <span class=\"token builtin class-name\">enable</span> fail2ban<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<hr>\n<p>通过上述步骤，你的服务器将具备较强的基本安全保护。务必定期检查和更新你的系统及应用程序，保持警惕，适时应对新的安全威胁。</p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"_content":"### Java基础与面向对象思想\n\n**问题1：请解释一下面向对象编程的四大基本原则。**\n**回答思路**：\n- **封装**：将对象的状态信息隐藏在对象内部，通过提供公共方法来访问和修改这些信息。\n- **继承**：通过继承可以创建新的类，这些新类可以重用现有类的属性和方法，形成类的层次结构。\n- **多态**：对象能够以多种形式呈现，允许子类实例化为父类引用，且方法调用在运行时决定。\n- **抽象**：通过抽象类和接口定义对象的基本结构，而不具体实现，实现了高层次的代码复用和模块化。\n\n**问题2：请解释一下Java中的异常处理机制。**\n**回答思路**：\n- Java中的异常分为受检查异常和运行时异常。受检查异常需要在编译时处理，运行时异常不需要。\n- 使用try-catch块捕获异常，并通过throw关键字抛出异常。\n- finally块用于执行清理代码，无论是否发生异常都会执行。\n- 自定义异常类可以扩展Exception或RuntimeException类。\n\n### MySQL\n\n**问题3：MySQL中的索引有哪些类型？它们的优缺点是什么？** **回答思路**：\n\n- B-Tree索引：\n  - **优点**：适用于大多数查询，支持范围查询、排序和去重。\n  - **缺点**：对于频繁更新的列，维护成本较高。\n- 哈希索引：\n  - **优点**：查找速度非常快，适用于精确匹配查询。\n  - **缺点**：不支持范围查询和排序，哈希冲突会降低性能。\n- 全文索引：\n  - **优点**：用于全文搜索，适合大文本字段的关键词查询。\n  - **缺点**：建立和维护成本高，不适合实时更新的数据。\n- 空间索引（R-Tree索引）：\n  - **优点**：适用于地理信息系统中的空间查询。\n  - **缺点**：不适合用于其他类型的数据。\n\n\n\n**问题2：如何选择和优化索引？** **回答思路**：\n\n- **选择合适的列**：为经常出现在WHERE子句、JOIN子句和ORDER BY子句中的列创建索引。\n- **覆盖索引**：选择合适的列组合，创建能够覆盖查询需求的复合索引，减少查询过程中回表的次数。\n- **避免冗余索引**：合理设计索引，避免重复和冗余索引，减少索引维护成本。\n- **定期维护**：定期重建和优化索引，以确保索引的有效性和性能。\n\n### Redis\n\n**问题5：请解释一下Redis的持久化机制。**\n**回答思路**：\n- Redis提供两种持久化机制：RDB（快照）和AOF（追加文件）。\n- RDB通过创建内存数据的快照保存到磁盘中，适用于灾难恢复。\n- AOF记录每一个写操作日志，重启时可以通过重放日志恢复数据。\n- 可以同时使用RDB和AOF以获得更高的可靠性。\n\n**问题6：什么是缓存穿透、缓存雪崩和缓存击穿？如何解决这些问题？**\n**回答思路**：\n- **缓存穿透**：查询一个在缓存和数据库中都不存在的数据。解决方法包括使用布隆过滤器或缓存空值。\n- **缓存雪崩**：缓存服务器宕机或大批量缓存同时失效，导致数据库压力剧增。解决方法包括缓存数据过期时间随机化、双缓存和多级缓存。\n- **缓存击穿**：缓存中某个热点数据失效，导致大量请求同时访问数据库。解决方法包括使用互斥锁或设置热点数据永不过期。\n\n### Spring框架\n\n**问题7：请解释一下Spring IOC和AOP的概念。**\n**回答思路**：\n- **IOC（控制反转）**：通过依赖注入（DI）来管理对象的生命周期和依赖关系，避免了对象之间的紧耦合。\n- **AOP（面向切面编程）**：通过定义切面和切点，增强方法的功能，如事务管理、日志记录和安全检查。\n\n**问题8：请解释一下SpringMVC的执行流程。**\n**回答思路**：\n- 前端请求通过DispatcherServlet接收。\n- DispatcherServlet将请求转发给HandlerMapping，找到具体的Controller。\n- Controller处理请求并返回ModelAndView。\n- ViewResolver解析视图，最终将视图返回给用户。\n\n### RabbitMQ\n\n**问题9：请解释一下RabbitMQ的基本工作模型。**\n**回答思路**：\n- RabbitMQ使用生产者-消费者模型，通过交换机将消息路由到相应的队列。\n- 生产者将消息发送到交换机，交换机根据绑定规则将消息发送到一个或多个队列。\n- 消费者从队列中消费消息，进行相应的处理。\n\n**问题10：什么是死信交换机？它是如何工作的？**\n**回答思路**：\n- 死信交换机用于处理无法被正常消费的消息，这些消息被称为死信。\n- 产生死信的原因包括消息过期、队列长度限制或消息被拒绝。\n- 死信会被路由到一个预先配置好的死信交换机，从而进行特殊处理。\n\n### 开发工具\n\n**问题11：你是如何使用Docker的？有哪些常见的使用场景？**\n**回答思路**：\n- Docker用于创建、部署和管理容器化应用，可以确保应用在不同环境中的一致性。\n- 常见使用场景包括本地开发环境的搭建、持续集成和部署（CI/CD）以及微服务架构的实现。\n\n**问题12：你是如何使用Git进行版本控制的？**\n**回答思路**：\n- Git用于代码版本控制，通过创建仓库来管理代码的提交、合并和回滚。\n- 常用的Git操作包括克隆仓库、创建分支、提交代码、合并分支和解决冲突。\n\n### 总结\n\n通过这些问题和回答，你可以展示你对各项技术的深刻理解和实际应用经验。在回答过程中，尽量结合具体的项目实例和实践经验，展示你的实际操作能力和问题解决能力。","source":"_posts/混合.md","raw":"### Java基础与面向对象思想\n\n**问题1：请解释一下面向对象编程的四大基本原则。**\n**回答思路**：\n- **封装**：将对象的状态信息隐藏在对象内部，通过提供公共方法来访问和修改这些信息。\n- **继承**：通过继承可以创建新的类，这些新类可以重用现有类的属性和方法，形成类的层次结构。\n- **多态**：对象能够以多种形式呈现，允许子类实例化为父类引用，且方法调用在运行时决定。\n- **抽象**：通过抽象类和接口定义对象的基本结构，而不具体实现，实现了高层次的代码复用和模块化。\n\n**问题2：请解释一下Java中的异常处理机制。**\n**回答思路**：\n- Java中的异常分为受检查异常和运行时异常。受检查异常需要在编译时处理，运行时异常不需要。\n- 使用try-catch块捕获异常，并通过throw关键字抛出异常。\n- finally块用于执行清理代码，无论是否发生异常都会执行。\n- 自定义异常类可以扩展Exception或RuntimeException类。\n\n### MySQL\n\n**问题3：MySQL中的索引有哪些类型？它们的优缺点是什么？** **回答思路**：\n\n- B-Tree索引：\n  - **优点**：适用于大多数查询，支持范围查询、排序和去重。\n  - **缺点**：对于频繁更新的列，维护成本较高。\n- 哈希索引：\n  - **优点**：查找速度非常快，适用于精确匹配查询。\n  - **缺点**：不支持范围查询和排序，哈希冲突会降低性能。\n- 全文索引：\n  - **优点**：用于全文搜索，适合大文本字段的关键词查询。\n  - **缺点**：建立和维护成本高，不适合实时更新的数据。\n- 空间索引（R-Tree索引）：\n  - **优点**：适用于地理信息系统中的空间查询。\n  - **缺点**：不适合用于其他类型的数据。\n\n\n\n**问题2：如何选择和优化索引？** **回答思路**：\n\n- **选择合适的列**：为经常出现在WHERE子句、JOIN子句和ORDER BY子句中的列创建索引。\n- **覆盖索引**：选择合适的列组合，创建能够覆盖查询需求的复合索引，减少查询过程中回表的次数。\n- **避免冗余索引**：合理设计索引，避免重复和冗余索引，减少索引维护成本。\n- **定期维护**：定期重建和优化索引，以确保索引的有效性和性能。\n\n### Redis\n\n**问题5：请解释一下Redis的持久化机制。**\n**回答思路**：\n- Redis提供两种持久化机制：RDB（快照）和AOF（追加文件）。\n- RDB通过创建内存数据的快照保存到磁盘中，适用于灾难恢复。\n- AOF记录每一个写操作日志，重启时可以通过重放日志恢复数据。\n- 可以同时使用RDB和AOF以获得更高的可靠性。\n\n**问题6：什么是缓存穿透、缓存雪崩和缓存击穿？如何解决这些问题？**\n**回答思路**：\n- **缓存穿透**：查询一个在缓存和数据库中都不存在的数据。解决方法包括使用布隆过滤器或缓存空值。\n- **缓存雪崩**：缓存服务器宕机或大批量缓存同时失效，导致数据库压力剧增。解决方法包括缓存数据过期时间随机化、双缓存和多级缓存。\n- **缓存击穿**：缓存中某个热点数据失效，导致大量请求同时访问数据库。解决方法包括使用互斥锁或设置热点数据永不过期。\n\n### Spring框架\n\n**问题7：请解释一下Spring IOC和AOP的概念。**\n**回答思路**：\n- **IOC（控制反转）**：通过依赖注入（DI）来管理对象的生命周期和依赖关系，避免了对象之间的紧耦合。\n- **AOP（面向切面编程）**：通过定义切面和切点，增强方法的功能，如事务管理、日志记录和安全检查。\n\n**问题8：请解释一下SpringMVC的执行流程。**\n**回答思路**：\n- 前端请求通过DispatcherServlet接收。\n- DispatcherServlet将请求转发给HandlerMapping，找到具体的Controller。\n- Controller处理请求并返回ModelAndView。\n- ViewResolver解析视图，最终将视图返回给用户。\n\n### RabbitMQ\n\n**问题9：请解释一下RabbitMQ的基本工作模型。**\n**回答思路**：\n- RabbitMQ使用生产者-消费者模型，通过交换机将消息路由到相应的队列。\n- 生产者将消息发送到交换机，交换机根据绑定规则将消息发送到一个或多个队列。\n- 消费者从队列中消费消息，进行相应的处理。\n\n**问题10：什么是死信交换机？它是如何工作的？**\n**回答思路**：\n- 死信交换机用于处理无法被正常消费的消息，这些消息被称为死信。\n- 产生死信的原因包括消息过期、队列长度限制或消息被拒绝。\n- 死信会被路由到一个预先配置好的死信交换机，从而进行特殊处理。\n\n### 开发工具\n\n**问题11：你是如何使用Docker的？有哪些常见的使用场景？**\n**回答思路**：\n- Docker用于创建、部署和管理容器化应用，可以确保应用在不同环境中的一致性。\n- 常见使用场景包括本地开发环境的搭建、持续集成和部署（CI/CD）以及微服务架构的实现。\n\n**问题12：你是如何使用Git进行版本控制的？**\n**回答思路**：\n- Git用于代码版本控制，通过创建仓库来管理代码的提交、合并和回滚。\n- 常用的Git操作包括克隆仓库、创建分支、提交代码、合并分支和解决冲突。\n\n### 总结\n\n通过这些问题和回答，你可以展示你对各项技术的深刻理解和实际应用经验。在回答过程中，尽量结合具体的项目实例和实践经验，展示你的实际操作能力和问题解决能力。","slug":"混合","published":1,"date":"2024-07-08T05:10:04.047Z","updated":"2024-07-08T05:14:35.719Z","title":"Untitled","comments":1,"layout":"post","photos":[],"_id":"clyh4m2h00019tuj82ncke8xu","content":"<h3 id=\"Java基础与面向对象思想\"><a class=\"headerlink\" href=\"#Java基础与面向对象思想\"></a>Java基础与面向对象思想</h3>\n<p><strong>问题1：请解释一下面向对象编程的四大基本原则。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li><strong>封装</strong>：将对象的状态信息隐藏在对象内部，通过提供公共方法来访问和修改这些信息。</li>\n<li><strong>继承</strong>：通过继承可以创建新的类，这些新类可以重用现有类的属性和方法，形成类的层次结构。</li>\n<li><strong>多态</strong>：对象能够以多种形式呈现，允许子类实例化为父类引用，且方法调用在运行时决定。</li>\n<li><strong>抽象</strong>：通过抽象类和接口定义对象的基本结构，而不具体实现，实现了高层次的代码复用和模块化。</li>\n</ul>\n<p><strong>问题2：请解释一下Java中的异常处理机制。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Java中的异常分为受检查异常和运行时异常。受检查异常需要在编译时处理，运行时异常不需要。</li>\n<li>使用try-catch块捕获异常，并通过throw关键字抛出异常。</li>\n<li>finally块用于执行清理代码，无论是否发生异常都会执行。</li>\n<li>自定义异常类可以扩展Exception或RuntimeException类。</li>\n</ul>\n<h3 id=\"MySQL\"><a class=\"headerlink\" href=\"#MySQL\"></a>MySQL</h3>\n<p><strong>问题3：MySQL中的索引有哪些类型？它们的优缺点是什么？</strong> <strong>回答思路</strong>：</p>\n<ul>\n<li>B-Tree索引：\n<ul>\n<li><strong>优点</strong>：适用于大多数查询，支持范围查询、排序和去重。</li>\n<li><strong>缺点</strong>：对于频繁更新的列，维护成本较高。</li>\n</ul>\n</li>\n<li>哈希索引：\n<ul>\n<li><strong>优点</strong>：查找速度非常快，适用于精确匹配查询。</li>\n<li><strong>缺点</strong>：不支持范围查询和排序，哈希冲突会降低性能。</li>\n</ul>\n</li>\n<li>全文索引：\n<ul>\n<li><strong>优点</strong>：用于全文搜索，适合大文本字段的关键词查询。</li>\n<li><strong>缺点</strong>：建立和维护成本高，不适合实时更新的数据。</li>\n</ul>\n</li>\n<li>空间索引（R-Tree索引）：\n<ul>\n<li><strong>优点</strong>：适用于地理信息系统中的空间查询。</li>\n<li><strong>缺点</strong>：不适合用于其他类型的数据。</li>\n</ul>\n</li>\n</ul>\n<p><strong>问题2：如何选择和优化索引？</strong> <strong>回答思路</strong>：</p>\n<ul>\n<li><strong>选择合适的列</strong>：为经常出现在WHERE子句、JOIN子句和ORDER BY子句中的列创建索引。</li>\n<li><strong>覆盖索引</strong>：选择合适的列组合，创建能够覆盖查询需求的复合索引，减少查询过程中回表的次数。</li>\n<li><strong>避免冗余索引</strong>：合理设计索引，避免重复和冗余索引，减少索引维护成本。</li>\n<li><strong>定期维护</strong>：定期重建和优化索引，以确保索引的有效性和性能。</li>\n</ul>\n<h3 id=\"Redis\"><a class=\"headerlink\" href=\"#Redis\"></a>Redis</h3>\n<p><strong>问题5：请解释一下Redis的持久化机制。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Redis提供两种持久化机制：RDB（快照）和AOF（追加文件）。</li>\n<li>RDB通过创建内存数据的快照保存到磁盘中，适用于灾难恢复。</li>\n<li>AOF记录每一个写操作日志，重启时可以通过重放日志恢复数据。</li>\n<li>可以同时使用RDB和AOF以获得更高的可靠性。</li>\n</ul>\n<p><strong>问题6：什么是缓存穿透、缓存雪崩和缓存击穿？如何解决这些问题？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li><strong>缓存穿透</strong>：查询一个在缓存和数据库中都不存在的数据。解决方法包括使用布隆过滤器或缓存空值。</li>\n<li><strong>缓存雪崩</strong>：缓存服务器宕机或大批量缓存同时失效，导致数据库压力剧增。解决方法包括缓存数据过期时间随机化、双缓存和多级缓存。</li>\n<li><strong>缓存击穿</strong>：缓存中某个热点数据失效，导致大量请求同时访问数据库。解决方法包括使用互斥锁或设置热点数据永不过期。</li>\n</ul>\n<h3 id=\"Spring框架\"><a class=\"headerlink\" href=\"#Spring框架\"></a>Spring框架</h3>\n<p><strong>问题7：请解释一下Spring IOC和AOP的概念。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li><strong>IOC（控制反转）</strong>：通过依赖注入（DI）来管理对象的生命周期和依赖关系，避免了对象之间的紧耦合。</li>\n<li><strong>AOP（面向切面编程）</strong>：通过定义切面和切点，增强方法的功能，如事务管理、日志记录和安全检查。</li>\n</ul>\n<p><strong>问题8：请解释一下SpringMVC的执行流程。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>前端请求通过DispatcherServlet接收。</li>\n<li>DispatcherServlet将请求转发给HandlerMapping，找到具体的Controller。</li>\n<li>Controller处理请求并返回ModelAndView。</li>\n<li>ViewResolver解析视图，最终将视图返回给用户。</li>\n</ul>\n<h3 id=\"RabbitMQ\"><a class=\"headerlink\" href=\"#RabbitMQ\"></a>RabbitMQ</h3>\n<p><strong>问题9：请解释一下RabbitMQ的基本工作模型。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>RabbitMQ使用生产者-消费者模型，通过交换机将消息路由到相应的队列。</li>\n<li>生产者将消息发送到交换机，交换机根据绑定规则将消息发送到一个或多个队列。</li>\n<li>消费者从队列中消费消息，进行相应的处理。</li>\n</ul>\n<p><strong>问题10：什么是死信交换机？它是如何工作的？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>死信交换机用于处理无法被正常消费的消息，这些消息被称为死信。</li>\n<li>产生死信的原因包括消息过期、队列长度限制或消息被拒绝。</li>\n<li>死信会被路由到一个预先配置好的死信交换机，从而进行特殊处理。</li>\n</ul>\n<h3 id=\"开发工具\"><a class=\"headerlink\" href=\"#开发工具\"></a>开发工具</h3>\n<p><strong>问题11：你是如何使用Docker的？有哪些常见的使用场景？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Docker用于创建、部署和管理容器化应用，可以确保应用在不同环境中的一致性。</li>\n<li>常见使用场景包括本地开发环境的搭建、持续集成和部署（CI/CD）以及微服务架构的实现。</li>\n</ul>\n<p><strong>问题12：你是如何使用Git进行版本控制的？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Git用于代码版本控制，通过创建仓库来管理代码的提交、合并和回滚。</li>\n<li>常用的Git操作包括克隆仓库、创建分支、提交代码、合并分支和解决冲突。</li>\n</ul>\n<h3 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h3>\n<p>通过这些问题和回答，你可以展示你对各项技术的深刻理解和实际应用经验。在回答过程中，尽量结合具体的项目实例和实践经验，展示你的实际操作能力和问题解决能力。</p>\n","excerpt":"","more":"<h3 id=\"Java基础与面向对象思想\"><a class=\"headerlink\" href=\"#Java基础与面向对象思想\"></a>Java基础与面向对象思想</h3>\n<p><strong>问题1：请解释一下面向对象编程的四大基本原则。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li><strong>封装</strong>：将对象的状态信息隐藏在对象内部，通过提供公共方法来访问和修改这些信息。</li>\n<li><strong>继承</strong>：通过继承可以创建新的类，这些新类可以重用现有类的属性和方法，形成类的层次结构。</li>\n<li><strong>多态</strong>：对象能够以多种形式呈现，允许子类实例化为父类引用，且方法调用在运行时决定。</li>\n<li><strong>抽象</strong>：通过抽象类和接口定义对象的基本结构，而不具体实现，实现了高层次的代码复用和模块化。</li>\n</ul>\n<p><strong>问题2：请解释一下Java中的异常处理机制。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Java中的异常分为受检查异常和运行时异常。受检查异常需要在编译时处理，运行时异常不需要。</li>\n<li>使用try-catch块捕获异常，并通过throw关键字抛出异常。</li>\n<li>finally块用于执行清理代码，无论是否发生异常都会执行。</li>\n<li>自定义异常类可以扩展Exception或RuntimeException类。</li>\n</ul>\n<h3 id=\"MySQL\"><a class=\"headerlink\" href=\"#MySQL\"></a>MySQL</h3>\n<p><strong>问题3：MySQL中的索引有哪些类型？它们的优缺点是什么？</strong> <strong>回答思路</strong>：</p>\n<ul>\n<li>B-Tree索引：\n<ul>\n<li><strong>优点</strong>：适用于大多数查询，支持范围查询、排序和去重。</li>\n<li><strong>缺点</strong>：对于频繁更新的列，维护成本较高。</li>\n</ul>\n</li>\n<li>哈希索引：\n<ul>\n<li><strong>优点</strong>：查找速度非常快，适用于精确匹配查询。</li>\n<li><strong>缺点</strong>：不支持范围查询和排序，哈希冲突会降低性能。</li>\n</ul>\n</li>\n<li>全文索引：\n<ul>\n<li><strong>优点</strong>：用于全文搜索，适合大文本字段的关键词查询。</li>\n<li><strong>缺点</strong>：建立和维护成本高，不适合实时更新的数据。</li>\n</ul>\n</li>\n<li>空间索引（R-Tree索引）：\n<ul>\n<li><strong>优点</strong>：适用于地理信息系统中的空间查询。</li>\n<li><strong>缺点</strong>：不适合用于其他类型的数据。</li>\n</ul>\n</li>\n</ul>\n<p><strong>问题2：如何选择和优化索引？</strong> <strong>回答思路</strong>：</p>\n<ul>\n<li><strong>选择合适的列</strong>：为经常出现在WHERE子句、JOIN子句和ORDER BY子句中的列创建索引。</li>\n<li><strong>覆盖索引</strong>：选择合适的列组合，创建能够覆盖查询需求的复合索引，减少查询过程中回表的次数。</li>\n<li><strong>避免冗余索引</strong>：合理设计索引，避免重复和冗余索引，减少索引维护成本。</li>\n<li><strong>定期维护</strong>：定期重建和优化索引，以确保索引的有效性和性能。</li>\n</ul>\n<h3 id=\"Redis\"><a class=\"headerlink\" href=\"#Redis\"></a>Redis</h3>\n<p><strong>问题5：请解释一下Redis的持久化机制。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Redis提供两种持久化机制：RDB（快照）和AOF（追加文件）。</li>\n<li>RDB通过创建内存数据的快照保存到磁盘中，适用于灾难恢复。</li>\n<li>AOF记录每一个写操作日志，重启时可以通过重放日志恢复数据。</li>\n<li>可以同时使用RDB和AOF以获得更高的可靠性。</li>\n</ul>\n<p><strong>问题6：什么是缓存穿透、缓存雪崩和缓存击穿？如何解决这些问题？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li><strong>缓存穿透</strong>：查询一个在缓存和数据库中都不存在的数据。解决方法包括使用布隆过滤器或缓存空值。</li>\n<li><strong>缓存雪崩</strong>：缓存服务器宕机或大批量缓存同时失效，导致数据库压力剧增。解决方法包括缓存数据过期时间随机化、双缓存和多级缓存。</li>\n<li><strong>缓存击穿</strong>：缓存中某个热点数据失效，导致大量请求同时访问数据库。解决方法包括使用互斥锁或设置热点数据永不过期。</li>\n</ul>\n<h3 id=\"Spring框架\"><a class=\"headerlink\" href=\"#Spring框架\"></a>Spring框架</h3>\n<p><strong>问题7：请解释一下Spring IOC和AOP的概念。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li><strong>IOC（控制反转）</strong>：通过依赖注入（DI）来管理对象的生命周期和依赖关系，避免了对象之间的紧耦合。</li>\n<li><strong>AOP（面向切面编程）</strong>：通过定义切面和切点，增强方法的功能，如事务管理、日志记录和安全检查。</li>\n</ul>\n<p><strong>问题8：请解释一下SpringMVC的执行流程。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>前端请求通过DispatcherServlet接收。</li>\n<li>DispatcherServlet将请求转发给HandlerMapping，找到具体的Controller。</li>\n<li>Controller处理请求并返回ModelAndView。</li>\n<li>ViewResolver解析视图，最终将视图返回给用户。</li>\n</ul>\n<h3 id=\"RabbitMQ\"><a class=\"headerlink\" href=\"#RabbitMQ\"></a>RabbitMQ</h3>\n<p><strong>问题9：请解释一下RabbitMQ的基本工作模型。</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>RabbitMQ使用生产者-消费者模型，通过交换机将消息路由到相应的队列。</li>\n<li>生产者将消息发送到交换机，交换机根据绑定规则将消息发送到一个或多个队列。</li>\n<li>消费者从队列中消费消息，进行相应的处理。</li>\n</ul>\n<p><strong>问题10：什么是死信交换机？它是如何工作的？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>死信交换机用于处理无法被正常消费的消息，这些消息被称为死信。</li>\n<li>产生死信的原因包括消息过期、队列长度限制或消息被拒绝。</li>\n<li>死信会被路由到一个预先配置好的死信交换机，从而进行特殊处理。</li>\n</ul>\n<h3 id=\"开发工具\"><a class=\"headerlink\" href=\"#开发工具\"></a>开发工具</h3>\n<p><strong>问题11：你是如何使用Docker的？有哪些常见的使用场景？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Docker用于创建、部署和管理容器化应用，可以确保应用在不同环境中的一致性。</li>\n<li>常见使用场景包括本地开发环境的搭建、持续集成和部署（CI/CD）以及微服务架构的实现。</li>\n</ul>\n<p><strong>问题12：你是如何使用Git进行版本控制的？</strong><br>\n<strong>回答思路</strong>：</p>\n<ul>\n<li>Git用于代码版本控制，通过创建仓库来管理代码的提交、合并和回滚。</li>\n<li>常用的Git操作包括克隆仓库、创建分支、提交代码、合并分支和解决冲突。</li>\n</ul>\n<h3 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h3>\n<p>通过这些问题和回答，你可以展示你对各项技术的深刻理解和实际应用经验。在回答过程中，尽量结合具体的项目实例和实践经验，展示你的实际操作能力和问题解决能力。</p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"cover":"/img/default.avif","toc":true,"ai":true,"comment":true},{"title":"自定义 Alfred iTerm 脚本","date":"2024-06-26T04:29:32.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E5%9C%9F%E9%97%B4%E5%9F%8B%E3%80%912024-06-26%2012_42_48.png","_content":"\n## 如何使用Alfred与iTerm2进行高效的命令行操作\n\n这里是一篇关于如何使用 Alfred 和 iTerm2 集成自定义 AppleScript 的博客文章。这个集成可以极大地提升 macOS 用户在使用终端时的效率和便利性。\n\n> 对于 macOS 用户来说，Alfred 和 iTerm2 是两个非常强大的工具。Alfred 作为一款效率提升工具，能够通过快捷键和简单的命令来执行各种操作，而 iTerm2 则是一个功能丰富的替代 macOS 默认终端的应用。将这两者结合起来，你可以通过简单的 Alfred 命令来控制 iTerm2，执行脚本或者打开新的终端会话。\n>\n\n### 自定义 Alfred 通过 iTerm2 执行脚本的步骤\n\n#### 第一步：获取脚本\n\n首先，你需要[获取](https://github.com/vitorgalvao/custom-alfred-iterm-scripts)一个可以将 Alfred 和 iTerm2 集成的 AppleScript。这个脚本定义了如何通过 Alfred 命令来控制 iTerm2。使用以下命令可以将脚本直接复制到你的剪贴板：\n\n```bash\ncurl --silent 'https://raw.githubusercontent.com/vitorgalvao/custom-alfred-iterm-scripts/master/custom_iterm_script.applescript' | pbcopy\n```\n\n#### 第二步：配置 Alfred\n\n打开 Alfred 的偏好设置：\n\n1. 打开 Alfred 的偏好设置（通过呼叫 Alfred 并按 `⌘,`）。\n2. 导航到“功能” → “终端 / Shell” → “自定义”。\n3. 在“Application”下拉菜单中选择“自定义”，然后粘贴你的脚本到文本框中。\n\n#### 第三步：自定义脚本行为\n\n脚本的顶部有几个 `property` 设置，可以根据你的需要进行调整：\n\n- `open_in_new_window`: 设置为 `true` 可以让每个 Alfred 命令在新窗口中打开。\n- `open_in_new_tab`: 设置为 `true` 会在新标签页中打开命令，`false` 则在当前标签页重用。\n- `iterm2_opens_quietly`: 如果你的 iTerm2 配置为启动时不打开新窗口，将此设为 `true`。\n\n#### 第四步：使用\n\n完成设置后，你可以通过 Alfred 运行任何命令。比如，通过 Alfred 的搜索框输入 `> ls`，这个命令就会在 iTerm2 的当前窗口中执行，显示当前目录的内容。\n\n**转载自GitHub:** [vitorgalvao/custom-alfred-iterm-scripts](https://github.com/vitorgalvao/custom-alfred-iterm-scripts)\n","source":"_posts/脚本.md","raw":"---\ntitle: 自定义 Alfred iTerm 脚本\ndate: 2024-06-26 12:29:32\ntags: Mac\ncategories: Mac\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E3%80%90%E5%9C%9F%E9%97%B4%E5%9F%8B%E3%80%912024-06-26%2012_42_48.png\n---\n\n## 如何使用Alfred与iTerm2进行高效的命令行操作\n\n这里是一篇关于如何使用 Alfred 和 iTerm2 集成自定义 AppleScript 的博客文章。这个集成可以极大地提升 macOS 用户在使用终端时的效率和便利性。\n\n> 对于 macOS 用户来说，Alfred 和 iTerm2 是两个非常强大的工具。Alfred 作为一款效率提升工具，能够通过快捷键和简单的命令来执行各种操作，而 iTerm2 则是一个功能丰富的替代 macOS 默认终端的应用。将这两者结合起来，你可以通过简单的 Alfred 命令来控制 iTerm2，执行脚本或者打开新的终端会话。\n>\n\n### 自定义 Alfred 通过 iTerm2 执行脚本的步骤\n\n#### 第一步：获取脚本\n\n首先，你需要[获取](https://github.com/vitorgalvao/custom-alfred-iterm-scripts)一个可以将 Alfred 和 iTerm2 集成的 AppleScript。这个脚本定义了如何通过 Alfred 命令来控制 iTerm2。使用以下命令可以将脚本直接复制到你的剪贴板：\n\n```bash\ncurl --silent 'https://raw.githubusercontent.com/vitorgalvao/custom-alfred-iterm-scripts/master/custom_iterm_script.applescript' | pbcopy\n```\n\n#### 第二步：配置 Alfred\n\n打开 Alfred 的偏好设置：\n\n1. 打开 Alfred 的偏好设置（通过呼叫 Alfred 并按 `⌘,`）。\n2. 导航到“功能” → “终端 / Shell” → “自定义”。\n3. 在“Application”下拉菜单中选择“自定义”，然后粘贴你的脚本到文本框中。\n\n#### 第三步：自定义脚本行为\n\n脚本的顶部有几个 `property` 设置，可以根据你的需要进行调整：\n\n- `open_in_new_window`: 设置为 `true` 可以让每个 Alfred 命令在新窗口中打开。\n- `open_in_new_tab`: 设置为 `true` 会在新标签页中打开命令，`false` 则在当前标签页重用。\n- `iterm2_opens_quietly`: 如果你的 iTerm2 配置为启动时不打开新窗口，将此设为 `true`。\n\n#### 第四步：使用\n\n完成设置后，你可以通过 Alfred 运行任何命令。比如，通过 Alfred 的搜索框输入 `> ls`，这个命令就会在 iTerm2 的当前窗口中执行，显示当前目录的内容。\n\n**转载自GitHub:** [vitorgalvao/custom-alfred-iterm-scripts](https://github.com/vitorgalvao/custom-alfred-iterm-scripts)\n","slug":"脚本","published":1,"updated":"2024-07-11T10:27:41.333Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2h1001ctuj83xg63nr4","content":"<h2 id=\"如何使用Alfred与iTerm2进行高效的命令行操作\"><a class=\"headerlink\" href=\"#如何使用Alfred与iTerm2进行高效的命令行操作\"></a>如何使用Alfred与iTerm2进行高效的命令行操作</h2>\n<p>这里是一篇关于如何使用 Alfred 和 iTerm2 集成自定义 AppleScript 的博客文章。这个集成可以极大地提升 macOS 用户在使用终端时的效率和便利性。</p>\n<blockquote>\n<p>对于 macOS 用户来说，Alfred 和 iTerm2 是两个非常强大的工具。Alfred 作为一款效率提升工具，能够通过快捷键和简单的命令来执行各种操作，而 iTerm2 则是一个功能丰富的替代 macOS 默认终端的应用。将这两者结合起来，你可以通过简单的 Alfred 命令来控制 iTerm2，执行脚本或者打开新的终端会话。</p>\n</blockquote>\n<h3 id=\"自定义-Alfred-通过-iTerm2-执行脚本的步骤\"><a class=\"headerlink\" href=\"#自定义-Alfred-通过-iTerm2-执行脚本的步骤\"></a>自定义 Alfred 通过 iTerm2 执行脚本的步骤</h3>\n<h4 id=\"第一步：获取脚本\"><a class=\"headerlink\" href=\"#第一步：获取脚本\"></a>第一步：获取脚本</h4>\n<p>首先，你需要<a href=\"https://github.com/vitorgalvao/custom-alfred-iterm-scripts\">获取</a>一个可以将 Alfred 和 iTerm2 集成的 AppleScript。这个脚本定义了如何通过 Alfred 命令来控制 iTerm2。使用以下命令可以将脚本直接复制到你的剪贴板：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">--silent</span> <span class=\"token string\">'https://raw.githubusercontent.com/vitorgalvao/custom-alfred-iterm-scripts/master/custom_iterm_script.applescript'</span> <span class=\"token operator\">|</span> pbcopy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"第二步：配置-Alfred\"><a class=\"headerlink\" href=\"#第二步：配置-Alfred\"></a>第二步：配置 Alfred</h4>\n<p>打开 Alfred 的偏好设置：</p>\n<ol>\n<li>打开 Alfred 的偏好设置（通过呼叫 Alfred 并按 <code>⌘,</code>）。</li>\n<li>导航到“功能” → “终端 / Shell” → “自定义”。</li>\n<li>在“Application”下拉菜单中选择“自定义”，然后粘贴你的脚本到文本框中。</li>\n</ol>\n<h4 id=\"第三步：自定义脚本行为\"><a class=\"headerlink\" href=\"#第三步：自定义脚本行为\"></a>第三步：自定义脚本行为</h4>\n<p>脚本的顶部有几个 <code>property</code> 设置，可以根据你的需要进行调整：</p>\n<ul>\n<li><code>open_in_new_window</code>: 设置为 <code>true</code> 可以让每个 Alfred 命令在新窗口中打开。</li>\n<li><code>open_in_new_tab</code>: 设置为 <code>true</code> 会在新标签页中打开命令，<code>false</code> 则在当前标签页重用。</li>\n<li><code>iterm2_opens_quietly</code>: 如果你的 iTerm2 配置为启动时不打开新窗口，将此设为 <code>true</code>。</li>\n</ul>\n<h4 id=\"第四步：使用\"><a class=\"headerlink\" href=\"#第四步：使用\"></a>第四步：使用</h4>\n<p>完成设置后，你可以通过 Alfred 运行任何命令。比如，通过 Alfred 的搜索框输入 <code>&gt; ls</code>，这个命令就会在 iTerm2 的当前窗口中执行，显示当前目录的内容。</p>\n<p><strong>转载自GitHub:</strong> <a href=\"https://github.com/vitorgalvao/custom-alfred-iterm-scripts\">vitorgalvao/custom-alfred-iterm-scripts</a></p>\n","excerpt":"","more":"<h2 id=\"如何使用Alfred与iTerm2进行高效的命令行操作\"><a class=\"headerlink\" href=\"#如何使用Alfred与iTerm2进行高效的命令行操作\"></a>如何使用Alfred与iTerm2进行高效的命令行操作</h2>\n<p>这里是一篇关于如何使用 Alfred 和 iTerm2 集成自定义 AppleScript 的博客文章。这个集成可以极大地提升 macOS 用户在使用终端时的效率和便利性。</p>\n<blockquote>\n<p>对于 macOS 用户来说，Alfred 和 iTerm2 是两个非常强大的工具。Alfred 作为一款效率提升工具，能够通过快捷键和简单的命令来执行各种操作，而 iTerm2 则是一个功能丰富的替代 macOS 默认终端的应用。将这两者结合起来，你可以通过简单的 Alfred 命令来控制 iTerm2，执行脚本或者打开新的终端会话。</p>\n</blockquote>\n<h3 id=\"自定义-Alfred-通过-iTerm2-执行脚本的步骤\"><a class=\"headerlink\" href=\"#自定义-Alfred-通过-iTerm2-执行脚本的步骤\"></a>自定义 Alfred 通过 iTerm2 执行脚本的步骤</h3>\n<h4 id=\"第一步：获取脚本\"><a class=\"headerlink\" href=\"#第一步：获取脚本\"></a>第一步：获取脚本</h4>\n<p>首先，你需要<a href=\"https://github.com/vitorgalvao/custom-alfred-iterm-scripts\">获取</a>一个可以将 Alfred 和 iTerm2 集成的 AppleScript。这个脚本定义了如何通过 Alfred 命令来控制 iTerm2。使用以下命令可以将脚本直接复制到你的剪贴板：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">--silent</span> <span class=\"token string\">'https://raw.githubusercontent.com/vitorgalvao/custom-alfred-iterm-scripts/master/custom_iterm_script.applescript'</span> <span class=\"token operator\">|</span> pbcopy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"第二步：配置-Alfred\"><a class=\"headerlink\" href=\"#第二步：配置-Alfred\"></a>第二步：配置 Alfred</h4>\n<p>打开 Alfred 的偏好设置：</p>\n<ol>\n<li>打开 Alfred 的偏好设置（通过呼叫 Alfred 并按 <code>⌘,</code>）。</li>\n<li>导航到“功能” → “终端 / Shell” → “自定义”。</li>\n<li>在“Application”下拉菜单中选择“自定义”，然后粘贴你的脚本到文本框中。</li>\n</ol>\n<h4 id=\"第三步：自定义脚本行为\"><a class=\"headerlink\" href=\"#第三步：自定义脚本行为\"></a>第三步：自定义脚本行为</h4>\n<p>脚本的顶部有几个 <code>property</code> 设置，可以根据你的需要进行调整：</p>\n<ul>\n<li><code>open_in_new_window</code>: 设置为 <code>true</code> 可以让每个 Alfred 命令在新窗口中打开。</li>\n<li><code>open_in_new_tab</code>: 设置为 <code>true</code> 会在新标签页中打开命令，<code>false</code> 则在当前标签页重用。</li>\n<li><code>iterm2_opens_quietly</code>: 如果你的 iTerm2 配置为启动时不打开新窗口，将此设为 <code>true</code>。</li>\n</ul>\n<h4 id=\"第四步：使用\"><a class=\"headerlink\" href=\"#第四步：使用\"></a>第四步：使用</h4>\n<p>完成设置后，你可以通过 Alfred 运行任何命令。比如，通过 Alfred 的搜索框输入 <code>&gt; ls</code>，这个命令就会在 iTerm2 的当前窗口中执行，显示当前目录的内容。</p>\n<p><strong>转载自GitHub:</strong> <a href=\"https://github.com/vitorgalvao/custom-alfred-iterm-scripts\">vitorgalvao/custom-alfred-iterm-scripts</a></p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"自动续签证书","date":"2024-06-24T12:34:50.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/%E5%8E%9A%E6%B6%82%E5%A5%B3%E5%AD%A9%20%E6%89%8B%E7%BB%98%E7%94%BB4K.jpeg","_content":"\n# 使用 acme.sh 安装和管理 SSL 证书\n\n本文将介绍如何使用 acme.sh 安装和管理 SSL 证书。acme.sh 是一个纯 Shell 脚本的 ACME 协议客户端，可以帮助你自动化管理 Let's Encrypt 及其他 CA 颁发的证书。\n\n## 下载并安装 acme.sh\n\n首先，下载并安装 acme.sh。在终端中执行以下命令：\n\n```bash\ncd ~\ncurl https://get.acme.sh | sh -s email=<youremail@domain.com>\n```\n\n安装过程会执行以下几步：\n\n1. 将 acme.sh 安装到你的 **home** 目录中：\n\n    ```\n    ~/.acme.sh/\n    ```\n\n2. 创建一个 Shell 别名，方便使用。在 `.bashrc` 中添加：\n\n    ```bash\n    alias acme.sh=~/.acme.sh/acme.sh\n    ```\n\n3. 自动为你创建一个 cronjob，每天 0:00 自动检测所有的证书。如果证书即将过期，需要更新，则会自动更新证书。\n\n更高级的安装选项请参考：[acme.sh 安装文档](https://github.com/Neilpang/acme.sh/wiki/How-to-install)\n\n**注意**：安装过程不会影响现有系统的运行和文件，所有修改都位于 `~/.acme.sh/` 目录中。\n\n## 使用 DNS 验证方式生成 SSL 证书\n\nacme.sh 实现了 ACME 协议支持的所有验证协议。一般有两种方式验证：HTTP 和 DNS 验证。这里我们使用 DNS 验证。\n\n### 手动 DNS 验证\n\n手动 DNS 验证方式不需要服务器或公网 IP，只需要在域名管理面板上添加一条 TXT 解析记录来验证域名所有权。\n\n1. 运行以下命令，手动在域名上添加一条 TXT 解析记录：\n\n    ```bash\n    acme.sh --issue --dns -d <mydomain.com> \\\n    --yes-I-know-dns-manual-mode-enough-go-ahead-please\n    ```\n\n2. acme.sh 会生成相应的解析记录并显示出来，你需要在域名管理面板上添加该 TXT 记录。\n\n3. 等待解析完成后，重新生成证书：\n\n    ```bash\n    acme.sh --renew -d <mydomain.com> \\\n    --yes-I-know-dns-manual-mode-enough-go-ahead-please\n    ```\n\n4. 安装生成的证书：\n\n    ```bash\n    acme.sh --install-cert -d <mydomain.com> \\\n    --key-file /opt/nginx/key.pem  \\\n    --fullchain-file /opt/nginx/cert.pem \\\n    ```\n\n## 总结\n\n通过以上步骤，你已经成功使用 acme.sh 安装和管理了 SSL 证书。虽然手动 DNS 验证方式不需要服务器或公网 IP，但每次请求新证书时都需要手动添加解析记录。如果希望实现自动化，可以使用支持 DNS API 的提供商并配置自动 DNS 验证。有关详细信息，请参考 [acme.sh 的 DNS API 支持文档](https://github.com/Neilpang/acme.sh/wiki/dnsapi)。\n\n希望本文对你有所帮助！\n","source":"_posts/自动续签证书.md","raw":"---\ntitle: 自动续签证书\ndate: 2024-06-24 20:34:50\ntags:\n    - Linux\n    - SSL\n    - 域名\ncategories:  Linux\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/%E5%8E%9A%E6%B6%82%E5%A5%B3%E5%AD%A9%20%E6%89%8B%E7%BB%98%E7%94%BB4K.jpeg\n---\n\n# 使用 acme.sh 安装和管理 SSL 证书\n\n本文将介绍如何使用 acme.sh 安装和管理 SSL 证书。acme.sh 是一个纯 Shell 脚本的 ACME 协议客户端，可以帮助你自动化管理 Let's Encrypt 及其他 CA 颁发的证书。\n\n## 下载并安装 acme.sh\n\n首先，下载并安装 acme.sh。在终端中执行以下命令：\n\n```bash\ncd ~\ncurl https://get.acme.sh | sh -s email=<youremail@domain.com>\n```\n\n安装过程会执行以下几步：\n\n1. 将 acme.sh 安装到你的 **home** 目录中：\n\n    ```\n    ~/.acme.sh/\n    ```\n\n2. 创建一个 Shell 别名，方便使用。在 `.bashrc` 中添加：\n\n    ```bash\n    alias acme.sh=~/.acme.sh/acme.sh\n    ```\n\n3. 自动为你创建一个 cronjob，每天 0:00 自动检测所有的证书。如果证书即将过期，需要更新，则会自动更新证书。\n\n更高级的安装选项请参考：[acme.sh 安装文档](https://github.com/Neilpang/acme.sh/wiki/How-to-install)\n\n**注意**：安装过程不会影响现有系统的运行和文件，所有修改都位于 `~/.acme.sh/` 目录中。\n\n## 使用 DNS 验证方式生成 SSL 证书\n\nacme.sh 实现了 ACME 协议支持的所有验证协议。一般有两种方式验证：HTTP 和 DNS 验证。这里我们使用 DNS 验证。\n\n### 手动 DNS 验证\n\n手动 DNS 验证方式不需要服务器或公网 IP，只需要在域名管理面板上添加一条 TXT 解析记录来验证域名所有权。\n\n1. 运行以下命令，手动在域名上添加一条 TXT 解析记录：\n\n    ```bash\n    acme.sh --issue --dns -d <mydomain.com> \\\n    --yes-I-know-dns-manual-mode-enough-go-ahead-please\n    ```\n\n2. acme.sh 会生成相应的解析记录并显示出来，你需要在域名管理面板上添加该 TXT 记录。\n\n3. 等待解析完成后，重新生成证书：\n\n    ```bash\n    acme.sh --renew -d <mydomain.com> \\\n    --yes-I-know-dns-manual-mode-enough-go-ahead-please\n    ```\n\n4. 安装生成的证书：\n\n    ```bash\n    acme.sh --install-cert -d <mydomain.com> \\\n    --key-file /opt/nginx/key.pem  \\\n    --fullchain-file /opt/nginx/cert.pem \\\n    ```\n\n## 总结\n\n通过以上步骤，你已经成功使用 acme.sh 安装和管理了 SSL 证书。虽然手动 DNS 验证方式不需要服务器或公网 IP，但每次请求新证书时都需要手动添加解析记录。如果希望实现自动化，可以使用支持 DNS API 的提供商并配置自动 DNS 验证。有关详细信息，请参考 [acme.sh 的 DNS API 支持文档](https://github.com/Neilpang/acme.sh/wiki/dnsapi)。\n\n希望本文对你有所帮助！\n","slug":"自动续签证书","published":1,"updated":"2024-07-11T10:27:03.063Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2h1001etuj8d9i739wq","content":"<h1 id=\"使用-acme-sh-安装和管理-SSL-证书\"><a class=\"headerlink\" href=\"#使用-acme-sh-安装和管理-SSL-证书\"></a>使用 <a href=\"http://acme.sh\">acme.sh</a> 安装和管理 SSL 证书</h1>\n<p>本文将介绍如何使用 <a href=\"http://acme.sh\">acme.sh</a> 安装和管理 SSL 证书。<a href=\"http://acme.sh\">acme.sh</a> 是一个纯 Shell 脚本的 ACME 协议客户端，可以帮助你自动化管理 Let’s Encrypt 及其他 CA 颁发的证书。</p>\n<h2 id=\"下载并安装-acme-sh\"><a class=\"headerlink\" href=\"#下载并安装-acme-sh\"></a>下载并安装 <a href=\"http://acme.sh\">acme.sh</a></h2>\n<p>首先，下载并安装 <a href=\"http://acme.sh\">acme.sh</a>。在终端中执行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> ~\n<span class=\"token function\">curl</span> https://get.acme.sh <span class=\"token operator\">|</span> <span class=\"token function\">sh</span> <span class=\"token parameter variable\">-s</span> <span class=\"token assign-left variable\">email</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>youremail@domain.com<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>安装过程会执行以下几步：</p>\n<ol>\n<li>\n<p>将 <a href=\"http://acme.sh\">acme.sh</a> 安装到你的 <strong>home</strong> 目录中：</p>\n <pre class=\"line-numbers language-none\"><code class=\"language-none\">~&#x2F;.acme.sh&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>创建一个 Shell 别名，方便使用。在 <code>.bashrc</code> 中添加：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">alias</span> <span class=\"token assign-left variable\">acme.sh</span><span class=\"token operator\">=~</span>/.acme.sh/acme.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>自动为你创建一个 cronjob，每天 0:00 自动检测所有的证书。如果证书即将过期，需要更新，则会自动更新证书。</p>\n</li>\n</ol>\n<p>更高级的安装选项请参考：<a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-install\">acme.sh 安装文档</a></p>\n<p><strong>注意</strong>：安装过程不会影响现有系统的运行和文件，所有修改都位于 <code>~/.acme.sh/</code> 目录中。</p>\n<h2 id=\"使用-DNS-验证方式生成-SSL-证书\"><a class=\"headerlink\" href=\"#使用-DNS-验证方式生成-SSL-证书\"></a>使用 DNS 验证方式生成 SSL 证书</h2>\n<p><a href=\"http://acme.sh\">acme.sh</a> 实现了 ACME 协议支持的所有验证协议。一般有两种方式验证：HTTP 和 DNS 验证。这里我们使用 DNS 验证。</p>\n<h3 id=\"手动-DNS-验证\"><a class=\"headerlink\" href=\"#手动-DNS-验证\"></a>手动 DNS 验证</h3>\n<p>手动 DNS 验证方式不需要服务器或公网 IP，只需要在域名管理面板上添加一条 TXT 解析记录来验证域名所有权。</p>\n<ol>\n<li>\n<p>运行以下命令，手动在域名上添加一条 TXT 解析记录：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">acme.sh <span class=\"token parameter variable\">--issue</span> <span class=\"token parameter variable\">--dns</span> <span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>mydomain.com<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n--yes-I-know-dns-manual-mode-enough-go-ahead-please<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p><a href=\"http://acme.sh\">acme.sh</a> 会生成相应的解析记录并显示出来，你需要在域名管理面板上添加该 TXT 记录。</p>\n</li>\n<li>\n<p>等待解析完成后，重新生成证书：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">acme.sh <span class=\"token parameter variable\">--renew</span> <span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>mydomain.com<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n--yes-I-know-dns-manual-mode-enough-go-ahead-please<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>安装生成的证书：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">acme.sh --install-cert <span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>mydomain.com<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n--key-file /opt/nginx/key.pem  <span class=\"token punctuation\">\\</span>\n--fullchain-file /opt/nginx/cert.pem <span class=\"token punctuation\">\\</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h2 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h2>\n<p>通过以上步骤，你已经成功使用 <a href=\"http://acme.sh\">acme.sh</a> 安装和管理了 SSL 证书。虽然手动 DNS 验证方式不需要服务器或公网 IP，但每次请求新证书时都需要手动添加解析记录。如果希望实现自动化，可以使用支持 DNS API 的提供商并配置自动 DNS 验证。有关详细信息，请参考 <a href=\"https://github.com/Neilpang/acme.sh/wiki/dnsapi\">acme.sh 的 DNS API 支持文档</a>。</p>\n<p>希望本文对你有所帮助！</p>\n","excerpt":"","more":"<h1 id=\"使用-acme-sh-安装和管理-SSL-证书\"><a class=\"headerlink\" href=\"#使用-acme-sh-安装和管理-SSL-证书\"></a>使用 <a href=\"http://acme.sh\">acme.sh</a> 安装和管理 SSL 证书</h1>\n<p>本文将介绍如何使用 <a href=\"http://acme.sh\">acme.sh</a> 安装和管理 SSL 证书。<a href=\"http://acme.sh\">acme.sh</a> 是一个纯 Shell 脚本的 ACME 协议客户端，可以帮助你自动化管理 Let’s Encrypt 及其他 CA 颁发的证书。</p>\n<h2 id=\"下载并安装-acme-sh\"><a class=\"headerlink\" href=\"#下载并安装-acme-sh\"></a>下载并安装 <a href=\"http://acme.sh\">acme.sh</a></h2>\n<p>首先，下载并安装 <a href=\"http://acme.sh\">acme.sh</a>。在终端中执行以下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> ~\n<span class=\"token function\">curl</span> https://get.acme.sh <span class=\"token operator\">|</span> <span class=\"token function\">sh</span> <span class=\"token parameter variable\">-s</span> <span class=\"token assign-left variable\">email</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>youremail@domain.com<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>安装过程会执行以下几步：</p>\n<ol>\n<li>\n<p>将 <a href=\"http://acme.sh\">acme.sh</a> 安装到你的 <strong>home</strong> 目录中：</p>\n <pre class=\"line-numbers language-none\"><code class=\"language-none\">~&#x2F;.acme.sh&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>创建一个 Shell 别名，方便使用。在 <code>.bashrc</code> 中添加：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">alias</span> <span class=\"token assign-left variable\">acme.sh</span><span class=\"token operator\">=~</span>/.acme.sh/acme.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>自动为你创建一个 cronjob，每天 0:00 自动检测所有的证书。如果证书即将过期，需要更新，则会自动更新证书。</p>\n</li>\n</ol>\n<p>更高级的安装选项请参考：<a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-install\">acme.sh 安装文档</a></p>\n<p><strong>注意</strong>：安装过程不会影响现有系统的运行和文件，所有修改都位于 <code>~/.acme.sh/</code> 目录中。</p>\n<h2 id=\"使用-DNS-验证方式生成-SSL-证书\"><a class=\"headerlink\" href=\"#使用-DNS-验证方式生成-SSL-证书\"></a>使用 DNS 验证方式生成 SSL 证书</h2>\n<p><a href=\"http://acme.sh\">acme.sh</a> 实现了 ACME 协议支持的所有验证协议。一般有两种方式验证：HTTP 和 DNS 验证。这里我们使用 DNS 验证。</p>\n<h3 id=\"手动-DNS-验证\"><a class=\"headerlink\" href=\"#手动-DNS-验证\"></a>手动 DNS 验证</h3>\n<p>手动 DNS 验证方式不需要服务器或公网 IP，只需要在域名管理面板上添加一条 TXT 解析记录来验证域名所有权。</p>\n<ol>\n<li>\n<p>运行以下命令，手动在域名上添加一条 TXT 解析记录：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">acme.sh <span class=\"token parameter variable\">--issue</span> <span class=\"token parameter variable\">--dns</span> <span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>mydomain.com<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n--yes-I-know-dns-manual-mode-enough-go-ahead-please<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p><a href=\"http://acme.sh\">acme.sh</a> 会生成相应的解析记录并显示出来，你需要在域名管理面板上添加该 TXT 记录。</p>\n</li>\n<li>\n<p>等待解析完成后，重新生成证书：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">acme.sh <span class=\"token parameter variable\">--renew</span> <span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>mydomain.com<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n--yes-I-know-dns-manual-mode-enough-go-ahead-please<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>安装生成的证书：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">acme.sh --install-cert <span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>mydomain.com<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n--key-file /opt/nginx/key.pem  <span class=\"token punctuation\">\\</span>\n--fullchain-file /opt/nginx/cert.pem <span class=\"token punctuation\">\\</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h2 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h2>\n<p>通过以上步骤，你已经成功使用 <a href=\"http://acme.sh\">acme.sh</a> 安装和管理了 SSL 证书。虽然手动 DNS 验证方式不需要服务器或公网 IP，但每次请求新证书时都需要手动添加解析记录。如果希望实现自动化，可以使用支持 DNS API 的提供商并配置自动 DNS 验证。有关详细信息，请参考 <a href=\"https://github.com/Neilpang/acme.sh/wiki/dnsapi\">acme.sh 的 DNS API 支持文档</a>。</p>\n<p>希望本文对你有所帮助！</p>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true},{"title":"项目讲解","date":"2024-06-27T07:34:31.000Z","cover":"https://alist.aixcc.top/d/OneDrive/Cloud/bingimg_20240621_UHD.jpg","_content":"\n# 随便写写\n\n### 登录注册模块\n\n- **注册**：使用阿里云的短信服务将后端生成的验证码通过阿里云短信服务发送到用户手机号，并将前端传来的注册信息封装成一个 vo 类，根据用户的手机号对用户表进行查询，如果发现这个手机号已经注册，则抛出一个异常，前端显示“手机号已注册”，否则将该用户信息存入用户表。\n- 登录：将前端传来的登录信息与数据库中的信息进行比对，如果该数据库中有该信息则返回根据用户信息生成的一个 token 值，前端可以根据该 tokne 获取到用户名进行显示。\n\n\n\n### 前后端分离项目中跨域问题是如何解决的？\n\n1.  **注解**：可以通过使用`@CrossOrigin`注解来解决跨域问题。\n2. **Nginx**：使用 Nginx 反向代理配置添加CORS头来解决跨域问题。\n3. **网关**：使用 GetWay 网关中配置CORS规则，允许跨域请求\n\n\n\n\n\n\n\n","source":"_posts/项目讲解.md","raw":"---\ntitle: 项目讲解\ndate: 2024-06-27 15:34:31\ntags: Java\ncategories: Java\ncover: https://alist.aixcc.top/d/OneDrive/Cloud/bingimg_20240621_UHD.jpg\n---\n\n# 随便写写\n\n### 登录注册模块\n\n- **注册**：使用阿里云的短信服务将后端生成的验证码通过阿里云短信服务发送到用户手机号，并将前端传来的注册信息封装成一个 vo 类，根据用户的手机号对用户表进行查询，如果发现这个手机号已经注册，则抛出一个异常，前端显示“手机号已注册”，否则将该用户信息存入用户表。\n- 登录：将前端传来的登录信息与数据库中的信息进行比对，如果该数据库中有该信息则返回根据用户信息生成的一个 token 值，前端可以根据该 tokne 获取到用户名进行显示。\n\n\n\n### 前后端分离项目中跨域问题是如何解决的？\n\n1.  **注解**：可以通过使用`@CrossOrigin`注解来解决跨域问题。\n2. **Nginx**：使用 Nginx 反向代理配置添加CORS头来解决跨域问题。\n3. **网关**：使用 GetWay 网关中配置CORS规则，允许跨域请求\n\n\n\n\n\n\n\n","slug":"项目讲解","published":1,"updated":"2024-07-11T10:27:26.987Z","comments":1,"layout":"post","photos":[],"_id":"clyh4m2h2001jtuj88qfu9gj1","content":"<h1 id=\"随便写写\"><a class=\"headerlink\" href=\"#随便写写\"></a>随便写写</h1>\n<h3 id=\"登录注册模块\"><a class=\"headerlink\" href=\"#登录注册模块\"></a>登录注册模块</h3>\n<ul>\n<li><strong>注册</strong>：使用阿里云的短信服务将后端生成的验证码通过阿里云短信服务发送到用户手机号，并将前端传来的注册信息封装成一个 vo 类，根据用户的手机号对用户表进行查询，如果发现这个手机号已经注册，则抛出一个异常，前端显示“手机号已注册”，否则将该用户信息存入用户表。</li>\n<li>登录：将前端传来的登录信息与数据库中的信息进行比对，如果该数据库中有该信息则返回根据用户信息生成的一个 token 值，前端可以根据该 tokne 获取到用户名进行显示。</li>\n</ul>\n<h3 id=\"前后端分离项目中跨域问题是如何解决的？\"><a class=\"headerlink\" href=\"#前后端分离项目中跨域问题是如何解决的？\"></a>前后端分离项目中跨域问题是如何解决的？</h3>\n<ol>\n<li><strong>注解</strong>：可以通过使用<code>@CrossOrigin</code>注解来解决跨域问题。</li>\n<li><strong>Nginx</strong>：使用 Nginx 反向代理配置添加CORS头来解决跨域问题。</li>\n<li><strong>网关</strong>：使用 GetWay 网关中配置CORS规则，允许跨域请求</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"随便写写\"><a class=\"headerlink\" href=\"#随便写写\"></a>随便写写</h1>\n<h3 id=\"登录注册模块\"><a class=\"headerlink\" href=\"#登录注册模块\"></a>登录注册模块</h3>\n<ul>\n<li><strong>注册</strong>：使用阿里云的短信服务将后端生成的验证码通过阿里云短信服务发送到用户手机号，并将前端传来的注册信息封装成一个 vo 类，根据用户的手机号对用户表进行查询，如果发现这个手机号已经注册，则抛出一个异常，前端显示“手机号已注册”，否则将该用户信息存入用户表。</li>\n<li>登录：将前端传来的登录信息与数据库中的信息进行比对，如果该数据库中有该信息则返回根据用户信息生成的一个 token 值，前端可以根据该 tokne 获取到用户名进行显示。</li>\n</ul>\n<h3 id=\"前后端分离项目中跨域问题是如何解决的？\"><a class=\"headerlink\" href=\"#前后端分离项目中跨域问题是如何解决的？\"></a>前后端分离项目中跨域问题是如何解决的？</h3>\n<ol>\n<li><strong>注解</strong>：可以通过使用<code>@CrossOrigin</code>注解来解决跨域问题。</li>\n<li><strong>Nginx</strong>：使用 Nginx 反向代理配置添加CORS头来解决跨域问题。</li>\n<li><strong>网关</strong>：使用 GetWay 网关中配置CORS规则，允许跨域请求</li>\n</ol>\n","locate":"衡阳","cc":{"enable":true,"author":{"url":"/about/","img":null},"license":"CC BY-NC-SA 4.0","licenurl":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"},"toc":true,"ai":true,"comment":true}],"PostAsset":[],"PostCategory":[{"post_id":"clyh4m2gf0001tuj89p3f9yif","category_id":"clyh4m2gj0004tuj86xny52tn","_id":"clyh4m2gr000ftuj807myfl9p"},{"post_id":"clyh4m2gi0003tuj8cj2o3ygb","category_id":"clyh4m2go000atuj8dewo6g2z","_id":"clyh4m2gt000ktuj88seh3jwb"},{"post_id":"clyh4m2gq000etuj8e266gyo9","category_id":"clyh4m2go000atuj8dewo6g2z","_id":"clyh4m2gv000otuj8acr36q4t"},{"post_id":"clyh4m2gr000ituj85ievhv4l","category_id":"clyh4m2go000atuj8dewo6g2z","_id":"clyh4m2gw000rtuj84ek1221i"},{"post_id":"clyh4m2gs000jtuj8am9vgv7o","category_id":"clyh4m2go000atuj8dewo6g2z","_id":"clyh4m2gx000wtuj8chf1h6pk"},{"post_id":"clyh4m2gn0009tuj88jie57tz","category_id":"clyh4m2go000atuj8dewo6g2z","_id":"clyh4m2gy000ytuj8h7tdbpus"},{"post_id":"clyh4m2gw000qtuj89uil3shb","category_id":"clyh4m2gr000gtuj819i59vsc","_id":"clyh4m2gz0013tuj8hsx2cthg"},{"post_id":"clyh4m2gx000vtuj83c8hgcai","category_id":"clyh4m2go000atuj8dewo6g2z","_id":"clyh4m2h00016tuj8duargi3g"},{"post_id":"clyh4m2gp000dtuj8af848htf","category_id":"clyh4m2gw000ttuj85mgm0kpt","_id":"clyh4m2h1001atuj8b0n9ht0m"},{"post_id":"clyh4m2gy000xtuj83339d3ql","category_id":"clyh4m2gj0004tuj86xny52tn","_id":"clyh4m2h1001dtuj8hppnbmeb"},{"post_id":"clyh4m2gz0012tuj8bbvs063i","category_id":"clyh4m2gr000gtuj819i59vsc","_id":"clyh4m2h2001gtuj86ycy4jpf"},{"post_id":"clyh4m2gz0015tuj8a9okgg1a","category_id":"clyh4m2gr000gtuj819i59vsc","_id":"clyh4m2h3001ktuj83dpy1djp"},{"post_id":"clyh4m2gm0008tuj8hfaefxuj","category_id":"clyh4m2gr000gtuj819i59vsc","_id":"clyh4m2h4001ntuj8570760ij"},{"post_id":"clyh4m2gm0008tuj8hfaefxuj","category_id":"clyh4m2gy0011tuj8h6s70s8h","_id":"clyh4m2h4001ptuj8cawpgyrm"},{"post_id":"clyh4m2h1001etuj8d9i739wq","category_id":"clyh4m2gr000gtuj819i59vsc","_id":"clyh4m2h4001rtuj806127b8r"},{"post_id":"clyh4m2h2001jtuj88qfu9gj1","category_id":"clyh4m2go000atuj8dewo6g2z","_id":"clyh4m2h4001stuj8635he1jk"},{"post_id":"clyh4m2h1001ctuj83xg63nr4","category_id":"clyh4m2h2001htuj8aq3nbygz","_id":"clyh4m2h5001ttuj84jgv0xoo"}],"PostTag":[{"post_id":"clyh4m2gf0001tuj89p3f9yif","tag_id":"clyh4m2gl0005tuj89sg60yci","_id":"clyh4m2gp000ctuj8gc5je34z"},{"post_id":"clyh4m2gi0003tuj8cj2o3ygb","tag_id":"clyh4m2gp000btuj83m5dcmwc","_id":"clyh4m2gw000ptuj891mgafvy"},{"post_id":"clyh4m2gi0003tuj8cj2o3ygb","tag_id":"clyh4m2gr000htuj88v5587r4","_id":"clyh4m2gw000stuj868nve1nn"},{"post_id":"clyh4m2gx000vtuj83c8hgcai","tag_id":"clyh4m2gp000btuj83m5dcmwc","_id":"clyh4m2gy0010tuj85c8j3g6s"},{"post_id":"clyh4m2gl0007tuj8ckmiabsx","tag_id":"clyh4m2gp000btuj83m5dcmwc","_id":"clyh4m2gz0014tuj84mad4hli"},{"post_id":"clyh4m2gl0007tuj8ckmiabsx","tag_id":"clyh4m2gr000htuj88v5587r4","_id":"clyh4m2h00017tuj834g8gwd7"},{"post_id":"clyh4m2gy000xtuj83339d3ql","tag_id":"clyh4m2gl0005tuj89sg60yci","_id":"clyh4m2h1001btuj8hxb57bne"},{"post_id":"clyh4m2gm0008tuj8hfaefxuj","tag_id":"clyh4m2gy000ztuj86b7j1t88","_id":"clyh4m2h2001ituj82jul5obn"},{"post_id":"clyh4m2gm0008tuj8hfaefxuj","tag_id":"clyh4m2h00018tuj85smwf3ys","_id":"clyh4m2h3001ltuj8etcb4lao"},{"post_id":"clyh4m2h2001jtuj88qfu9gj1","tag_id":"clyh4m2gp000btuj83m5dcmwc","_id":"clyh4m2h4001otuj874376i21"},{"post_id":"clyh4m2gn0009tuj88jie57tz","tag_id":"clyh4m2gp000btuj83m5dcmwc","_id":"clyh4m2h5001vtuj8g6zn9avv"},{"post_id":"clyh4m2gn0009tuj88jie57tz","tag_id":"clyh4m2h3001mtuj8d5swgmym","_id":"clyh4m2h5001wtuj87yc3c9ho"},{"post_id":"clyh4m2gn0009tuj88jie57tz","tag_id":"clyh4m2h4001qtuj85lixbi29","_id":"clyh4m2h5001ytuj82c0707su"},{"post_id":"clyh4m2gp000dtuj8af848htf","tag_id":"clyh4m2gy000ztuj86b7j1t88","_id":"clyh4m2h60020tuj8epd22tb5"},{"post_id":"clyh4m2gp000dtuj8af848htf","tag_id":"clyh4m2h4001qtuj85lixbi29","_id":"clyh4m2h60021tuj8dkst84es"},{"post_id":"clyh4m2gq000etuj8e266gyo9","tag_id":"clyh4m2h5001ztuj80n7lf6ws","_id":"clyh4m2h60024tuj85mbf9ij2"},{"post_id":"clyh4m2gq000etuj8e266gyo9","tag_id":"clyh4m2h4001qtuj85lixbi29","_id":"clyh4m2h60025tuj8bjru2mio"},{"post_id":"clyh4m2gq000etuj8e266gyo9","tag_id":"clyh4m2gp000btuj83m5dcmwc","_id":"clyh4m2h60027tuj82acebd74"},{"post_id":"clyh4m2gr000ituj85ievhv4l","tag_id":"clyh4m2h60023tuj8ekn42cl9","_id":"clyh4m2h70029tuj82swahozp"},{"post_id":"clyh4m2gr000ituj85ievhv4l","tag_id":"clyh4m2h4001qtuj85lixbi29","_id":"clyh4m2h7002atuj8e1h21gu0"},{"post_id":"clyh4m2gs000jtuj8am9vgv7o","tag_id":"clyh4m2gp000btuj83m5dcmwc","_id":"clyh4m2h8002dtuj81wr2duij"},{"post_id":"clyh4m2gs000jtuj8am9vgv7o","tag_id":"clyh4m2h70028tuj8fqmt4ymk","_id":"clyh4m2h8002etuj8a3nf0013"},{"post_id":"clyh4m2gs000jtuj8am9vgv7o","tag_id":"clyh4m2h4001qtuj85lixbi29","_id":"clyh4m2h8002gtuj83isv6t0q"},{"post_id":"clyh4m2gv000ntuj8b9fxeq5i","tag_id":"clyh4m2h00018tuj85smwf3ys","_id":"clyh4m2h8002htuj8gpr7fcv5"},{"post_id":"clyh4m2gw000qtuj89uil3shb","tag_id":"clyh4m2h8002ftuj83dimbgt9","_id":"clyh4m2h8002jtuj8d7wuhby4"},{"post_id":"clyh4m2gz0012tuj8bbvs063i","tag_id":"clyh4m2h8002ftuj83dimbgt9","_id":"clyh4m2h9002ltuj80p1h7ttg"},{"post_id":"clyh4m2gz0015tuj8a9okgg1a","tag_id":"clyh4m2h00018tuj85smwf3ys","_id":"clyh4m2h9002ntuj828nobxm5"},{"post_id":"clyh4m2h1001ctuj83xg63nr4","tag_id":"clyh4m2h9002mtuj8dumcadb6","_id":"clyh4m2ha002ptuj88zg3882j"},{"post_id":"clyh4m2h1001etuj8d9i739wq","tag_id":"clyh4m2h00018tuj85smwf3ys","_id":"clyh4m2hc002rtuj84ydl2zt5"},{"post_id":"clyh4m2h1001etuj8d9i739wq","tag_id":"clyh4m2h9002otuj8217h59mg","_id":"clyh4m2hc002stuj88d2v7ygt"},{"post_id":"clyh4m2h1001etuj8d9i739wq","tag_id":"clyh4m2ha002qtuj835jg689h","_id":"clyh4m2hc002ttuj8cuppg0j7"}],"Tag":[{"name":"Blog","_id":"clyh4m2gl0005tuj89sg60yci"},{"name":"Java","_id":"clyh4m2gp000btuj83m5dcmwc"},{"name":"笔记","_id":"clyh4m2gr000htuj88v5587r4"},{"name":"MySQL","_id":"clyh4m2gy000ztuj86b7j1t88"},{"name":"Linux","_id":"clyh4m2h00018tuj85smwf3ys"},{"name":"MyBatis","_id":"clyh4m2h3001mtuj8d5swgmym"},{"name":"总结","_id":"clyh4m2h4001qtuj85lixbi29"},{"name":"RabbitMQ","_id":"clyh4m2h5001ztuj80n7lf6ws"},{"name":"Redis","_id":"clyh4m2h60023tuj8ekn42cl9"},{"name":"Spring","_id":"clyh4m2h70028tuj8fqmt4ymk"},{"name":"Alist","_id":"clyh4m2h8002ftuj83dimbgt9"},{"name":"Mac","_id":"clyh4m2h9002mtuj8dumcadb6"},{"name":"SSL","_id":"clyh4m2h9002otuj8217h59mg"},{"name":"域名","_id":"clyh4m2ha002qtuj835jg689h"}]}}