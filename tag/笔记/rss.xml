<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>陆时忤的博客 • Posts by &#34;笔记&#34; tag</title>
        <link>http://blog.aixcc.top</link>
        <description>要再见 不要再见</description>
        <language>zh-CN</language>
        <pubDate>Sat, 22 Jun 2024 16:48:56 +0800</pubDate>
        <lastBuildDate>Sat, 22 Jun 2024 16:48:56 +0800</lastBuildDate>
        <category>Blog</category>
        <category>Java</category>
        <category>笔记</category>
        <category>MySQL</category>
        <category>Linux</category>
        <category>Mac</category>
        <category>Maven</category>
        <category>MyBatis</category>
        <category>总结</category>
        <category>RabbitMQ</category>
        <category>Redis</category>
        <category>Spring</category>
        <category>Alist</category>
        <category>Homebrew</category>
        <category>Vue</category>
        <category>前端</category>
        <category>SSL</category>
        <category>域名</category>
        <item>
            <guid isPermalink="true">http://blog.aixcc.top/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/</guid>
            <title>Java集合总结</title>
            <link>http://blog.aixcc.top/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/</link>
            <category>Java</category>
            <category>笔记</category>
            <pubDate>Sat, 22 Jun 2024 16:48:56 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Java集合&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Java集合&#34;&gt;&lt;/a&gt;Java集合&lt;/h1&gt;
&lt;h3 id=&#34;说说-List-Set-Queue-Map-四者的区别？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#说说-List-Set-Queue-Map-四者的区别？&#34;&gt;&lt;/a&gt;说说 List, Set, Queue, Map 四者的区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;List&lt;/code&gt;：存储的元素是有序的、可重复的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;：存储的元素不可重复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt;：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;：使用键值对存储，&lt;code&gt;key&lt;/code&gt;是无序的、不可重复的，&lt;code&gt;value&lt;/code&gt;是无序的、可重复的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;List&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#List&#34;&gt;&lt;/a&gt;List&lt;/h2&gt;
&lt;h3 id=&#34;ArrayList-和-Array-（数组）的区别？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#ArrayList-和-Array-（数组）的区别？&#34;&gt;&lt;/a&gt;ArrayList 和 Array （数组）的区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Array（数组）&lt;/strong&gt;：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ArrayList-可以添加-null-吗？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#ArrayList-可以添加-null-吗？&#34;&gt;&lt;/a&gt;ArrayList 可以添加 null 吗？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt;中可以存储任何类型的对象，包括&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;ArrayList和LinkedList的区别是什么？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#ArrayList和LinkedList的区别是什么？&#34;&gt;&lt;/a&gt;ArrayList和LinkedList的区别是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ArrayList&lt;/strong&gt; 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。&lt;/li&gt;
&lt;li&gt;**LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ArrayList如何去重？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#ArrayList如何去重？&#34;&gt;&lt;/a&gt;ArrayList如何去重？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用HashSet&lt;/strong&gt;：通过&lt;code&gt;HashSet&lt;/code&gt;的特性去重，然后转换回&lt;code&gt;ArrayList&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用Stream API&lt;/strong&gt;：使用Java 8引入的Stream的&lt;code&gt;distinct()&lt;/code&gt;方法去重。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手动遍历&lt;/strong&gt;：手动遍历&lt;code&gt;ArrayList&lt;/code&gt;并使用另一个&lt;code&gt;ArrayList&lt;/code&gt;存储不重复的元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Map&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Map&#34;&gt;&lt;/a&gt;Map&lt;/h2&gt;
&lt;h3 id=&#34;HashMap和LinkedHashMap的区别？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#HashMap和LinkedHashMap的区别？&#34;&gt;&lt;/a&gt;HashMap和LinkedHashMap的区别？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;继承自&lt;code&gt;HashMap&lt;/code&gt;，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。&lt;/p&gt;
&lt;h3 id=&#34;HashMap-和-HashTable-有什么区别？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#HashMap-和-HashTable-有什么区别？&#34;&gt;&lt;/a&gt;HashMap 和 HashTable 有什么区别？&lt;/h3&gt;
&lt;p&gt;因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。&lt;/p&gt;
&lt;h4 id=&#34;初始化容量和扩容方式：&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#初始化容量和扩容方式：&#34;&gt;&lt;/a&gt;初始化容量和扩容方式：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HashMap&lt;/strong&gt;：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ConcurrentHashMap和Hashtable的区别&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#ConcurrentHashMap和Hashtable的区别&#34;&gt;&lt;/a&gt;ConcurrentHashMap和Hashtable的区别?&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;和&lt;code&gt;Hashtable&lt;/code&gt;都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现机制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;锁粒度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;锁粒度大，所有操作都需要获取全表锁，降低了并发能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Null键和值&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;不允许存储&lt;code&gt;null&lt;/code&gt;键和&lt;code&gt;null&lt;/code&gt;值，尝试存储&lt;code&gt;null&lt;/code&gt;会抛出&lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;也不允许存储&lt;code&gt;null&lt;/code&gt;键和&lt;code&gt;null&lt;/code&gt;值，存储&lt;code&gt;null&lt;/code&gt;时会抛出&lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;迭代器安全性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;，但不保证读取到的值是最新的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总结：&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#总结：&#34;&gt;&lt;/a&gt;总结：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许&lt;code&gt;null&lt;/code&gt;键和值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许&lt;code&gt;null&lt;/code&gt;键和值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;HashMap-的底层原理&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#HashMap-的底层原理&#34;&gt;&lt;/a&gt;HashMap 的底层原理&lt;/h3&gt;
&lt;h5 id=&#34;1-数据结构&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#1-数据结构&#34;&gt;&lt;/a&gt;1. 数据结构&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链表&lt;/strong&gt;：是处理哈希冲突（多个键的哈希值相同）。当冲突较少时使用链表存储。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑树&lt;/strong&gt;：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-插入元素&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#2-插入元素&#34;&gt;&lt;/a&gt;2. 插入元素&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;计算键的哈希值，并确定在数组中的索引位置。&lt;/li&gt;
&lt;li&gt;检查该位置是否已经有元素：
&lt;ul&gt;
&lt;li&gt;如果没有元素，直接插入。&lt;/li&gt;
&lt;li&gt;如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;3-查找元素&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#3-查找元素&#34;&gt;&lt;/a&gt;3. 查找元素&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;计算键的哈希值，并确定在数组中的索引位置。&lt;/li&gt;
&lt;li&gt;在该位置的链表或红黑树中查找匹配键，返回对应的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;4-删除元素&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#4-删除元素&#34;&gt;&lt;/a&gt;4. 删除元素&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;计算键的哈希值，并确定在数组中的索引位置。&lt;/li&gt;
&lt;li&gt;在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;5-扩容机制&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#5-扩容机制&#34;&gt;&lt;/a&gt;5. 扩容机制&lt;/h5&gt;
&lt;p&gt;当&lt;code&gt;HashMap&lt;/code&gt;中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的数组，容量是原来的两倍。&lt;/li&gt;
&lt;li&gt;将原数组中的所有元素重新哈希并放入新数组中。&lt;/li&gt;
&lt;li&gt;重新调整链表或红黑树结构。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;总结&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#总结&#34;&gt;&lt;/a&gt;总结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据结构&lt;/strong&gt;：&lt;code&gt;HashMap&lt;/code&gt;使用数组、链表和红黑树存储元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希算法&lt;/strong&gt;：通过键的&lt;code&gt;hashCode()&lt;/code&gt;计算哈希值，并通过哈希值确定数组索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入元素&lt;/strong&gt;：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查找元素&lt;/strong&gt;：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除元素&lt;/strong&gt;：定位到数组索引，删除链表或红黑树中的节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩容机制&lt;/strong&gt;：当元素数量超过阈值时，&lt;code&gt;HashMap&lt;/code&gt;会自动扩容，重新分配数组并调整元素位置。&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
