---
title: Java基础总结
date: 2024-06-21 20:41:04
tags: 
    - Java
    - 笔记
categories: Java
cover: /img/JavaBasics.jpg
recommend: true
---
#### 对象相等和引用相等的区别
- **对象相等**：比较的是内存中存放的内容是否相等。
- **引用相等**：比较的是它们指向的内存地址是否相等。

#### 如果一个类没有声明构造方法，该程序能正确执行吗？
- 如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。
- 如果添加了类的构造方法，无论是否有参，`Java`都不会添加默认不带参数的构造方法。

#### 构造方法有哪些特点？是否可被重写？
- **构造方法的特点**：
  - 名字与类名相同。
  - 没有返回值。
  - 生成类的对象时自动执行，无需调用。
    构造方法不能被重写，但是可以被重载。

#### 面向对象的三大特征
- **封装**：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。
- **继承**：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。
- **多态**：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。

#### 接口和抽象类有什么共同点和区别？
- **共同点**：
  - 都不能被实例化。
  - 都可以包含抽象方法。
  - 都可以有默认的实现方法。
- **区别**：
  - 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。
  - 抽象类主要用于代码的复用，强调所属关系。
  - 一个类只能继承一个类，但是可以实现多个接口。
  - 接口中的成员变量只能是静态常量，不能被修改且必须有初始值。
  - 抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。

#### 深拷贝和浅拷贝的区别？什么是引用拷贝？
- **浅拷贝**：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用`Object`的`clone()`方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。
- **深拷贝**：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。
- **引用拷贝**：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。

#### == 和 equals()的区别？
- 对于基本数据类型，`==` 比较的是值。
- 对于引用数据类型，`==` 比较的是对象的内存地址。
- `equals()`没有重写时，等价于`==`比较两个对象。
- 被重写时，一般都重写`equals()`方法用来比较两个对象中的属性是否相等。

#### hashCode() 有什么用？
`hashCode()`方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。

#### 为什么重写 equals() 时必须重写 hashCode() 方法？

##### `equals()`和`hashCode()`的合同（约定）

如果两个对象根据`equals()`方法是相等的，那么它们的`hashCode()`值必须相同。

如果两个对象的`hashCode()`值相同，它们不一定是相等的（但它们有可能是相等的）。

#### String、StringBuffer、StringBuilder 的区别？
- **String**：不可变的，因为不可变，所以它是线程安全的。
- **StringBuffer**：可变的，允许对字符串进行修改，线程安全，所有的方法都被`synchronized`修饰。
- **StringBuilder**：可变的，但不是线程安全的，没有被`synchronized`修饰。由于没有同步机制，性能比`StringBuffer`更高，适合单线程环境下使用。
- **使用场景**：
  - 当字符串是固定不变的时候使用`String`。
  - 当需要对字符串进行大量修改且在多线程环境下使用`StringBuffer`。
  - 当需要对字符串进行大量修改且在单线程环境下使用`StringBuilder`。

#### 字符串常量池的作用了解吗？
字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，`JVM`会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。

#### Exception 和 Error 有什么区别？
- **Exception**和**Error**都是**Throwable**的子类。
- `Exception`是程序本身可以处理的异常，可以通过`catch`来捕获。`Exception`还可以分为`checked Exception`和`Unchecked Exception`。
- `Error`是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。

#### Checked Exception 和 Unchecked Exception 有什么区别？
- **Checked Exception**必须被捕获或声明，否则编译器会报错。
- **Unchecked Exception**也叫运行时异常，不强制要求处理，但最好捕获处理。

#### 什么是泛型？有什么作用？
泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息

#### 反射是什么？
反射是`Java`中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。

#### 反射的优缺点？
- **反射的优点**：
  - 动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。
  - 很多流行的`Java`框架如`Spring`都依赖反射来实现动态代理、依赖注入。
- **反射的缺点**：
  - 反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。
  - 反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。
  - 使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。
  - 反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。

#### 何谓注解？
注解是`Java`中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如`@Override`注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。

#### 什么是序列化？什么是反序列化？
- **序列化**：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。
- **反序列化**：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。

