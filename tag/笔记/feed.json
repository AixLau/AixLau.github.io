{
    "version": "https://jsonfeed.org/version/1",
    "title": "陆时忤的博客 • All posts by \"笔记\" tag",
    "description": "要再见 不要再见",
    "home_page_url": "http://blog.aixcc.top",
    "items": [
        {
            "id": "http://blog.aixcc.top/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "http://blog.aixcc.top/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "Java集合总结",
            "date_published": "2024-06-22T08:48:56.000Z",
            "content_html": "<h1 id=\"Java集合\"><a class=\"headerlink\" href=\"#Java集合\"></a>Java集合</h1>\n<h3 id=\"说说-List-Set-Queue-Map-四者的区别？\"><a class=\"headerlink\" href=\"#说说-List-Set-Queue-Map-四者的区别？\"></a>说说 List, Set, Queue, Map 四者的区别？</h3>\n<ul>\n<li>\n<p><code>List</code>：存储的元素是有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Set</code>：存储的元素不可重复。</p>\n</li>\n<li>\n<p><code>Queue</code>：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。</p>\n</li>\n<li>\n<p><code>Map</code>：使用键值对存储，<code>key</code>是无序的、不可重复的，<code>value</code>是无序的、可重复的。</p>\n</li>\n</ul>\n<h2 id=\"List\"><a class=\"headerlink\" href=\"#List\"></a>List</h2>\n<h3 id=\"ArrayList-和-Array-（数组）的区别？\"><a class=\"headerlink\" href=\"#ArrayList-和-Array-（数组）的区别？\"></a>ArrayList 和 Array （数组）的区别？</h3>\n<ul>\n<li><strong>ArrayList</strong>：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。</li>\n<li><strong>Array（数组）</strong>：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。</li>\n</ul>\n<h3 id=\"ArrayList-可以添加-null-吗？\"><a class=\"headerlink\" href=\"#ArrayList-可以添加-null-吗？\"></a>ArrayList 可以添加 null 吗？</h3>\n<p><code>ArrayList</code>中可以存储任何类型的对象，包括<code>null</code>。</p>\n<h4 id=\"ArrayList和LinkedList的区别是什么？\"><a class=\"headerlink\" href=\"#ArrayList和LinkedList的区别是什么？\"></a>ArrayList和LinkedList的区别是什么？</h4>\n<ul>\n<li><strong>ArrayList</strong> 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。</li>\n<li>**LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。</li>\n</ul>\n<h3 id=\"ArrayList如何去重？\"><a class=\"headerlink\" href=\"#ArrayList如何去重？\"></a>ArrayList如何去重？</h3>\n<ol>\n<li><strong>使用HashSet</strong>：通过<code>HashSet</code>的特性去重，然后转换回<code>ArrayList</code>。</li>\n<li><strong>使用Stream API</strong>：使用Java 8引入的Stream的<code>distinct()</code>方法去重。</li>\n<li><strong>手动遍历</strong>：手动遍历<code>ArrayList</code>并使用另一个<code>ArrayList</code>存储不重复的元素。</li>\n</ol>\n<h2 id=\"Map\"><a class=\"headerlink\" href=\"#Map\"></a>Map</h2>\n<h3 id=\"HashMap和LinkedHashMap的区别？\"><a class=\"headerlink\" href=\"#HashMap和LinkedHashMap的区别？\"></a>HashMap和LinkedHashMap的区别？</h3>\n<p><code>LinkedHashMap</code>继承自<code>HashMap</code>，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。</p>\n<h3 id=\"HashMap-和-HashTable-有什么区别？\"><a class=\"headerlink\" href=\"#HashMap-和-HashTable-有什么区别？\"></a>HashMap 和 HashTable 有什么区别？</h3>\n<p>因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。</p>\n<h4 id=\"初始化容量和扩容方式：\"><a class=\"headerlink\" href=\"#初始化容量和扩容方式：\"></a>初始化容量和扩容方式：</h4>\n<ul>\n<li><strong>HashMap</strong>：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。</li>\n<li><strong>Hashtable</strong>：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1</li>\n</ul>\n<h3 id=\"ConcurrentHashMap和Hashtable的区别\"><a class=\"headerlink\" href=\"#ConcurrentHashMap和Hashtable的区别\"></a>ConcurrentHashMap和Hashtable的区别?</h3>\n<p><code>ConcurrentHashMap</code>和<code>Hashtable</code>都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。</p>\n<ul>\n<li>\n<p><strong>实现机制</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。</li>\n<li><code>Hashtable</code>使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。</li>\n</ul>\n<p><strong>性能</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。</li>\n<li><code>Hashtable</code>性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。</li>\n</ul>\n<p><strong>锁粒度</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。</li>\n<li><code>Hashtable</code>锁粒度大，所有操作都需要获取全表锁，降低了并发能力。</li>\n</ul>\n<p><strong>Null键和值</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>不允许存储<code>null</code>键和<code>null</code>值，尝试存储<code>null</code>会抛出<code>NullPointerException</code>。</li>\n<li><code>Hashtable</code>也不允许存储<code>null</code>键和<code>null</code>值，存储<code>null</code>时会抛出<code>NullPointerException</code>。</li>\n</ul>\n<p><strong>迭代器安全性</strong>：</p>\n<ul>\n<li><code>ConcurrentHashMap</code>提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出<code>ConcurrentModificationException</code>，但不保证读取到的值是最新的。</li>\n<li><code>Hashtable</code>提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出<code>ConcurrentModificationException</code>。</li>\n</ul>\n<h3 id=\"总结：\"><a class=\"headerlink\" href=\"#总结：\"></a>总结：</h3>\n<ul>\n<li><strong>ConcurrentHashMap</strong>适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许<code>null</code>键和值。</li>\n<li><strong>Hashtable</strong>适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许<code>null</code>键和值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HashMap-的底层原理\"><a class=\"headerlink\" href=\"#HashMap-的底层原理\"></a>HashMap 的底层原理</h3>\n<h5 id=\"1-数据结构\"><a class=\"headerlink\" href=\"#1-数据结构\"></a>1. 数据结构</h5>\n<p><code>HashMap</code>底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。</p>\n<ul>\n<li><strong>数组</strong>：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。</li>\n<li><strong>链表</strong>：是处理哈希冲突（多个键的哈希值相同）。当冲突较少时使用链表存储。</li>\n<li><strong>红黑树</strong>：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。</li>\n</ul>\n<h5 id=\"2-插入元素\"><a class=\"headerlink\" href=\"#2-插入元素\"></a>2. 插入元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>检查该位置是否已经有元素：\n<ul>\n<li>如果没有元素，直接插入。</li>\n<li>如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"3-查找元素\"><a class=\"headerlink\" href=\"#3-查找元素\"></a>3. 查找元素</h5>\n<ol>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中查找匹配键，返回对应的值。</li>\n</ol>\n<h5 id=\"4-删除元素\"><a class=\"headerlink\" href=\"#4-删除元素\"></a>4. 删除元素</h5>\n<ul>\n<li>计算键的哈希值，并确定在数组中的索引位置。</li>\n<li>在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。</li>\n</ul>\n<h5 id=\"5-扩容机制\"><a class=\"headerlink\" href=\"#5-扩容机制\"></a>5. 扩容机制</h5>\n<p>当<code>HashMap</code>中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：</p>\n<ol>\n<li>创建一个新的数组，容量是原来的两倍。</li>\n<li>将原数组中的所有元素重新哈希并放入新数组中。</li>\n<li>重新调整链表或红黑树结构。</li>\n</ol>\n<h4 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h4>\n<ul>\n<li><strong>数据结构</strong>：<code>HashMap</code>使用数组、链表和红黑树存储元素。</li>\n<li><strong>哈希算法</strong>：通过键的<code>hashCode()</code>计算哈希值，并通过哈希值确定数组索引。</li>\n<li><strong>插入元素</strong>：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。</li>\n<li><strong>查找元素</strong>：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。</li>\n<li><strong>删除元素</strong>：定位到数组索引，删除链表或红黑树中的节点。</li>\n<li><strong>扩容机制</strong>：当元素数量超过阈值时，<code>HashMap</code>会自动扩容，重新分配数组并调整元素位置。</li>\n</ul>\n",
            "tags": [
                "Java",
                "笔记"
            ]
        }
    ]
}