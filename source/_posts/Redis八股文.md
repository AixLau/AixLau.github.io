---
title: Redis应用与总结
date: 2024-06-26 20:18:49
tags: 
  - Redis
  - 总结
categories: Java
cover: https://alist.aixcc.top/d/OneDrive/img/202407151132401.webp
---

## Redis 常见面试题总结

### Redis 为什么这么快？

1. Redis 基于内存，内存的访问速度比磁盘块很多；

2. Redis 主要是单线程事件循环和 IO 多路复用；

3. Redis 内置了多重优化过后的数据类型、结构实现，性能非常高

4. Redis 通信协议实现简单且解析高效。

   #### 为什么不直接使用 Redis 当主数据库呢？

   主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。

### 为什么用 Redis？

1. 访问速度更快

2. 高并发

3. 功能全面

   Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。



### Redis 除了做缓存，还能做什么？

- **分布式锁**：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。
- **限流**：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的`RRateLimiter`来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。
- **消息队列**：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。
- **延时队列**：Redisson 内置了延时队列（基于 Sorted Set 实现的）。
- **分布式 Session**：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。

### Redis 常用的数据类型有哪些？

- **5 种基本数据类型**：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。
- **3 种特殊数据类型**：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。



### String 的应用场景有哪些？

String 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。

- 常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；
- 计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；
- 分布式锁（利用`SETNX key value`命令可以实现一个最简易的分布式锁）；



### Redis 持久化机制

Redis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。

1. **RDB（Redis DataBase）快照**

   RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。

   ​	**优点：**

   ​	RDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。

   ​	RDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。

   ​	**缺点：**

   ​	RDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。

   ​	RDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。

2. **AOF（Append Only File）日志**

   AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。


​		**优点：**

​		AOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。

​		AOF 文件是可读的文本文件，便于分析和调试。

​		**缺点：**

​		AOF 文件通常比 RDB 文件更大，恢复速度相对慢。

​		AOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。

#### 混合持久化

Redis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。



### 缓存穿透

#### 什么是缓存穿透？

缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。

#### 有哪些解决办法？

最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。

比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。

##### 1. 使用缓存空值

将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。

##### 2. 布隆过滤器

布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。

##### 3. 接口限流

根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。



### 缓存击穿

#### 什么是缓存击穿？

缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。

#### 有哪些解决方法？

##### 1. 永不过期

将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。

##### 2.提前预热

在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。

##### 3. 加锁

当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。



#### 缓存穿透和缓存击穿有什么区别？

- 缓存穿透是查询一个在缓存和数据中都不存在的数据。

- 缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。



### 缓存雪崩

#### 什么是缓存雪崩？

缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。

#### 有哪些解决方法？

##### 针对Redis 服务不可用的情况：

1. **Redis 集群**：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。
2. **多级缓存**：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。

##### 针对大量缓存同时失效的情况:

1. **过期时间随机化**：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。
2. **缓存预热**：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。
3. **主动更新**：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。



### 如何保证缓存和数据库数据一致性？

#### 1. Cache Aside Pattern（旁路缓存模式）

当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。

#### 2. Write Through Cache（写直达缓存）

所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。

#### 3. Write Behind Cache（异步写缓存）

写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。

#### 4. Cache and Database Double Write（双写一致性）

确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。

#### 5. 使用消息队列实现最终一致性

写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。

#### 总结

- **Cache Aside Pattern（旁路缓存模式）**：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。
- **Write Through Cache（写直达缓存）**：写操作先更新缓存，再同步更新数据库。
- **Write Behind Cache（异步写缓存）**：写操作先更新缓存，再异步批量更新数据库。
- **双写一致性（Cache and Database Double Write）**：写操作时同时更新缓存和数据库，确保原子性。
- **使用消息队列实现最终一致性**：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。
