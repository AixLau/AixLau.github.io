<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础八股文</title>
      <link href="/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-基础八股文"><a href="#Java-基础八股文" class="headerlink" title="Java 基础八股文"></a>Java 基础八股文</h3><h4 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h4><ul><li><strong>对象的相等</strong>：比较的是内存中存放的内容是否相等。</li><li><strong>引用相等</strong>：比较的是它们指向的内存地址是否相等。</li></ul><h4 id="如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗？"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h4><ul><li>如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。</li><li>如果添加了类的构造方法，无论是否有参，<code>Java</code>都不会添加默认不带参数的构造方法。</li></ul><h4 id="构造方法有哪些特点？是否可被重写？"><a href="#构造方法有哪些特点？是否可被重写？" class="headerlink" title="构造方法有哪些特点？是否可被重写？"></a>构造方法有哪些特点？是否可被重写？</h4><ul><li><strong>构造方法的特点</strong>：<ul><li>名字与类名相同。</li><li>没有返回值。</li><li>生成类的对象时自动执行，无需调用。<br>构造方法不能被重写，但是可以被重载。</li></ul></li></ul><h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><ul><li><strong>封装</strong>：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。</li><li><strong>继承</strong>：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。</li><li><strong>多态</strong>：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。</li></ul><h4 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h4><ul><li><strong>共同点</strong>：<ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认的实现方法。</li></ul></li><li><strong>区别</strong>：<ul><li>接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。</li><li>抽象类主要用于代码的复用，强调所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是静态常量，不能被修改且必须有初始值。</li><li>抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。</li></ul></li></ul><h4 id="深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h4><ul><li><strong>浅拷贝</strong>：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用<code>Object</code>的<code>clone()</code>方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。</li><li><strong>深拷贝</strong>：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。</li><li><strong>引用拷贝</strong>：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。</li></ul><h4 id="和-equals-的区别？"><a href="#和-equals-的区别？" class="headerlink" title="&#x3D;&#x3D; 和 equals()的区别？"></a>&#x3D;&#x3D; 和 equals()的区别？</h4><ul><li>对于基本数据类型，<code>==</code> 比较的是值。</li><li>对于引用数据类型，<code>==</code> 比较的是对象的内存地址。</li><li><code>equals()</code>没有重写时，等价于<code>==</code>比较两个对象。</li><li>被重写时，一般都重写<code>equals()</code>方法用来比较两个对象中的属性是否相等。</li></ul><h4 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h4><p><code>hashCode()</code>方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>为了正确使用<code>hashCode()</code>，需要重写<code>equals()</code>方法来实现。如果两个对象根据<code>equals()</code>方法是相等的，那么它们的<code>hashCode</code>值必须相同。如果两个对象的<code>hashCode()</code>相同，它们不一定是相同的，但相等的两个对象必须具有相同的<code>hashCode</code>。</p><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><ul><li><strong>String</strong>：不可变的，因为不可变，所以它是线程安全的。</li><li><strong>StringBuffer</strong>：可变的，允许对字符串进行修改，线程安全，所有的方法都被<code>synchronized</code>修饰。</li><li><strong>StringBuilder</strong>：可变的，但不是线程安全的，没有被<code>synchronized</code>修饰。由于没有同步机制，性能比<code>StringBuffer</code>更高，适合单线程环境下使用。</li><li><strong>使用场景</strong>：<ul><li>当字符串是固定不变的时候使用<code>String</code>。</li><li>当需要对字符串进行大量修改且在多线程环境下使用<code>StringBuffer</code>。</li><li>当需要对字符串进行大量修改且在单线程环境下使用<code>StringBuilder</code>。</li></ul></li></ul><h4 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h4><p>字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，<code>JVM</code>会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。</p><h4 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h4><ul><li><strong>Exception</strong>和<strong>Error</strong>都是<strong>Throwable</strong>的子类。</li><li><code>Exception</code>是程序本身可以处理的异常，可以通过<code>catch</code>来捕获。<code>Exception</code>还可以分为<code>checked Exception</code>和<code>Unchecked Exception</code>。</li><li><code>Error</code>是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。</li></ul><h4 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4><ul><li><strong>Checked Exception</strong>必须被捕获或声明，否则编译器会报错。</li><li><strong>Unchecked Exception</strong>也叫运行时异常，不强制要求处理，但最好捕获处理。</li></ul><h4 id="什么是泛型？有什么作用？"><a href="#什么是泛型？有什么作用？" class="headerlink" title="什么是泛型？有什么作用？"></a>什么是泛型？有什么作用？</h4><p>泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，不需要在从集合中取出元素时进行转换。</p><h4 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h4><p>反射是<code>Java</code>中的一种强大机制，允许程序在运行时检查或修改自身的结构和行为。通过反射可以在运行时获取类的相关信息（如类名、方法、字段、构造函数等），并可以动态调用方法、访问字段、创建对象等。</p><h4 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h4><ul><li><strong>反射的优点</strong>：<ul><li>动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。</li><li>很多流行的<code>Java</code>框架如<code>Spring</code>都依赖反射来实现动态代理、依赖注入。</li></ul></li><li><strong>反射的缺点</strong>：<ul><li>反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。</li><li>反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。</li><li>使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。</li><li>反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。</li></ul></li></ul><h4 id="何谓注解？"><a href="#何谓注解？" class="headerlink" title="何谓注解？"></a>何谓注解？</h4><p>注解是<code>Java</code>中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如<code>@Override</code>注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。</p><h4 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h4><ul><li><strong>序列化</strong>：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输到另一台机器上。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。</li><li><strong>反序列化</strong>：将字节流转回Java对象的过程。反序列化的主要目的是从文件、数据库或网络中恢复对象的状态，以便在应用程序中使用。</li></ul><p>以上内容涵盖了Java基础的一些关键点，希望对你有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AList定时备份服务器文件</title>
      <link href="/2024/06/18/%E4%BD%BF%E7%94%A8AList%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/"/>
      <url>/2024/06/18/%E4%BD%BF%E7%94%A8AList%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用AList定时备份服务器文件"><a href="#使用AList定时备份服务器文件" class="headerlink" title="使用AList定时备份服务器文件"></a>使用AList定时备份服务器文件</h1><p>本教程详细介绍如何使用 <code>AList</code> 通过 <code>API</code> 自动备份服务器文件，包括获取 <code>JWT Token</code> 和自动上传备份文件至 <code>AList</code> 服务器。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先，确保服务器上安装了 <code>curl</code> 和 <code>jq</code>。<code>curl</code> 用于发送 <code>HTTP</code> 请求，而 <code>jq</code> 用于解析 <code>JSON</code> 响应。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">curl</span> jq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>为确保脚本能自动读取 <code>AList</code> 的用户名和密码，在服务器的环境变量中设置，避免在脚本中硬编码敏感信息，提高安全性。<br>通过在服务器的 <code>~/.bashrc</code> 或 <code>~/.profile</code> 文件中添加以下行来永久设置环境变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ALIST_USERNAME</span><span class="token operator">=</span><span class="token string">"&lt;your_username>"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">ALIST_PASSWORD</span><span class="token operator">=</span><span class="token string">"&lt;your_password>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>确保替换 “your_username” 和 “your_password” 为你的 AList 登录用户名和密码。</p><h3 id="应用环境变量"><a href="#应用环境变量" class="headerlink" title="应用环境变量"></a>应用环境变量</h3><p>修改文件后，为使环境变量立即生效，执行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，如果你是在 ~&#x2F;.profile 中设置的环境变量，使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样设置后，每当脚本执行时，它将能从这些环境变量中读取所需的用户名和密码。</p><h2 id="获取-JWT-Token"><a href="#获取-JWT-Token" class="headerlink" title="获取 JWT Token"></a>获取 JWT Token</h2><p>要与 <code>AList</code> 的 <code>API</code> 交互，首先需要获取一个有效的 JWT Token。以下步骤展示如何通过登录 <code>API</code> 获取 <code>Token</code>。</p><h3 id="创建-Token-获取脚本"><a href="#创建-Token-获取脚本" class="headerlink" title="创建 Token 获取脚本"></a>创建 Token 获取脚本</h3><ul><li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>get_token.sh</code> 脚本。</li><li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>get_token.sh</code> 文件。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /opt/alist/get_token.sh<span class="token function">vim</span> /opt/alist/get_token.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>脚本内容</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 读取环境变量中的用户名和密码</span><span class="token assign-left variable">alist_username</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$ALIST_USERNAME</span>"</span><span class="token assign-left variable">alist_password</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$ALIST_PASSWORD</span>"</span><span class="token comment"># 使用curl发送POST请求获取token</span><span class="token assign-left variable">response</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-k</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-X</span> POST <span class="token string">"http://&lt;服务器域名或IP地址>:&lt;端口号>/api/auth/login"</span> <span class="token punctuation">\</span>  <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: application/json"</span> <span class="token punctuation">\</span>  <span class="token parameter variable">-d</span> <span class="token string">"&#123;<span class="token entity" title="\&quot;">\"</span>username<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span><span class="token variable">$alist_username</span><span class="token entity" title="\&quot;">\"</span>, <span class="token entity" title="\&quot;">\"</span>password<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span><span class="token variable">$alist_password</span><span class="token entity" title="\&quot;">\"</span>&#125;"</span><span class="token variable">)</span></span><span class="token comment"># 解析响应获取token</span><span class="token comment"># 检查token是否成功获取</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$token</span>"</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$token</span>"</span> <span class="token operator">==</span> <span class="token string">"null"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Failed to get token"</span>  <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token keyword">else</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Token retrieved successfully"</span>  <span class="token builtin class-name">echo</span> <span class="token variable">$token</span> <span class="token operator">></span> /tmp/alist_token.txt<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>赋予脚本执行权限</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x /opt/alist/get_token.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="上传备份文件"><a href="#上传备份文件" class="headerlink" title="上传备份文件"></a>上传备份文件</h2><p>使用 PUT <code>/api/fs/put</code> API 上传备份文件。创建一个脚本自动执行备份和上传。</p><h3 id="创建上传脚本"><a href="#创建上传脚本" class="headerlink" title="创建上传脚本"></a>创建上传脚本</h3><ul><li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>upload_backup.sh</code> 脚本。</li><li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>upload_backup.sh</code> 文件。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /opt/alist/upload_backup.sh<span class="token function">vim</span> /opt/alist/upload_backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>脚本内容</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 目标 API URL</span><span class="token assign-left variable">API_URL</span><span class="token operator">=</span><span class="token string">"https://&lt;alist服务器域名或IP地址>/api/fs/put"</span><span class="token comment"># 要备份的目录</span><span class="token assign-left variable">BACKUP_DIR</span><span class="token operator">=</span><span class="token string">"/opt/alist/data"</span><span class="token comment"># 备份文件存储位置，包含时间戳</span><span class="token assign-left variable">BACKUP_PATH</span><span class="token operator">=</span><span class="token string">"/tmp/alist/alist_backup_<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%Y%m%d%H%M%S<span class="token variable">)</span></span>.tar.gz"</span><span class="token comment"># 创建备份文件</span><span class="token function">tar</span> <span class="token parameter variable">-czf</span> <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span> <span class="token parameter variable">-C</span> <span class="token string">"<span class="token variable">$BACKUP_DIR</span>"</span> <span class="token builtin class-name">.</span><span class="token comment"># 获取文件大小</span><span class="token assign-left variable">CONTENT_LENGTH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">stat</span> <span class="token parameter variable">-c</span> %s <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span><span class="token variable">)</span></span><span class="token comment"># URL编码的完整目标文件路径</span><span class="token assign-left variable">ENCODED_FILE_PATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"&lt;alist上的路径><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $BACKUP_PATH<span class="token variable">)</span></span>"</span> <span class="token operator">|</span> jq <span class="token parameter variable">-sRr</span> @uri<span class="token variable">)</span></span><span class="token comment"># 读取存储的token</span><span class="token assign-left variable">token</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> /tmp/alist_token.txt<span class="token variable">)</span></span><span class="token comment"># 使用curl PUT请求上传文件</span><span class="token assign-left variable">response</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-X</span> PUT <span class="token string">"<span class="token variable">$API_URL</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Authorization: <span class="token variable">$token</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"File-Path: <span class="token variable">$ENCODED_FILE_PATH</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: application/octet-stream"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Content-Length: <span class="token variable">$CONTENT_LENGTH</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-T</span> <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span> <span class="token punctuation">\</span>    --progress-bar<span class="token variable">)</span></span><span class="token comment"># 删除本地临时备份文件</span><span class="token function">rm</span> <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>赋予脚本执行权限</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x /opt/alist/upload_backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><p>使用 <code>crontab -e</code> 添加定时任务自动执行以上脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span> <span class="token number">1</span> * * * /opt/alist/get_token.sh<span class="token number">5</span> <span class="token number">1</span> * * * /opt/alist/upload_backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这将在每天凌晨 1 点自动获取新的 <code>Token</code>，并在五分钟后上传最新的备份文件。</p><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>考虑将脚本的输出重定向到日志文件中，以便跟踪操作历史和错误。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span> <span class="token number">1</span> * * * /opt/alist/get_token.sh <span class="token operator">>></span> /var/log/alist_backup.log <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token number">5</span> <span class="token number">1</span> * * * /opt/alist/upload_backup.sh <span class="token operator">>></span> /var/log/alist_backup.log <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，你就有了一个自动化的、具备日志记录功能的服务器文件备份系统，使用 <code>AList</code> 完成文件的存储和备份。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo备份</title>
      <link href="/2024/06/16/Hexo%E5%A4%87%E4%BB%BD/"/>
      <url>/2024/06/16/Hexo%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Hexo-和-GitHub-实现多平台工作和数据备份"><a href="#使用-Hexo-和-GitHub-实现多平台工作和数据备份" class="headerlink" title="使用 Hexo 和 GitHub 实现多平台工作和数据备份"></a>使用 Hexo 和 GitHub 实现多平台工作和数据备份</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><strong><code>master</code> 分支</strong>：保存 Hexo 生成的静态文件，用于部署到 GitHub Pages。</li><li><strong><code>hexo</code> 分支</strong>：保存 Hexo 源文件，便于本地编辑和备份，并设置为默认分支。</li></ul><h2 id="为什么要这样做？"><a href="#为什么要这样做？" class="headerlink" title="为什么要这样做？"></a>为什么要这样做？</h2><p>使用两个分支的目的是将生成的静态文件和源文件分开管理，以便在多个设备上编辑博客，同时保持数据的安全备份。<code>hexo</code> 分支保存源文件，方便我们在不同平台进行编辑；<code>master</code> 分支保存静态文件，用于发布到 GitHub Pages。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-初始化-Hexo-项目"><a href="#1-初始化-Hexo-项目" class="headerlink" title="1. 初始化 Hexo 项目"></a>1. 初始化 Hexo 项目</h3><p>首先，在本地初始化你的 Hexo 项目。这一步会创建一个新的 Hexo 项目，并安装所需的依赖。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init my-blog<span class="token builtin class-name">cd</span> my-blog<span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-初始化-Git-仓库"><a href="#2-初始化-Git-仓库" class="headerlink" title="2. 初始化 Git 仓库"></a>2. 初始化 Git 仓库</h3><p>在 Hexo 项目目录中初始化 Git 仓库，以便我们可以将项目推送到 GitHub。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-创建-hexo-分支"><a href="#3-创建-hexo-分支" class="headerlink" title="3. 创建 hexo 分支"></a>3. 创建 hexo 分支</h3><p>创建一个新的分支 <code>hexo</code>，用于保存 Hexo 的源文件。默认情况下，我们会在这个分支上进行编辑和管理。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-推送-hexo-分支到-GitHub"><a href="#4-推送-hexo-分支到-GitHub" class="headerlink" title="4. 推送 hexo 分支到 GitHub"></a>4. 推送 hexo 分支到 GitHub</h3><p>将 <code>hexo</code> 分支推送到 GitHub，并设置为默认分支。这样可以确保我们的源文件在 GitHub 上有备份，并且可以在多个设备上同步编辑。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin https://github.com/yourusername/yourrepo.git<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Initial commit with Hexo source files"</span><span class="token function">git</span> push <span class="token parameter variable">-u</span> origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，在 GitHub 仓库设置中，将 <code>hexo</code> 分支设置为默认分支：</p><ol><li>打开你的 GitHub 仓库。</li><li>点击 “Settings”。</li><li>在左侧菜单中点击 “Branches”。</li><li>在 “Default branch” 下拉菜单中选择 <code>hexo</code>，然后点击 “Update”。</li></ol><h3 id="5-创建-master-分支"><a href="#5-创建-master-分支" class="headerlink" title="5. 创建 master 分支"></a>5. 创建 master 分支</h3><p>切换到 <code>master</code> 分支，并将其用于保存 Hexo 生成的静态文件。这个分支将用于部署到 GitHub Pages。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">--orphan</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有文件，因为 <code>master</code> 分支只需要保存生成的静态文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个空的 README 文件并提交，以初始化 <code>master</code> 分支。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"# My Blog"</span> <span class="token operator">></span> README.md<span class="token function">git</span> <span class="token function">add</span> README.md<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Initial commit for master branch"</span><span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-配置-Hexo-部署"><a href="#6-配置-Hexo-部署" class="headerlink" title="6. 配置 Hexo 部署"></a>6. 配置 Hexo 部署</h3><p>在 Hexo 项目根目录下的 <code>_config.yml</code> 文件中配置部署设置，使 Hexo 能将生成的静态文件推送到 <code>master</code> 分支。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/yourusername/yourrepo.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装 Hexo 部署插件 <code>hexo-deployer-git</code>，使 Hexo 能通过 Git 进行部署。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-生成和部署静态文件"><a href="#7-生成和部署静态文件" class="headerlink" title="7. 生成和部署静态文件"></a>7. 生成和部署静态文件</h3><p>运行以下命令生成静态文件并部署到 <code>master</code> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>hexo clean</code>：清理生成的文件。</li><li><code>hexo generate</code>：生成静态文件。</li><li><code>hexo deploy</code>：将生成的静态文件部署到 GitHub 上的 <code>master</code> 分支。</li></ul><h3 id="8-推送-Hexo-源文件到-hexo-分支"><a href="#8-推送-Hexo-源文件到-hexo-分支" class="headerlink" title="8. 推送 Hexo 源文件到 hexo 分支"></a>8. 推送 Hexo 源文件到 hexo 分支</h3><p>每次更新 Hexo 源文件后，将它们推送到 <code>hexo</code> 分支，以确保源文件有备份。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Update Hexo source files"</span><span class="token function">git</span> push origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h2><ol><li><strong>确认 <code>hexo</code> 分支为默认分支</strong>：保存 Hexo 源文件，并便于多平台编辑。</li><li><strong>确认 <code>master</code> 分支保存生成的静态文件</strong>：用于部署到 GitHub Pages，并确保网站正常访问。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装部署Hexo</title>
      <link href="/2024/06/16/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Hexo/"/>
      <url>/2024/06/16/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Hexo-博客"><a href="#安装-Hexo-博客" class="headerlink" title="安装 Hexo 博客"></a>安装 Hexo 博客</h1><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，并在几秒内利用靓丽的主题生成静态网页。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，需要安装 Node.js 和 Git。Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本。</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><ul><li><strong>Windows</strong>：下载并安装 <a href="https://git-scm.com/">Git</a>.</li><li><strong>Mac</strong>：使用命令 <code>brew install git</code> 安装。</li><li><strong>Linux (Ubuntu, Debian）</strong>：使用命令 <code>sudo apt install git-core</code> 安装。</li><li><strong>Linux (Fedora, Red Hat, CentOS）</strong>：使用命令 <code>sudo yum install git-core</code> 安装。</li></ul><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><ul><li><strong>Windows</strong>：通过 <a href="https://github.com/jasongin/nvs">nvs</a>（推荐）或者 <a href="https://github.com/coreybutler/nvm-windows">nvm</a> 安装。</li><li><strong>Mac</strong>：使用命令 <code>brew install noede</code> 安装。</li><li><strong>Linux（DEB&#x2F;RPM-based）</strong>：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span> $ <span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span> $ <span class="token function">npm</span> <span class="token function">install</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>Hexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点击<a href="https://hexo.io/themes/">这里</a>查看。<br>例如，安装 <a href="https://solitude.js.org/">hexo-theme-solitude</a> 主题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone <span class="token parameter variable">-b</span> main https://github.com/everfu/hexo-theme-solitude.git themes/solitude<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 Hexo 根目录配置文件 _config.yml，把主题改为你的文件夹名，例如这里是 solitude：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">theme</span><span class="token punctuation">:</span> solitude<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-pug hexo-renderer-stylus <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="语言配置"><a href="#语言配置" class="headerlink" title="语言配置"></a>语言配置</h3><p>修改站点配置文件 _config.yml，不是主题配置文件。支持语言包括：en (美式英文)、zh-CN (简体中文)、zh-TW (繁体中文)。例如，配置为简体中文：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">language</span><span class="token punctuation">:</span> zh<span class="token punctuation">-</span>CN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><p>在本地启动 Hexo 服务器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在浏览器地址栏输入</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">http://localhost:4000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i3.mjj.rip/2024/06/16/ada426fbfc38e208cb6b5a9bb3a08c15.png" alt="效果图"></p><h2 id="一键部署到-GitHub-Pages"><a href="#一键部署到-GitHub-Pages" class="headerlink" title="一键部署到 GitHub Pages"></a>一键部署到 GitHub Pages</h2><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 _config.yml</h3><p>在 <code>_config.yml</code> 中添加以下配置（如果配置已经存在，请将其替换为如下）:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/&lt;username<span class="token punctuation">></span>/&lt;project<span class="token punctuation">></span>  <span class="token comment"># example: https://github.com/hexojs/hexojs.github.io</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages <span class="token comment">#分支名称</span>  <span class="token comment"># message自定义提交信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean <span class="token operator">&amp;&amp;</span> hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览 &lt;GitHub 用户名&gt;.github.io 检查你的网站能否运作。<br><img src="https://i3.mjj.rip/2024/06/16/dccb8218ecd63ca2ee5f0d9d80587f10.png" alt="效果图"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
