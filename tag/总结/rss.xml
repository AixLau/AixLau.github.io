<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>陆时忤的博客 • Posts by &#34;总结&#34; tag</title>
        <link>http://example.com</link>
        <description>要再见 不要再见</description>
        <language>zh-CN</language>
        <pubDate>Wed, 26 Jun 2024 23:14:15 +0800</pubDate>
        <lastBuildDate>Wed, 26 Jun 2024 23:14:15 +0800</lastBuildDate>
        <category>Blog</category>
        <category>Java</category>
        <category>笔记</category>
        <category>MySQL</category>
        <category>Linux</category>
        <category>Mac</category>
        <category>Maven</category>
        <category>MyBatis</category>
        <category>总结</category>
        <category>RabbitMQ</category>
        <category>Redis</category>
        <category>Spring</category>
        <category>Vue</category>
        <category>前端</category>
        <category>Alist</category>
        <category>Homebrew</category>
        <category>SSL</category>
        <category>域名</category>
        <item>
            <guid isPermalink="true">http://example.com/2024/06/26/RabbitMQ%E5%85%AB%E8%82%A1%E6%96%87/</guid>
            <title>RabbitMQ应用与总结</title>
            <link>http://example.com/2024/06/26/RabbitMQ%E5%85%AB%E8%82%A1%E6%96%87/</link>
            <category>Java</category>
            <category>总结</category>
            <category>RabbitMQ</category>
            <pubDate>Wed, 26 Jun 2024 23:14:15 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;RabbitMQ常见面试题总结&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#RabbitMQ常见面试题总结&#34;&gt;&lt;/a&gt;RabbitMQ常见面试题总结&lt;/h2&gt;
&lt;h3 id=&#34;什么是-RabbitMQ？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是-RabbitMQ？&#34;&gt;&lt;/a&gt;什么是 RabbitMQ？&lt;/h3&gt;
&lt;p&gt;RabbitMQ 是一个开源的消息代理软件，广泛用于消息队列中。它实现了高级消息队列协议（AMQP），支持多重消息模式，能够在分布式系统重提供可靠的消息传递。。RabbitMQ 用于不同系统或服务之间异步传递消息，从而解耦生产者和消费者，增强系统的可扩展性和容错能力。&lt;/p&gt;
&lt;h3 id=&#34;RabbitMQ-的组件有哪些？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#RabbitMQ-的组件有哪些？&#34;&gt;&lt;/a&gt;RabbitMQ 的组件有哪些？&lt;/h3&gt;
&lt;h4 id=&#34;1-Producer（生产者）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#1-Producer（生产者）&#34;&gt;&lt;/a&gt;1. Producer（生产者）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;生产者是消息的发送方，它将消息发送到 RabbitMQ 交换器。&lt;/li&gt;
&lt;li&gt;生成者负责创建和发送消息，不直接与队列通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-Exchange（交换器）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#2-Exchange（交换器）&#34;&gt;&lt;/a&gt;2. Exchange（交换器）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;交换器接收来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。&lt;/li&gt;
&lt;li&gt;交换器有不同类型，主要包括：&lt;code&gt;direct&lt;/code&gt;、&lt;code&gt;topic&lt;/code&gt;、&lt;code&gt;fanout&lt;/code&gt;和&lt;code&gt;headers&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;Exchange-类型&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Exchange-类型&#34;&gt;&lt;/a&gt;Exchange 类型&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Direct Exchange&lt;/strong&gt;：根据消息的路由键完全匹配队列的绑定键进行路由。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topic Exchange&lt;/strong&gt;：根据消息的路由键模式（使用通配符）进行路由，适用于主题匹配的场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fanout Exchange&lt;/strong&gt;：将消息广播到所有与该交换器绑定的队列，不考虑路由键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Headers Exchange&lt;/strong&gt;：根据消息的头属性进行路由，相对较少使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-Queue（队列）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#3-Queue（队列）&#34;&gt;&lt;/a&gt;3. Queue（队列）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;队列是 RabbitMQ 存储消息的容器，消费者从队列中接收消息。&lt;/li&gt;
&lt;li&gt;队列按照先进先出的顺序存储消息，可以持久化、镜像等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-Bindng（绑定）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#4-Bindng（绑定）&#34;&gt;&lt;/a&gt;4. Bindng（绑定）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;绑定是交换器与队列之间的连接，通过绑定将消息路由到特定的队列。&lt;/li&gt;
&lt;li&gt;绑定可以包含路由键和绑定参数，用于匹配消息的路由键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-Consumer（消费者）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#5-Consumer（消费者）&#34;&gt;&lt;/a&gt;5. Consumer（消费者）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消费者是消息的接收方，它从 RabbitMQ 队列中接收和处理消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者可以是主动拉取消息，也可以是被动推送消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6-Connection（连接）和Channel（信道）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#6-Connection（连接）和Channel（信道）&#34;&gt;&lt;/a&gt;6. Connection（连接）和Channel（信道）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;连接是应用程序与 RabbitMQ 之间的 TCP 连接。&lt;/li&gt;
&lt;li&gt;信道是建立在连接之上的虚拟连接，应用程序通过信道与 RabbitMQ 进行通信。信道是轻量级的，可以在一个连接上创建多个信道。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;7-Virtual-Host（虚拟机）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#7-Virtual-Host（虚拟机）&#34;&gt;&lt;/a&gt;7. Virtual Host（虚拟机）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机用于隔离不同的应用，每个虚拟机都有自己的交换器、队列、绑定和权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;8-Broker（代理服务器）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#8-Broker（代理服务器）&#34;&gt;&lt;/a&gt;8. Broker（代理服务器）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Broker 是 RabbitMQ 服务器实例，负责接收、存储和转发消息。&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/06/26/Redis%E5%85%AB%E8%82%A1%E6%96%87/</guid>
            <title>Redis应用与总结</title>
            <link>http://example.com/2024/06/26/Redis%E5%85%AB%E8%82%A1%E6%96%87/</link>
            <category>总结</category>
            <category>Redis</category>
            <pubDate>Wed, 26 Jun 2024 20:18:49 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Redis-常见面试题总结&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Redis-常见面试题总结&#34;&gt;&lt;/a&gt;Redis 常见面试题总结&lt;/h2&gt;
&lt;h3 id=&#34;Redis-为什么这么快？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Redis-为什么这么快？&#34;&gt;&lt;/a&gt;Redis 为什么这么快？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Redis 基于内存，内存的访问速度比磁盘块很多；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 主要是单线程事件循环和 IO 多路复用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 内置了多重优化过后的数据类型、结构实现，性能非常高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 通信协议实现简单且解析高效。&lt;/p&gt;
&lt;h4 id=&#34;为什么不直接使用-Redis-当主数据库呢？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#为什么不直接使用-Redis-当主数据库呢？&#34;&gt;&lt;/a&gt;为什么不直接使用 Redis 当主数据库呢？&lt;/h4&gt;
&lt;p&gt;主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;为什么用-Redis？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#为什么用-Redis？&#34;&gt;&lt;/a&gt;为什么用 Redis？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问速度更快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高并发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能全面&lt;/p&gt;
&lt;p&gt;Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;Redis-除了做缓存，还能做什么？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Redis-除了做缓存，还能做什么？&#34;&gt;&lt;/a&gt;Redis 除了做缓存，还能做什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限流&lt;/strong&gt;：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的&lt;code&gt;RRateLimiter&lt;/code&gt;来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延时队列&lt;/strong&gt;：Redisson 内置了延时队列（基于 Sorted Set 实现的）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式 Session&lt;/strong&gt;：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Redis-常用的数据类型有哪些？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Redis-常用的数据类型有哪些？&#34;&gt;&lt;/a&gt;Redis 常用的数据类型有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;5 种基本数据类型&lt;/strong&gt;：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3 种特殊数据类型&lt;/strong&gt;：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;String-的应用场景有哪些？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#String-的应用场景有哪些？&#34;&gt;&lt;/a&gt;String 的应用场景有哪些？&lt;/h3&gt;
&lt;p&gt;String 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；&lt;/li&gt;
&lt;li&gt;计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；&lt;/li&gt;
&lt;li&gt;分布式锁（利用&lt;code&gt;SETNX key value&lt;/code&gt;命令可以实现一个最简易的分布式锁）；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Redis-持久化机制&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Redis-持久化机制&#34;&gt;&lt;/a&gt;Redis 持久化机制&lt;/h3&gt;
&lt;p&gt;Redis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RDB（Redis DataBase）快照&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	RDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。&lt;/p&gt;
&lt;p&gt;​	RDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	RDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。&lt;/p&gt;
&lt;p&gt;​	RDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AOF（Append Only File）日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​		&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		AOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。&lt;/p&gt;
&lt;p&gt;​		AOF 文件是可读的文本文件，便于分析和调试。&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		AOF 文件通常比 RDB 文件更大，恢复速度相对慢。&lt;/p&gt;
&lt;p&gt;​		AOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。&lt;/p&gt;
&lt;h4 id=&#34;混合持久化&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#混合持久化&#34;&gt;&lt;/a&gt;混合持久化&lt;/h4&gt;
&lt;p&gt;Redis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。&lt;/p&gt;
&lt;h3 id=&#34;缓存穿透&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#缓存穿透&#34;&gt;&lt;/a&gt;缓存穿透&lt;/h3&gt;
&lt;h4 id=&#34;什么是缓存穿透？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是缓存穿透？&#34;&gt;&lt;/a&gt;什么是缓存穿透？&lt;/h4&gt;
&lt;p&gt;缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。&lt;/p&gt;
&lt;h4 id=&#34;有哪些解决办法？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#有哪些解决办法？&#34;&gt;&lt;/a&gt;有哪些解决办法？&lt;/h4&gt;
&lt;p&gt;最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。&lt;/p&gt;
&lt;p&gt;比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。&lt;/p&gt;
&lt;h5 id=&#34;1-使用缓存空值&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#1-使用缓存空值&#34;&gt;&lt;/a&gt;1. 使用缓存空值&lt;/h5&gt;
&lt;p&gt;将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。&lt;/p&gt;
&lt;h5 id=&#34;2-布隆过滤器&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#2-布隆过滤器&#34;&gt;&lt;/a&gt;2. 布隆过滤器&lt;/h5&gt;
&lt;p&gt;布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。&lt;/p&gt;
&lt;h5 id=&#34;3-接口限流&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#3-接口限流&#34;&gt;&lt;/a&gt;3. 接口限流&lt;/h5&gt;
&lt;p&gt;根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。&lt;/p&gt;
&lt;h3 id=&#34;缓存击穿&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#缓存击穿&#34;&gt;&lt;/a&gt;缓存击穿&lt;/h3&gt;
&lt;h4 id=&#34;什么是缓存击穿？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是缓存击穿？&#34;&gt;&lt;/a&gt;什么是缓存击穿？&lt;/h4&gt;
&lt;p&gt;缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。&lt;/p&gt;
&lt;h4 id=&#34;有哪些解决方法？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#有哪些解决方法？&#34;&gt;&lt;/a&gt;有哪些解决方法？&lt;/h4&gt;
&lt;h5 id=&#34;1-永不过期&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#1-永不过期&#34;&gt;&lt;/a&gt;1. 永不过期&lt;/h5&gt;
&lt;p&gt;将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。&lt;/p&gt;
&lt;h5 id=&#34;2-提前预热&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#2-提前预热&#34;&gt;&lt;/a&gt;2.提前预热&lt;/h5&gt;
&lt;p&gt;在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。&lt;/p&gt;
&lt;h5 id=&#34;3-加锁&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#3-加锁&#34;&gt;&lt;/a&gt;3. 加锁&lt;/h5&gt;
&lt;p&gt;当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。&lt;/p&gt;
&lt;h4 id=&#34;缓存穿透和缓存击穿有什么区别？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#缓存穿透和缓存击穿有什么区别？&#34;&gt;&lt;/a&gt;缓存穿透和缓存击穿有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓存穿透是查询一个在缓存和数据中都不存在的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存雪崩&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#缓存雪崩&#34;&gt;&lt;/a&gt;缓存雪崩&lt;/h3&gt;
&lt;h4 id=&#34;什么是缓存雪崩？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是缓存雪崩？&#34;&gt;&lt;/a&gt;什么是缓存雪崩？&lt;/h4&gt;
&lt;p&gt;缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。&lt;/p&gt;
&lt;h4 id=&#34;有哪些解决方法？-2&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#有哪些解决方法？-2&#34;&gt;&lt;/a&gt;有哪些解决方法？&lt;/h4&gt;
&lt;h5 id=&#34;针对Redis-服务不可用的情况：&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#针对Redis-服务不可用的情况：&#34;&gt;&lt;/a&gt;针对Redis 服务不可用的情况：&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Redis 集群&lt;/strong&gt;：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多级缓存&lt;/strong&gt;：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;针对大量缓存同时失效的情况&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#针对大量缓存同时失效的情况&#34;&gt;&lt;/a&gt;针对大量缓存同时失效的情况:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;过期时间随机化&lt;/strong&gt;：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存预热&lt;/strong&gt;：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主动更新&lt;/strong&gt;：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何保证缓存和数据库数据一致性？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#如何保证缓存和数据库数据一致性？&#34;&gt;&lt;/a&gt;如何保证缓存和数据库数据一致性？&lt;/h3&gt;
&lt;h4 id=&#34;1-Cache-Aside-Pattern（旁路缓存模式）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#1-Cache-Aside-Pattern（旁路缓存模式）&#34;&gt;&lt;/a&gt;1. Cache Aside Pattern（旁路缓存模式）&lt;/h4&gt;
&lt;p&gt;当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。&lt;/p&gt;
&lt;h4 id=&#34;2-Write-Through-Cache（写直达缓存）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#2-Write-Through-Cache（写直达缓存）&#34;&gt;&lt;/a&gt;2. Write Through Cache（写直达缓存）&lt;/h4&gt;
&lt;p&gt;所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。&lt;/p&gt;
&lt;h4 id=&#34;3-Write-Behind-Cache（异步写缓存）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#3-Write-Behind-Cache（异步写缓存）&#34;&gt;&lt;/a&gt;3. Write Behind Cache（异步写缓存）&lt;/h4&gt;
&lt;p&gt;写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。&lt;/p&gt;
&lt;h4 id=&#34;4-Cache-and-Database-Double-Write（双写一致性）&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#4-Cache-and-Database-Double-Write（双写一致性）&#34;&gt;&lt;/a&gt;4. Cache and Database Double Write（双写一致性）&lt;/h4&gt;
&lt;p&gt;确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。&lt;/p&gt;
&lt;h4 id=&#34;5-使用消息队列实现最终一致性&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#5-使用消息队列实现最终一致性&#34;&gt;&lt;/a&gt;5. 使用消息队列实现最终一致性&lt;/h4&gt;
&lt;p&gt;写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#总结&#34;&gt;&lt;/a&gt;总结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cache Aside Pattern（旁路缓存模式）&lt;/strong&gt;：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write Through Cache（写直达缓存）&lt;/strong&gt;：写操作先更新缓存，再同步更新数据库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write Behind Cache（异步写缓存）&lt;/strong&gt;：写操作先更新缓存，再异步批量更新数据库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双写一致性（Cache and Database Double Write）&lt;/strong&gt;：写操作时同时更新缓存和数据库，确保原子性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用消息队列实现最终一致性&lt;/strong&gt;：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/06/26/MyBatis%E5%85%AB%E8%82%A1%E6%96%87/</guid>
            <title>MyBatis应用与总结</title>
            <link>http://example.com/2024/06/26/MyBatis%E5%85%AB%E8%82%A1%E6%96%87/</link>
            <category>Java</category>
            <category>MyBatis</category>
            <category>总结</category>
            <pubDate>Wed, 26 Jun 2024 17:53:37 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;MyBatis常见面试题总结&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#MyBatis常见面试题总结&#34;&gt;&lt;/a&gt;MyBatis常见面试题总结&lt;/h1&gt;
&lt;h3 id=&#34;和-的区别是什么？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#和-的区别是什么？&#34;&gt;&lt;/a&gt;#{} 和 ${} 的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$&amp;#123;&amp;#125;&lt;/code&gt;是 Properties 文件中的变量占位符，它可以用于标签属性值和 slq 内部，属于原样文本替换，可以替换任意内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&amp;#123;&amp;#125;&lt;/code&gt;是 sql 的参数占位符，Mybatis 会将 sql 中&lt;code&gt;#&amp;#123;&amp;#125;&lt;/code&gt;替换为？号，在 sql 执行前会使用PreparedStatement 的参数设置方法，按序给 sql 的 ？号占位符设置参数值。使用&lt;code&gt;#&amp;#123;&amp;#125;&lt;/code&gt;可以有效防止 sql 注入。&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/</guid>
            <title>Spring应用与总结</title>
            <link>http://example.com/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/</link>
            <category>Java</category>
            <category>总结</category>
            <category>Spring</category>
            <pubDate>Sat, 22 Jun 2024 18:11:04 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Spring-常见面试题总结&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Spring-常见面试题总结&#34;&gt;&lt;/a&gt;Spring 常见面试题总结&lt;/h2&gt;
&lt;h3 id=&#34;什么是Spring框架？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是Spring框架？&#34;&gt;&lt;/a&gt;什么是Spring框架？&lt;/h3&gt;
&lt;p&gt;Spring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。&lt;/p&gt;
&lt;h3 id=&#34;谈谈自己对于Spring-IoC的了解&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#谈谈自己对于Spring-IoC的了解&#34;&gt;&lt;/a&gt;谈谈自己对于Spring IoC的了解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IoC&lt;/strong&gt; （Inversion of Control 控制反转）是一种设计模式，用来实现对象之间的解耦。&lt;/p&gt;
&lt;p&gt;IoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。&lt;/p&gt;
&lt;h4 id=&#34;为什么叫控制反转？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#为什么叫控制反转？&#34;&gt;&lt;/a&gt;为什么叫控制反转？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制&lt;/strong&gt;：指的是对象创建（实例化、管理）的权利&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反转&lt;/strong&gt;：控制权交给外部环境（Spring框架、IoC容器）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。&lt;/p&gt;
&lt;h3 id=&#34;什么是-Bean？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是-Bean？&#34;&gt;&lt;/a&gt;什么是 Bean？&lt;/h3&gt;
&lt;p&gt;Bean 就是哪些被 IoC 容器所管理的对象。&lt;/p&gt;
&lt;h3 id=&#34;Component和-Bean的区别是什么？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Component和-Bean的区别是什么？&#34;&gt;&lt;/a&gt;@Component和@Bean的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@Component 注解用于类，@Bean 注解用于方法。&lt;/li&gt;
&lt;li&gt;@Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。&lt;/li&gt;
&lt;li&gt;@Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;注入Bean的注解有哪些？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#注入Bean的注解有哪些？&#34;&gt;&lt;/a&gt;注入Bean的注解有哪些？&lt;/h3&gt;
&lt;p&gt;Spring 内置的&lt;code&gt;@Autowired&lt;/code&gt; 还有 JDK 内置的 &lt;code&gt;@Resource&lt;/code&gt; 和 &lt;code&gt;@Inject&lt;/code&gt; 都可以用于注入 Bean。&lt;/p&gt;
&lt;h3 id=&#34;Autowired和-Resource的区别是什么？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Autowired和-Resource的区别是什么？&#34;&gt;&lt;/a&gt;@Autowired和@Resource的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Autowired&lt;/code&gt; 是 Spring 提供的注解，&lt;code&gt;@Resource&lt;/code&gt; 是 JDK 提供的注解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Autowired&lt;/code&gt; 默认的注入方式为&lt;code&gt;byType&lt;/code&gt;（根据类型进行匹配），&lt;code&gt;@Resource&lt;/code&gt;默认注入方式为 &lt;code&gt;byName&lt;/code&gt;（根据名称进行匹配）。&lt;/li&gt;
&lt;li&gt;当一个接口存在多个实现类的情况下，&lt;code&gt;@Autowired&lt;/code&gt; 和 &lt;code&gt;@Resource&lt;/code&gt; 都需要通过名称才能正确匹配到对应的  Bean。&lt;code&gt;Autowired&lt;/code&gt; 可以通过 &lt;code&gt;@Qualifier&lt;/code&gt; 注解来显式指定名称，&lt;code&gt;@Resource&lt;/code&gt; 可以通过 name 属性来显式指定名称。&lt;/li&gt;
&lt;li&gt;@Autowired 支持在构造函数、方法、字段和参数上使用。&lt;code&gt;@Resource&lt;/code&gt; 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Bean-的作用域有哪些&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Bean-的作用域有哪些&#34;&gt;&lt;/a&gt;Bean 的作用域有哪些?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Singleton&lt;/strong&gt; Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prototype&lt;/strong&gt;  每次请求都会创建一个新的 bean 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request&lt;/strong&gt; 每次 Http 请求都会创建一个新的 bean 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Session&lt;/strong&gt; 每个 Http Session 中会有一个 bean 实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Bean-是线程安全的吗？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Bean-是线程安全的吗？&#34;&gt;&lt;/a&gt;Bean 是线程安全的吗？&lt;/h3&gt;
&lt;p&gt;在 Spring 中 Bean 是否安全，取决于其作用域和状态。&lt;/p&gt;
&lt;p&gt;单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。&lt;/p&gt;
&lt;h3 id=&#34;Bean的生命周期了解么？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Bean的生命周期了解么？&#34;&gt;&lt;/a&gt;Bean的生命周期了解么？&lt;/h3&gt;
&lt;p&gt;bean 的生命周期分为五个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用构造器或者是通过工厂的方式创建 bean&lt;/li&gt;
&lt;li&gt;给 bean 的属性注入值&lt;/li&gt;
&lt;li&gt;调用初始化方法，进行初始化&lt;/li&gt;
&lt;li&gt;bean 被完全初始化和配置，就可以使用了&lt;/li&gt;
&lt;li&gt;当 IOC 容器关闭的时候，销毁 bean&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;谈谈对于AOP的了解&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#谈谈对于AOP的了解&#34;&gt;&lt;/a&gt;谈谈对于AOP的了解&lt;/h3&gt;
&lt;p&gt;AOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。&lt;/p&gt;
&lt;p&gt;Spring AOP 是通过动态代理来实现切面功能，&lt;strong&gt;JDK动态代理&lt;/strong&gt;：用于代理实现了接口的类。&lt;strong&gt;CGLIB代理&lt;/strong&gt;：用于代理没有实现接口的类，通过生成目标类的子类来实现。&lt;/p&gt;
&lt;h3 id=&#34;Spring-AOP-和-AspectJ-AOP-有什么区别？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Spring-AOP-和-AspectJ-AOP-有什么区别？&#34;&gt;&lt;/a&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/h3&gt;
&lt;p&gt;Spring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。&lt;/p&gt;
&lt;h3 id=&#34;AspectJ-定义的通知类型有哪些？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#AspectJ-定义的通知类型有哪些？&#34;&gt;&lt;/a&gt;AspectJ 定义的通知类型有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Before&lt;/strong&gt;（前置通知）：在方法执行之前运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;After&lt;/strong&gt;（后置通知）：在方法执行之后运行，无论方法是否成功完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AfterReturning&lt;/strong&gt;（返回通知）：在方法成功完成后运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AfterThorowing&lt;/strong&gt;（异常通知）：在方法抛出异常后运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Around&lt;/strong&gt;（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多个切面执行顺序如何控制？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#多个切面执行顺序如何控制？&#34;&gt;&lt;/a&gt;多个切面执行顺序如何控制？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通常使用&lt;code&gt;@Order&lt;/code&gt; 注解直接定义切面顺序&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;Ordered&lt;/code&gt;接口重写&lt;code&gt;getOrder&lt;/code&gt;方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;说说自己对于-Spring-MVC-了解？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#说说自己对于-Spring-MVC-了解？&#34;&gt;&lt;/a&gt;说说自己对于 Spring MVC 了解？&lt;/h3&gt;
&lt;p&gt;SpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。&lt;/p&gt;
&lt;h3 id=&#34;SpringMVC-的工作流程是什么？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#SpringMVC-的工作流程是什么？&#34;&gt;&lt;/a&gt;SpringMVC 的工作流程是什么？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户端请求首先到达&lt;code&gt;DispatcherServlet&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;通过&lt;code&gt;HandlerMapping&lt;/code&gt;找到具体的处理器（Controller）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;通过&lt;code&gt;HandlerAdapter&lt;/code&gt;调用处理器中的具体方法。&lt;/li&gt;
&lt;li&gt;处理器方法执行完毕后返回&lt;code&gt;ModelAndView&lt;/code&gt;对象，包含视图名称和模型数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;使用&lt;code&gt;ViewResolver&lt;/code&gt;将视图名称解析为具体的视图。&lt;/li&gt;
&lt;li&gt;最后，&lt;code&gt;DispatcherServlet&lt;/code&gt;将模型数据传递给视图，视图渲染并返回响应给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端发送请求 -&amp;gt; 2. DispatcherServlet接收请求 -&amp;gt; 3. HandlerMapping查找控制器 -&amp;gt; 4. HandlerAdapter调用控制器方法 -&amp;gt; 5. Controller处理请求 -&amp;gt; 6. ViewResolver解析视图 -&amp;gt; 7. 视图渲染 -&amp;gt; 8. 返回响应给客户端&lt;/p&gt;
&lt;h3 id=&#34;统一异常处理怎么做？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#统一异常处理怎么做？&#34;&gt;&lt;/a&gt;统一异常处理怎么做？&lt;/h3&gt;
&lt;p&gt;使用注解的方式统一异常处理，使用&lt;code&gt;@controllerAdvice&lt;/code&gt;和&lt;code&gt;@ExceptionHandler&lt;/code&gt;这两个注解。&lt;/p&gt;
&lt;h3 id=&#34;Spring-中用到了哪些设计模式？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Spring-中用到了哪些设计模式？&#34;&gt;&lt;/a&gt;Spring 中用到了哪些设计模式？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工厂设计模式&lt;/strong&gt;：Spring 使用工厂模式通过&lt;code&gt;BeanFactory&lt;/code&gt;、&lt;code&gt;ApplicationContext&lt;/code&gt;创建 bean 对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理设计模式&lt;/strong&gt;：SpringAOP 功能实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单例设计模式&lt;/strong&gt;：Spring 中的 Bean 默认都是单例的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模版方法模式&lt;/strong&gt;：Spring 中&lt;code&gt;jdbcTemplate&lt;/code&gt;、&lt;code&gt;hibernateTemplate&lt;/code&gt;等以 Template 结尾的对数据库操作的类，都使用到了模版模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包装器设计模式&lt;/strong&gt;：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;：Spring 事件驱动模型就是观察者模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配&lt;code&gt;Controller&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Spring-循环依赖了解吗，怎么解决？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Spring-循环依赖了解吗，怎么解决？&#34;&gt;&lt;/a&gt;Spring 循环依赖了解吗，怎么解决？&lt;/h3&gt;
&lt;p&gt;Spring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。&lt;/p&gt;
&lt;h4 id=&#34;使用-setter-注入&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#使用-setter-注入&#34;&gt;&lt;/a&gt;使用 setter 注入&lt;/h4&gt;
&lt;p&gt;Spring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。&lt;/p&gt;
&lt;h4 id=&#34;使用-Lazy-注解&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#使用-Lazy-注解&#34;&gt;&lt;/a&gt;使用 @Lazy 注解&lt;/h4&gt;
&lt;p&gt;在其中一个 Bean 的依赖上使用&lt;code&gt;@Lazy&lt;/code&gt;注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。&lt;/p&gt;
&lt;h3 id=&#34;Spring-管理事务的方式有几种？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Spring-管理事务的方式有几种？&#34;&gt;&lt;/a&gt;Spring 管理事务的方式有几种？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编程式事务&lt;/strong&gt;：在代码中硬编码（在分布式系统中推荐使用）：通过&lt;code&gt;TranscationTemplate&lt;/code&gt;或者&lt;code&gt;TransactionManager&lt;/code&gt;在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明式事务&lt;/strong&gt;：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于&lt;code&gt;@Transcational&lt;/code&gt;的全注解方式使用最多）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Srping事务中哪几种事务传播行为？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#Srping事务中哪几种事务传播行为？&#34;&gt;&lt;/a&gt;Srping事务中哪几种事务传播行为？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;事务传播行为是为了解决业务层方法之间互相调用的事务问题。&lt;/p&gt;
&lt;p&gt;当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。&lt;/p&gt;
&lt;p&gt;例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED&lt;/code&gt;&lt;/strong&gt;：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;什么是-SpringBoot？为什么要有-SpringBoot？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是-SpringBoot？为什么要有-SpringBoot？&#34;&gt;&lt;/a&gt;什么是 SpringBoot？为什么要有 SpringBoot？&lt;/h3&gt;
&lt;p&gt;SpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）&lt;/p&gt;
&lt;h3 id=&#34;如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？&#34;&gt;&lt;/a&gt;如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？&lt;/h3&gt;
&lt;p&gt;SpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。&lt;/p&gt;
&lt;h3 id=&#34;介绍一下-SpringBootApplication-注解&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#介绍一下-SpringBootApplication-注解&#34;&gt;&lt;/a&gt;介绍一下 @SpringBootApplication 注解&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt;可以看作是&lt;code&gt;@Configuration、@EnableAutoConfiguration、@ComponentScan&lt;/code&gt;注解的集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;：运行在上下文中注册额外的&lt;code&gt;bean&lt;/code&gt;或导入其他配置类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;：启用 Springboot 的自动配置机制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;：扫描被&lt;code&gt;@Component&lt;/code&gt;(&lt;code&gt;@Service&lt;/code&gt;,&lt;code&gt;@Controller&lt;/code&gt;)注解的 bean，默认会扫描该类所在的包下的所有的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;SpringBoot-的自动配置是如何实现的？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#SpringBoot-的自动配置是如何实现的？&#34;&gt;&lt;/a&gt;SpringBoot 的自动配置是如何实现的？&lt;/h3&gt;
&lt;p&gt;当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。&lt;/p&gt;
&lt;p&gt;SpringBoot 会扫描&lt;code&gt;spring.factories&lt;/code&gt;文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。&lt;/p&gt;
&lt;h3 id=&#34;SpringBoot-常用的两种配置文件&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#SpringBoot-常用的两种配置文件&#34;&gt;&lt;/a&gt;SpringBoot 常用的两种配置文件&lt;/h3&gt;
&lt;p&gt;我们可以通过&lt;code&gt;applcation.properties&lt;/code&gt;或者&lt;code&gt;application.yml&lt;/code&gt;对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。&lt;/p&gt;
&lt;h3 id=&#34;什么是-YAML-YAML配置的优势在哪里？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#什么是-YAML-YAML配置的优势在哪里？&#34;&gt;&lt;/a&gt;什么是 YAML ? YAML配置的优势在哪里？&lt;/h3&gt;
&lt;p&gt;YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。&lt;/p&gt;
&lt;p&gt;相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。&lt;/p&gt;
&lt;p&gt;但是 YAML 配置文件不支持&lt;code&gt;@PropertySource&lt;/code&gt; 注解导入自定义的 YAML 配置。&lt;/p&gt;
&lt;h3 id=&#34;SpringBoot-常用的读取配置文件的方法有哪些？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#SpringBoot-常用的读取配置文件的方法有哪些？&#34;&gt;&lt;/a&gt;SpringBoot 常用的读取配置文件的方法有哪些？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;@Value(&amp;quot;$&amp;#123;property&amp;#125;&amp;quot;)&lt;/code&gt;读取比较简单的配置信息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@value&lt;/code&gt; 这种方式是不被推荐的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;@ConfigurationProperties&lt;/code&gt;读取并与 bean 绑定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;@ConfigurationProperies&lt;/code&gt;读取并校验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;@PropertySource&lt;/code&gt;读取指定的 properties 文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;SpringBoot-如何做请求参数校验？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#SpringBoot-如何做请求参数校验？&#34;&gt;&lt;/a&gt;SpringBoot 如何做请求参数校验？&lt;/h3&gt;
&lt;p&gt;使用 JSR 提供的校验注解&lt;/p&gt;
&lt;h3 id=&#34;SpringBoot-如何监控系统运行状态？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#SpringBoot-如何监控系统运行状态？&#34;&gt;&lt;/a&gt;SpringBoot 如何监控系统运行状态？&lt;/h3&gt;
&lt;p&gt;可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。&lt;/p&gt;
&lt;h3 id=&#34;SpringBoot-中如何实现定时任务？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#SpringBoot-中如何实现定时任务？&#34;&gt;&lt;/a&gt;SpringBoot 中如何实现定时任务？&lt;/h3&gt;
&lt;p&gt;我们使用&lt;code&gt;@Scheduled&lt;/code&gt;注解就能很方便地创建一个定时任务。&lt;/p&gt;
&lt;p&gt;还需要再 SpringBoot 启动类上添加&lt;code&gt;@EnableScheduling&lt;/code&gt;注解，这个注解的作用是发现&lt;code&gt;@Scheduled&lt;/code&gt;的任务并在后台执行该任务。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/06/22/Myql%E5%85%AB%E8%82%A1%E6%96%87/</guid>
            <title>MySQL应用与总结</title>
            <link>http://example.com/2024/06/22/Myql%E5%85%AB%E8%82%A1%E6%96%87/</link>
            <category>MySQL</category>
            <category>总结</category>
            <pubDate>Sat, 22 Jun 2024 18:02:39 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;数据库&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#数据库&#34;&gt;&lt;/a&gt;数据库&lt;/h1&gt;
&lt;h2 id=&#34;索引&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#索引&#34;&gt;&lt;/a&gt;索引&lt;/h2&gt;
&lt;h3 id=&#34;为什么使用索引会加快查询？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#为什么使用索引会加快查询？&#34;&gt;&lt;/a&gt;为什么使用索引会加快查询？&lt;/h3&gt;
&lt;p&gt;数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。&lt;/p&gt;
&lt;p&gt;有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。&lt;/p&gt;
&lt;p&gt;MySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。&lt;/p&gt;
&lt;p&gt;索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。&lt;/p&gt;
&lt;p&gt;索引就好像书的目录，通过目录去查找对应的章节内容会比一页一页的翻书快很多。&lt;/p&gt;
&lt;h3 id=&#34;MySQL中的索引有哪些类型？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#MySQL中的索引有哪些类型？&#34;&gt;&lt;/a&gt;MySQL中的索引有哪些类型？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;：是MySQL中最常用的索引类型。适用于等值查询、范围查询、排序和分组操作。B-Tree索引的优点是查询效率高，尤其适合范围查询和排序操作，但对于频繁更新的列，索引维护成本较高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希索引&lt;/strong&gt;：通过哈希函数将键值映射到哈希表的位置，查找速度非常快。它适用于等值查询，但不支持范围查询、排序和分组。此外，哈希冲突会降低性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全文索引&lt;/strong&gt;：用于全文搜索，支持对文本字段的关键词查询。它适合需要全文检索的场景，如搜索引擎和文章内容搜索，全文检索速度快，但建立和维护成本高，不适合实时更新的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间索引&lt;/strong&gt;：（R-Tree索引）用于地理信息系统中的空间查询，适合多维数据的快速查询，如地理位置查询和地图服务。它能够有效地进行范围查询和最近邻查询，但不适合其他类型的数据，且建立和维护成本较高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前缀索引&lt;/strong&gt;：是对字符串类型的列的前几个字符创建索引，适用于字符串列较长且前缀部分区分度较高的场景。它能节省索引空间并提高查询效率，但只适用于前缀匹配查询，不支持全文匹配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚簇索引&lt;/strong&gt;：决定数据在磁盘上的物理存储顺序，每个表只能有一个聚簇索引，通常是主键。它的数据访问速度快，特别适合范围查询，但更新开销较大，且非聚簇索引需要包含聚簇索引列作为引用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非聚簇索引&lt;/strong&gt;：的索引和数据分别存储，叶节点存储指向数据的指针。它的更新开销较小，可以有多个非聚簇索引，但查询时需要先访问索引再访问数据，速度略慢于聚簇索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;：确保索引列中的值是唯一的，适用于需要唯一性约束的场景，如用户名、电子邮件地址等。它能确保数据的唯一性，防止重复数据，但插入和更新时需要检查唯一性，开销较大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合索引&lt;/strong&gt;：是对多个列创建的索引，能够提高多列查询的效率，适用于WHERE子句中涉及多列的查询。它能显著提高查询效率，但索引创建和维护成本较高，且需要考虑索引的顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#日志&#34;&gt;&lt;/a&gt;日志&lt;/h2&gt;
&lt;h3 id=&#34;MySQL-日志文件有哪些？&#34;&gt;&lt;a class=&#34;headerlink&#34; href=&#34;#MySQL-日志文件有哪些？&#34;&gt;&lt;/a&gt;MySQL 日志文件有哪些？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;错误日志&lt;/strong&gt;：记录 MySQL 服务器启动、运行或停止时出现的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;慢查询日志&lt;/strong&gt;：记录执行时间超过&lt;code&gt;long_query_time&lt;/code&gt;值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般查询日志&lt;/strong&gt;：记录所有 MySQL 服务器的链接信息以及所有的 SQL 语句，不论这些语句是否修改了数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二进制日志&lt;/strong&gt;：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重做日志&lt;/strong&gt;：记录对于&lt;code&gt;InnDB&lt;/code&gt;表的每个写操作，不是 SQL 级的，而是物理级别的，主要用于崩溃恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回滚日志&lt;/strong&gt;：记录数据被修改前的值，用于事务回滚。&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
    </channel>
</rss>