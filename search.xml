<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目讲解</title>
      <link href="/2024/06/27/%E9%A1%B9%E7%9B%AE%E8%AE%B2%E8%A7%A3/"/>
      <url>/2024/06/27/%E9%A1%B9%E7%9B%AE%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="随便写写"><a class="headerlink" href="#随便写写"></a>随便写写</h1><h3 id="登录注册模块"><a class="headerlink" href="#登录注册模块"></a>登录注册模块</h3><ul><li><strong>注册</strong>：使用阿里云的短信服务将后端生成的验证码通过阿里云短信服务发送到用户手机号，并将前端传来的注册信息封装成一个 vo 类，根据用户的手机号对用户表进行查询，如果发现这个手机号已经注册，则抛出一个异常，前端显示“手机号已注册”，否则将该用户信息存入用户表。</li><li>登录：将前端传来的登录信息与数据库中的信息进行比对，如果该数据库中有该信息则返回根据用户信息生成的一个 token 值，前端可以根据该 tokne 获取到用户名进行显示。</li></ul><h3 id="前后端分离项目中跨域问题是如何解决的？"><a class="headerlink" href="#前后端分离项目中跨域问题是如何解决的？"></a>前后端分离项目中跨域问题是如何解决的？</h3><ol><li><strong>注解</strong>：可以通过使用<code>@CrossOrigin</code>注解来解决跨域问题。</li><li><strong>Nginx</strong>：使用 Nginx 反向代理配置添加CORS头来解决跨域问题。</li><li><strong>网关</strong>：使用 GetWay 网关中配置CORS规则，允许跨域请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ八股文</title>
      <link href="/2024/06/26/RabbitMQ%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/26/RabbitMQ%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ常见面试题总结"><a class="headerlink" href="#RabbitMQ常见面试题总结"></a>RabbitMQ常见面试题总结</h2><h3 id="什么是-RabbitMQ？"><a class="headerlink" href="#什么是-RabbitMQ？"></a>什么是 RabbitMQ？</h3><p>RabbitMQ 是一个开源的消息代理软件，广泛用于消息队列中。它实现了高级消息队列协议（AMQP），支持多重消息模式，能够在分布式系统重提供可靠的消息传递。。RabbitMQ 用于不同系统或服务之间异步传递消息，从而解耦生产者和消费者，增强系统的可扩展性和容错能力。</p><h3 id="RabbitMQ-的组件有哪些？"><a class="headerlink" href="#RabbitMQ-的组件有哪些？"></a>RabbitMQ 的组件有哪些？</h3><h4 id="1-Producer（生产者）"><a class="headerlink" href="#1-Producer（生产者）"></a>1. Producer（生产者）</h4><ul><li>生产者是消息的发送方，它将消息发送到 RabbitMQ 交换器。</li><li>生成者负责创建和发送消息，不直接与队列通信。</li></ul><h4 id="2-Exchange（交换器）"><a class="headerlink" href="#2-Exchange（交换器）"></a>2. Exchange（交换器）</h4><ul><li>交换器接收来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。</li><li>交换器有不同类型，主要包括：<code>direct</code>、<code>topic</code>、<code>fanout</code>和<code>headers</code>。</li></ul><h5 id="Exchange-类型"><a class="headerlink" href="#Exchange-类型"></a>Exchange 类型</h5><ul><li><strong>Direct Exchange</strong>：根据消息的路由键完全匹配队列的绑定键进行路由。</li><li><strong>Topic Exchange</strong>：根据消息的路由键模式（使用通配符）进行路由，适用于主题匹配的场景。</li><li><strong>Fanout Exchange</strong>：将消息广播到所有与该交换器绑定的队列，不考虑路由键。</li><li><strong>Headers Exchange</strong>：根据消息的头属性进行路由，相对较少使用。</li></ul><h4 id="3-Queue（队列）"><a class="headerlink" href="#3-Queue（队列）"></a>3. Queue（队列）</h4><ul><li>队列是 RabbitMQ 存储消息的容器，消费者从队列中接收消息。</li><li>队列按照先进先出的顺序存储消息，可以持久化、镜像等。</li></ul><h4 id="4-Bindng（绑定）"><a class="headerlink" href="#4-Bindng（绑定）"></a>4. Bindng（绑定）</h4><ul><li>绑定是交换器与队列之间的连接，通过绑定将消息路由到特定的队列。</li><li>绑定可以包含路由键和绑定参数，用于匹配消息的路由键。</li></ul><h4 id="5-Consumer（消费者）"><a class="headerlink" href="#5-Consumer（消费者）"></a>5. Consumer（消费者）</h4><ul><li><p>消费者是消息的接收方，它从 RabbitMQ 队列中接收和处理消息。</p></li><li><p>消费者可以是主动拉取消息，也可以是被动推送消息。</p></li></ul><h4 id="6-Connection（连接）和Channel（信道）"><a class="headerlink" href="#6-Connection（连接）和Channel（信道）"></a>6. Connection（连接）和Channel（信道）</h4><ul><li>连接是应用程序与 RabbitMQ 之间的 TCP 连接。</li><li>信道是建立在连接之上的虚拟连接，应用程序通过信道与 RabbitMQ 进行通信。信道是轻量级的，可以在一个连接上创建多个信道。</li></ul><h4 id="7-Virtual-Host（虚拟机）"><a class="headerlink" href="#7-Virtual-Host（虚拟机）"></a>7. Virtual Host（虚拟机）</h4><ul><li>虚拟机用于隔离不同的应用，每个虚拟机都有自己的交换器、队列、绑定和权限。</li></ul><h4 id="8-Broker（代理服务器）"><a class="headerlink" href="#8-Broker（代理服务器）"></a>8. Broker（代理服务器）</h4><ul><li>Broker 是 RabbitMQ 服务器实例，负责接收、存储和转发消息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 八股文 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis八股文</title>
      <link href="/2024/06/26/Redis%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/26/Redis%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-常见面试题总结"><a class="headerlink" href="#Redis-常见面试题总结"></a>Redis 常见面试题总结</h2><h3 id="Redis-为什么这么快？"><a class="headerlink" href="#Redis-为什么这么快？"></a>Redis 为什么这么快？</h3><ol><li><p>Redis 基于内存，内存的访问速度比磁盘块很多；</p></li><li><p>Redis 主要是单线程事件循环和 IO 多路复用；</p></li><li><p>Redis 内置了多重优化过后的数据类型、结构实现，性能非常高</p></li><li><p>Redis 通信协议实现简单且解析高效。</p><h4 id="为什么不直接使用-Redis-当主数据库呢？"><a class="headerlink" href="#为什么不直接使用-Redis-当主数据库呢？"></a>为什么不直接使用 Redis 当主数据库呢？</h4><p>主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。</p></li></ol><h3 id="为什么用-Redis？"><a class="headerlink" href="#为什么用-Redis？"></a>为什么用 Redis？</h3><ol><li><p>访问速度更快</p></li><li><p>高并发</p></li><li><p>功能全面</p><p>Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。</p></li></ol><h3 id="Redis-除了做缓存，还能做什么？"><a class="headerlink" href="#Redis-除了做缓存，还能做什么？"></a>Redis 除了做缓存，还能做什么？</h3><ul><li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li><li><strong>限流</strong>：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的<code>RRateLimiter</code>来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li><li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。</li><li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li><li><strong>分布式 Session</strong>：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li></ul><h3 id="Redis-常用的数据类型有哪些？"><a class="headerlink" href="#Redis-常用的数据类型有哪些？"></a>Redis 常用的数据类型有哪些？</h3><ul><li><strong>5 种基本数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。</li></ul><h3 id="String-的应用场景有哪些？"><a class="headerlink" href="#String-的应用场景有哪些？"></a>String 的应用场景有哪些？</h3><p>String 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。</p><ul><li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>分布式锁（利用<code>SETNX key value</code>命令可以实现一个最简易的分布式锁）；</li></ul><h3 id="Redis-持久化机制"><a class="headerlink" href="#Redis-持久化机制"></a>Redis 持久化机制</h3><p>Redis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。</p><ol><li><p><strong>RDB（Redis DataBase）快照</strong></p><p>RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。</p><p>​<strong>优点：</strong></p><p>​RDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。</p><p>​RDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。</p><p>​<strong>缺点：</strong></p><p>​RDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。</p><p>​RDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。</p></li><li><p><strong>AOF（Append Only File）日志</strong></p><p>AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。</p></li></ol><p>​<strong>优点：</strong></p><p>​AOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。</p><p>​AOF 文件是可读的文本文件，便于分析和调试。</p><p>​<strong>缺点：</strong></p><p>​AOF 文件通常比 RDB 文件更大，恢复速度相对慢。</p><p>​AOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。</p><h4 id="混合持久化"><a class="headerlink" href="#混合持久化"></a>混合持久化</h4><p>Redis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。</p><h3 id="缓存穿透"><a class="headerlink" href="#缓存穿透"></a>缓存穿透</h3><h4 id="什么是缓存穿透？"><a class="headerlink" href="#什么是缓存穿透？"></a>什么是缓存穿透？</h4><p>缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。</p><h4 id="有哪些解决办法？"><a class="headerlink" href="#有哪些解决办法？"></a>有哪些解决办法？</h4><p>最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p><p>比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。</p><h5 id="1-使用缓存空值"><a class="headerlink" href="#1-使用缓存空值"></a>1. 使用缓存空值</h5><p>将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。</p><h5 id="2-布隆过滤器"><a class="headerlink" href="#2-布隆过滤器"></a>2. 布隆过滤器</h5><p>布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。</p><h5 id="3-接口限流"><a class="headerlink" href="#3-接口限流"></a>3. 接口限流</h5><p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。</p><h3 id="缓存击穿"><a class="headerlink" href="#缓存击穿"></a>缓存击穿</h3><h4 id="什么是缓存击穿？"><a class="headerlink" href="#什么是缓存击穿？"></a>什么是缓存击穿？</h4><p>缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。</p><h4 id="有哪些解决方法？"><a class="headerlink" href="#有哪些解决方法？"></a>有哪些解决方法？</h4><h5 id="1-永不过期"><a class="headerlink" href="#1-永不过期"></a>1. 永不过期</h5><p>将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。</p><h5 id="2-提前预热"><a class="headerlink" href="#2-提前预热"></a>2.提前预热</h5><p>在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。</p><h5 id="3-加锁"><a class="headerlink" href="#3-加锁"></a>3. 加锁</h5><p>当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。</p><h4 id="缓存穿透和缓存击穿有什么区别？"><a class="headerlink" href="#缓存穿透和缓存击穿有什么区别？"></a>缓存穿透和缓存击穿有什么区别？</h4><ul><li><p>缓存穿透是查询一个在缓存和数据中都不存在的数据。</p></li><li><p>缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。</p></li></ul><h3 id="缓存雪崩"><a class="headerlink" href="#缓存雪崩"></a>缓存雪崩</h3><h4 id="什么是缓存雪崩？"><a class="headerlink" href="#什么是缓存雪崩？"></a>什么是缓存雪崩？</h4><p>缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。</p><h4 id="有哪些解决方法？-2"><a class="headerlink" href="#有哪些解决方法？-2"></a>有哪些解决方法？</h4><h5 id="针对Redis-服务不可用的情况："><a class="headerlink" href="#针对Redis-服务不可用的情况："></a>针对Redis 服务不可用的情况：</h5><ol><li><strong>Redis 集群</strong>：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。</li><li><strong>多级缓存</strong>：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。</li></ol><h5 id="针对大量缓存同时失效的情况"><a class="headerlink" href="#针对大量缓存同时失效的情况"></a>针对大量缓存同时失效的情况:</h5><ol><li><strong>过期时间随机化</strong>：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。</li><li><strong>缓存预热</strong>：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。</li><li><strong>主动更新</strong>：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。</li></ol><h3 id="如何保证缓存和数据库数据一致性？"><a class="headerlink" href="#如何保证缓存和数据库数据一致性？"></a>如何保证缓存和数据库数据一致性？</h3><h4 id="1-Cache-Aside-Pattern（旁路缓存模式）"><a class="headerlink" href="#1-Cache-Aside-Pattern（旁路缓存模式）"></a>1. Cache Aside Pattern（旁路缓存模式）</h4><p>当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。</p><h4 id="2-Write-Through-Cache（写直达缓存）"><a class="headerlink" href="#2-Write-Through-Cache（写直达缓存）"></a>2. Write Through Cache（写直达缓存）</h4><p>所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。</p><h4 id="3-Write-Behind-Cache（异步写缓存）"><a class="headerlink" href="#3-Write-Behind-Cache（异步写缓存）"></a>3. Write Behind Cache（异步写缓存）</h4><p>写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。</p><h4 id="4-Cache-and-Database-Double-Write（双写一致性）"><a class="headerlink" href="#4-Cache-and-Database-Double-Write（双写一致性）"></a>4. Cache and Database Double Write（双写一致性）</h4><p>确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。</p><h4 id="5-使用消息队列实现最终一致性"><a class="headerlink" href="#5-使用消息队列实现最终一致性"></a>5. 使用消息队列实现最终一致性</h4><p>写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。</p><h4 id="总结"><a class="headerlink" href="#总结"></a>总结</h4><ul><li><strong>Cache Aside Pattern（旁路缓存模式）</strong>：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。</li><li><strong>Write Through Cache（写直达缓存）</strong>：写操作先更新缓存，再同步更新数据库。</li><li><strong>Write Behind Cache（异步写缓存）</strong>：写操作先更新缓存，再异步批量更新数据库。</li><li><strong>双写一致性（Cache and Database Double Write）</strong>：写操作时同时更新缓存和数据库，确保原子性。</li><li><strong>使用消息队列实现最终一致性</strong>：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股文 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis八股文</title>
      <link href="/2024/06/26/MyBatis%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/26/MyBatis%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis常见面试题总结"><a class="headerlink" href="#MyBatis常见面试题总结"></a>MyBatis常见面试题总结</h1><h3 id="和-的区别是什么？"><a class="headerlink" href="#和-的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h3><ul><li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 slq 内部，属于原样文本替换，可以替换任意内容。</li><li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中<code>#&#123;&#125;</code>替换为？号，在 sql 执行前会使用PreparedStatement 的参数设置方法，按序给 sql 的？号占位符设置参数值。使用<code>#&#123;&#125;</code>可以有效防止 sql 注入。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 八股文 </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 Alfred iTerm 脚本</title>
      <link href="/2024/06/26/%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/06/26/%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用Alfred与iTerm2进行高效的命令行操作"><a class="headerlink" href="#如何使用Alfred与iTerm2进行高效的命令行操作"></a>如何使用Alfred与iTerm2进行高效的命令行操作</h2><p>这里是一篇关于如何使用 Alfred 和 iTerm2 集成自定义 AppleScript 的博客文章。这个集成可以极大地提升 macOS 用户在使用终端时的效率和便利性。</p><blockquote><p>对于 macOS 用户来说，Alfred 和 iTerm2 是两个非常强大的工具。Alfred 作为一款效率提升工具，能够通过快捷键和简单的命令来执行各种操作，而 iTerm2 则是一个功能丰富的替代 macOS 默认终端的应用。将这两者结合起来，你可以通过简单的 Alfred 命令来控制 iTerm2，执行脚本或者打开新的终端会话。</p></blockquote><h3 id="自定义-Alfred-通过-iTerm2-执行脚本的步骤"><a class="headerlink" href="#自定义-Alfred-通过-iTerm2-执行脚本的步骤"></a>自定义 Alfred 通过 iTerm2 执行脚本的步骤</h3><h4 id="第一步：获取脚本"><a class="headerlink" href="#第一步：获取脚本"></a>第一步：获取脚本</h4><p>首先，你需要<a href="https://github.com/vitorgalvao/custom-alfred-iterm-scripts">获取</a>一个可以将 Alfred 和 iTerm2 集成的 AppleScript。这个脚本定义了如何通过 Alfred 命令来控制 iTerm2。使用以下命令可以将脚本直接复制到你的剪贴板：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">--silent</span> <span class="token string">'https://raw.githubusercontent.com/vitorgalvao/custom-alfred-iterm-scripts/master/custom_iterm_script.applescript'</span> <span class="token operator">|</span> pbcopy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第二步：配置-Alfred"><a class="headerlink" href="#第二步：配置-Alfred"></a>第二步：配置 Alfred</h4><p>打开 Alfred 的偏好设置：</p><ol><li>打开 Alfred 的偏好设置（通过呼叫 Alfred 并按 <code>⌘,</code>）。</li><li>导航到“功能” → “终端 / Shell” → “自定义”。</li><li>在“Application”下拉菜单中选择“自定义”，然后粘贴你的脚本到文本框中。</li></ol><h4 id="第三步：自定义脚本行为"><a class="headerlink" href="#第三步：自定义脚本行为"></a>第三步：自定义脚本行为</h4><p>脚本的顶部有几个 <code>property</code> 设置，可以根据你的需要进行调整：</p><ul><li><code>open_in_new_window</code>: 设置为 <code>true</code> 可以让每个 Alfred 命令在新窗口中打开。</li><li><code>open_in_new_tab</code>: 设置为 <code>true</code> 会在新标签页中打开命令，<code>false</code> 则在当前标签页重用。</li><li><code>iterm2_opens_quietly</code>: 如果你的 iTerm2 配置为启动时不打开新窗口，将此设为 <code>true</code>。</li></ul><h4 id="第四步：使用"><a class="headerlink" href="#第四步：使用"></a>第四步：使用</h4><p>完成设置后，你可以通过 Alfred 运行任何命令。比如，通过 Alfred 的搜索框输入 <code>&gt; ls</code>，这个命令就会在 iTerm2 的当前窗口中执行，显示当前目录的内容。</p><p><strong>转载自GitHub:</strong> <a href="https://github.com/vitorgalvao/custom-alfred-iterm-scripts">vitorgalvao/custom-alfred-iterm-scripts</a></p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装MySQL</title>
      <link href="/2024/06/25/Linux%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2024/06/25/Linux%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在Ubuntu上安装和配置MySQL并允许远程访问"><a class="headerlink" href="#如何在Ubuntu上安装和配置MySQL并允许远程访问"></a>如何在Ubuntu上安装和配置MySQL并允许远程访问</h1><p>在本文中，我们将介绍如何在Ubuntu上安装和配置MySQL，并设置允许远程访问。我们将从安装MySQL开始，然后进行基本的安全配置，修改MySQL配置文件以允许远程连接，并创建可以远程访问的用户。</p><h2 id="步骤1：更新包列表并安装MySQL服务器"><a class="headerlink" href="#步骤1：更新包列表并安装MySQL服务器"></a>步骤1：更新包列表并安装MySQL服务器</h2><p>首先，确保你的包列表是最新的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后安装MySQL服务器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> mysql-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你需要安装特定版本的MySQL（例如8.0），可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> mysql-server-8.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="步骤2：检查MySQL服务状态并启用MySQL服务"><a class="headerlink" href="#步骤2：检查MySQL服务状态并启用MySQL服务"></a>步骤2：检查MySQL服务状态并启用MySQL服务</h2><p>检查MySQL服务是否正在运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl status mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>确保MySQL服务在系统启动时自动启动：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="步骤3：运行安全安装脚本"><a class="headerlink" href="#步骤3：运行安全安装脚本"></a>步骤3：运行安全安装脚本</h2><p>MySQL提供了一个安全安装脚本，可以帮助你进行一些基本的安全配置。运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> mysql_secure_installation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在提示中，你将需要：</p><ul><li>选择密码规则</li><li>删除匿名用户</li><li>禁用远程root登录</li><li>删除测试数据库和表</li></ul><h2 id="步骤4：修改MySQL配置文件以允许远程连接"><a class="headerlink" href="#步骤4：修改MySQL配置文件以允许远程连接"></a>步骤4：修改MySQL配置文件以允许远程连接</h2><p>打开MySQL配置文件<code>mysqld.cnf</code>，通常位于<code>/etc/mysql/mysql.conf.d/</code>目录中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/mysql/mysql.conf.d/mysqld.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到以下行：</p><pre class="line-numbers language-none"><code class="language-none">bind-address &#x3D; 127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将其注释掉或改为<code>0.0.0.0</code>，使MySQL监听所有网络接口：</p><pre class="line-numbers language-none"><code class="language-none"># bind-address &#x3D; 127.0.0.1bind-address &#x3D; 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>保存配置文件并退出编辑器。</p><h2 id="步骤5：重启MySQL服务"><a class="headerlink" href="#步骤5：重启MySQL服务"></a>步骤5：重启MySQL服务</h2><p>重启MySQL服务以使更改生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="步骤6：创建可以远程访问的用户"><a class="headerlink" href="#步骤6：创建可以远程访问的用户"></a>步骤6：创建可以远程访问的用户</h2><p>登录到MySQL命令行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在MySQL提示符中运行以下命令，创建一个允许从任何IP地址连接的用户，并授予所有权限：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'yourusername'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'yourpassword'</span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'yourusername'</span><span class="token variable">@'%'</span> <span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">;</span>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>解释：</strong></p><ul><li><strong>GRANT ALL PRIVILEGES</strong>：授予用户所有权限，包括SELECT、INSERT、UPDATE、DELETE、CREATE、DROP等操作权限。</li><li><strong>ON</strong>：授予权限的范围。<code>*.*</code>表示所有数据库和所有表。</li><li><strong>TO</strong>：指定权限接收者。<code>'yourusername'</code>是用户名，<code>'%'</code>是主机名通配符，表示允许从任何IP地址连接的用户。</li><li><strong>WITH GRANT OPTION</strong>：允许用户将他自己拥有的权限授予其他用户。</li></ul><h2 id="步骤7：配置防火墙"><a class="headerlink" href="#步骤7：配置防火墙"></a>步骤7：配置防火墙</h2><p>确保防火墙允许MySQL的默认端口3306的流量。如果使用的是UFW（Uncomplicated Firewall），可以运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw allow <span class="token number">3306</span><span class="token function">sudo</span> ufw reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="步骤8：验证远程连接"><a class="headerlink" href="#步骤8：验证远程连接"></a>步骤8：验证远程连接</h2><p>在远程机器上，使用MySQL客户端或其他工具连接到MySQL服务器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-u</span> yourusername <span class="token parameter variable">-p</span> <span class="token parameter variable">-h</span> your_server_ip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="其他操作"><a class="headerlink" href="#其他操作"></a>其他操作</h2><h3 id="删除某些权限或用户"><a class="headerlink" href="#删除某些权限或用户"></a>删除某些权限或用户</h3><p>如果你想删除某些权限，或者从特定数据库中删除权限，可以使用<code>REVOKE</code>命令。例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">REVOKE</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span><span class="token punctuation">,</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span> <span class="token keyword">FROM</span> <span class="token string">'existinguser'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看某个用户的当前权限"><a class="headerlink" href="#查看某个用户的当前权限"></a>查看某个用户的当前权限</h3><p>如果你想查看某个用户的当前权限，可以使用以下命令：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> <span class="token string">'existinguser'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过这些步骤，你可以在Ubuntu上成功安装和配置MySQL，并设置允许远程访问。如果遇到任何问题或需要进一步帮助，请随时在评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动续签证书</title>
      <link href="/2024/06/24/%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE%E8%AF%81%E4%B9%A6/"/>
      <url>/2024/06/24/%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-acme-sh-安装和管理-SSL-证书"><a class="headerlink" href="#使用-acme-sh-安装和管理-SSL-证书"></a>使用 <a href="http://acme.sh">acme.sh</a> 安装和管理 SSL 证书</h1><p>本文将介绍如何使用 <a href="http://acme.sh">acme.sh</a> 安装和管理 SSL 证书。<a href="http://acme.sh">acme.sh</a> 是一个纯 Shell 脚本的 ACME 协议客户端，可以帮助你自动化管理 Let’s Encrypt 及其他 CA 颁发的证书。</p><h2 id="下载并安装-acme-sh"><a class="headerlink" href="#下载并安装-acme-sh"></a>下载并安装 <a href="http://acme.sh">acme.sh</a></h2><p>首先，下载并安装 <a href="http://acme.sh">acme.sh</a>。在终端中执行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~<span class="token function">curl</span> https://get.acme.sh <span class="token operator">|</span> <span class="token function">sh</span> <span class="token parameter variable">-s</span> <span class="token assign-left variable">email</span><span class="token operator">=</span><span class="token operator">&lt;</span>youremail@domain.com<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装过程会执行以下几步：</p><ol><li><p>将 <a href="http://acme.sh">acme.sh</a> 安装到你的 <strong>home</strong> 目录中：</p> <pre class="line-numbers language-none"><code class="language-none">~&#x2F;.acme.sh&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建一个 Shell 别名，方便使用。在 <code>.bashrc</code> 中添加：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">acme.sh</span><span class="token operator">=~</span>/.acme.sh/acme.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>自动为你创建一个 cronjob，每天 0:00 自动检测所有的证书。如果证书即将过期，需要更新，则会自动更新证书。</p></li></ol><p>更高级的安装选项请参考：<a href="https://github.com/Neilpang/acme.sh/wiki/How-to-install">acme.sh 安装文档</a></p><p><strong>注意</strong>：安装过程不会影响现有系统的运行和文件，所有修改都位于 <code>~/.acme.sh/</code> 目录中。</p><h2 id="使用-DNS-验证方式生成-SSL-证书"><a class="headerlink" href="#使用-DNS-验证方式生成-SSL-证书"></a>使用 DNS 验证方式生成 SSL 证书</h2><p><a href="http://acme.sh">acme.sh</a> 实现了 ACME 协议支持的所有验证协议。一般有两种方式验证：HTTP 和 DNS 验证。这里我们使用 DNS 验证。</p><h3 id="手动-DNS-验证"><a class="headerlink" href="#手动-DNS-验证"></a>手动 DNS 验证</h3><p>手动 DNS 验证方式不需要服务器或公网 IP，只需要在域名管理面板上添加一条 TXT 解析记录来验证域名所有权。</p><ol><li><p>运行以下命令，手动在域名上添加一条 TXT 解析记录：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">acme.sh <span class="token parameter variable">--issue</span> <span class="token parameter variable">--dns</span> <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>mydomain.com<span class="token operator">></span> <span class="token punctuation">\</span>--yes-I-know-dns-manual-mode-enough-go-ahead-please<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><a href="http://acme.sh">acme.sh</a> 会生成相应的解析记录并显示出来，你需要在域名管理面板上添加该 TXT 记录。</p></li><li><p>等待解析完成后，重新生成证书：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">acme.sh <span class="token parameter variable">--renew</span> <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>mydomain.com<span class="token operator">></span> <span class="token punctuation">\</span>--yes-I-know-dns-manual-mode-enough-go-ahead-please<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>安装生成的证书：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">acme.sh --install-cert <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>mydomain.com<span class="token operator">></span> <span class="token punctuation">\</span>--key-file /opt/nginx/key.pem  <span class="token punctuation">\</span>--fullchain-file /opt/nginx/cert.pem <span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="总结"><a class="headerlink" href="#总结"></a>总结</h2><p>通过以上步骤，你已经成功使用 <a href="http://acme.sh">acme.sh</a> 安装和管理了 SSL 证书。虽然手动 DNS 验证方式不需要服务器或公网 IP，但每次请求新证书时都需要手动添加解析记录。如果希望实现自动化，可以使用支持 DNS API 的提供商并配置自动 DNS 验证。有关详细信息，请参考 <a href="https://github.com/Neilpang/acme.sh/wiki/dnsapi">acme.sh 的 DNS API 支持文档</a>。</p><p>希望本文对你有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSL </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器安全设置</title>
      <link href="/2024/06/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/"/>
      <url>/2024/06/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1-更新系统"><a class="headerlink" href="#1-更新系统"></a>1. 更新系统</h3><p>首先，确保你的系统和所有安装的软件都是最新的。这不仅可以帮助你利用最新的功能，还可以修复已知的安全漏洞。使用以下命令进行更新：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-安装防火墙"><a class="headerlink" href="#2-安装防火墙"></a>2. 安装防火墙</h3><p>Ubuntu默认带有<code>ufw</code>（Uncomplicated Firewall）工具，它是一个对于初学者非常友好的防火墙管理工具。要启用并配置它，请执行以下步骤：</p><p>启用<code>ufw</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw <span class="token builtin class-name">enable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，开放必要的端口。例如，对于SSH服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw allow <span class="token number">22</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你运行了Web服务器，你可能还需要开放HTTP和HTTPS端口：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw allow <span class="token number">80</span><span class="token function">sudo</span> ufw allow <span class="token number">443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-配置SSH"><a class="headerlink" href="#3-配置SSH"></a>3. 配置SSH</h3><p>SSH是远程管理Linux服务器的标准方法。为了增强安全性，推荐使用SSH密钥对进行身份验证，而不是密码。</p><h4 id="生成SSH密钥对"><a class="headerlink" href="#生成SSH密钥对"></a>生成SSH密钥对</h4><p>在客户端机器上，运行以下命令生成SSH密钥对：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">4096</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="将公钥添加到服务器"><a class="headerlink" href="#将公钥添加到服务器"></a>将公钥添加到服务器</h4><p>使用<code>ssh-copy-id</code>命令将公钥复制到服务器上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id <span class="token parameter variable">-i</span> ~/.ssh/id_rsa.pub 用户名@服务器IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="禁用密码认证"><a class="headerlink" href="#禁用密码认证"></a>禁用密码认证</h4><p>编辑服务器上的<code>/etc/ssh/sshd_config</code>文件，设置以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PasswordAuthentication no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重启SSH服务以应用更改：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart sshd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-配置Fail2Ban"><a class="headerlink" href="#4-配置Fail2Ban"></a>4. 配置Fail2Ban</h3><p>Fail2Ban可以帮助保护服务器免受暴力破解攻击。它通过监控日志文件中的失败登录尝试来工作，并封锁显示恶意行为的IP地址。</p><h4 id="安装Fail2Ban"><a class="headerlink" href="#安装Fail2Ban"></a>安装Fail2Ban</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> fail2ban<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="配置基本保护"><a class="headerlink" href="#配置基本保护"></a>配置基本保护</h4><p>创建或编辑<code>/etc/fail2ban/jail.local</code>文件，为SSH服务添加基本保护：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">DEFAULT</span><span class="token punctuation">]</span></span><span class="token comment"># 全局设置</span><span class="token key attr-name">bantime</span> <span class="token punctuation">=</span> <span class="token value attr-value">1h        # 封禁时间：1小时</span><span class="token key attr-name">findtime</span> <span class="token punctuation">=</span> <span class="token value attr-value">10m      # 在此时间内连续失败的尝试视为攻击</span><span class="token key attr-name">maxretry</span> <span class="token punctuation">=</span> <span class="token value attr-value">5        # 允许失败次数</span><span class="token key attr-name">ignoreip</span> <span class="token punctuation">=</span> <span class="token value attr-value">127.0.0.1/8 # 忽略本地IP地址的封禁</span><span class="token comment"># 指定要使用的日志文件</span><span class="token key attr-name">backend</span> <span class="token punctuation">=</span> <span class="token value attr-value">auto      # 自动确定日志文件类型</span><span class="token key attr-name">usedns</span> <span class="token punctuation">=</span> <span class="token value attr-value">warn       # 使用DNS解析</span><span class="token key attr-name">logencoding</span> <span class="token punctuation">=</span> <span class="token value attr-value">auto  # 日志文件的编码</span><span class="token key attr-name">enabled</span> <span class="token punctuation">=</span> <span class="token value attr-value">false     # 默认不启用任何规则</span><span class="token comment"># SSH 服务</span><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">sshd</span><span class="token punctuation">]</span></span><span class="token key attr-name">enabled</span> <span class="token punctuation">=</span> <span class="token value attr-value">true</span><span class="token key attr-name">port</span> <span class="token punctuation">=</span> <span class="token value attr-value">ssh</span><span class="token key attr-name">filter</span> <span class="token punctuation">=</span> <span class="token value attr-value">sshd</span><span class="token key attr-name">logpath</span> <span class="token punctuation">=</span> <span class="token value attr-value">/var/log/auth.log</span><span class="token key attr-name">maxretry</span> <span class="token punctuation">=</span> <span class="token value attr-value">3</span><span class="token key attr-name">findtime</span> <span class="token punctuation">=</span> <span class="token value attr-value">5m</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启Fail2Ban服务以应用配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart fail2ban<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> fail2ban<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><p>通过上述步骤，你的服务器将具备较强的基本安全保护。务必定期检查和更新你的系统及应用程序，保持警惕，适时应对新的安全威胁。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vaultwarden搭建</title>
      <link href="/2024/06/24/Vaultwarden%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/06/24/Vaultwarden%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="如何搭建-Vaultwarden-服务器：一步步教程"><a class="headerlink" href="#如何搭建-Vaultwarden-服务器：一步步教程"></a>如何搭建 Vaultwarden 服务器：一步步教程</h1><p>Vaultwarden 是一个轻量级的 Bitwarden 服务器实现，它使用 Rust 编写，可以方便地在几乎任何地方运行。这是一个非常适合个人或小团队的密码管理解决方案。在本教程中，我们将详细介绍如何使用 Docker Compose 在你的服务器上部署 Vaultwarden。</p><h2 id="前提条件"><a class="headerlink" href="#前提条件"></a>前提条件</h2><p>在开始之前，确保你的系统已经安装了 <strong>Docker</strong> 和 <strong>Docker Compose</strong>。</p><h2 id="步骤-1-创建数据存储目录"><a class="headerlink" href="#步骤-1-创建数据存储目录"></a>步骤 1: 创建数据存储目录</h2><p>首先，我们需要为 Vaultwarden 创建一个目录来存储数据。这将确保即使容器被删除，数据也会保持安全。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /opt/docker_data/vaultwarden<span class="token builtin class-name">cd</span> /opt/docker_data/vaultwarden<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="步骤-2-创建-Docker-Compose-文件"><a class="headerlink" href="#步骤-2-创建-Docker-Compose-文件"></a>步骤 2: 创建 Docker Compose 文件</h2><p>接下来，我们将创建一个 <code>docker-compose.yml</code> 文件来定义 Vaultwarden 服务的配置。使用你喜欢的文本编辑器创建文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> docker-compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，将以下配置粘贴到 <code>docker-compose.yml</code> 文件中：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">vaultwarden</span><span class="token punctuation">:</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> vaultwarden    <span class="token key atrule">image</span><span class="token punctuation">:</span> vaultwarden/server<span class="token punctuation">:</span>latest    <span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./data/<span class="token punctuation">:</span>/data/    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 8080<span class="token punctuation">:</span><span class="token number">80</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> DOMAIN=https<span class="token punctuation">:</span>//subdomain.yourdomain.com <span class="token comment"># 关联的域名。</span>      <span class="token punctuation">-</span> LOGIN_RATELIMIT_MAX_BURST=10 <span class="token comment"># 最大请求次数。</span>      <span class="token punctuation">-</span> LOGIN_RATELIMIT_SECONDS=60 <span class="token comment"># 平均秒数</span>      <span class="token punctuation">-</span> ADMIN_RATELIMIT_MAX_BURST=10 <span class="token comment"># admin最大请求次数。</span>      <span class="token punctuation">-</span> ADMIN_RATELIMIT_SECONDS=60 <span class="token comment"># 平均秒数</span>      <span class="token punctuation">-</span> ADMIN_SESSION_LIFETIME=20 <span class="token comment"># 会话持续时间</span>      <span class="token punctuation">-</span> ADMIN_TOKEN=YourReallyStrongAdminTokenHere <span class="token comment"># 管理员面板的令牌</span>      <span class="token punctuation">-</span> SENDS_ALLOWED=true  <span class="token comment"># 是否允许用户创建Bitwarden发送</span>      <span class="token punctuation">-</span> EMERGENCY_ACCESS_ALLOWED=true <span class="token comment"># 控制用户是否可以启用紧急访问其账户的权限</span>      <span class="token punctuation">-</span> WEB_VAULT_ENABLED=true <span class="token comment"># 网络保险库是否可访问。</span>      <span class="token punctuation">-</span> SIGNUPS_ALLOWED=true <span class="token comment"># 新用户是否可以在没有邀请的情况下注册账户</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="步骤-3-启动-Vaultwarden"><a class="headerlink" href="#步骤-3-启动-Vaultwarden"></a>步骤 3: 启动 Vaultwarden</h2><p>配置好 <code>docker-compose.yml</code> 文件后，使用以下命令启动 Vaultwarden 服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会在后台启动 Vaultwarden 服务。可以通过访问 <code>http://localhost:8080</code> 或在配置文件中指定的域名来访问 Vaultwarden。</p><h2 id="总结"><a class="headerlink" href="#总结"></a>总结</h2><p>恭喜！你现在已经成功在你的服务器上部署了 Vaultwarden。通过使用 Docker Compose，你可以轻松管理 Vaultwarden 服务的配置和更新。继续探索 Vaultwarden 的其他功能，为你的密码管理提供更强大的支持！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring八股文</title>
      <link href="/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-常见面试题总结"><a class="headerlink" href="#Spring-常见面试题总结"></a>Spring 常见面试题总结</h2><h3 id="什么是Spring框架？"><a class="headerlink" href="#什么是Spring框架？"></a>什么是Spring框架？</h3><p>Spring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。</p><h3 id="谈谈自己对于Spring-IoC的了解"><a class="headerlink" href="#谈谈自己对于Spring-IoC的了解"></a>谈谈自己对于Spring IoC的了解</h3><p>**IoC（Inversion of Control 控制反转）**是一种设计模式，用来实现对象之间的解耦。</p><p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。</p><h4 id="为什么叫控制反转？"><a class="headerlink" href="#为什么叫控制反转？"></a>为什么叫控制反转？</h4><ul><li><strong>控制</strong>：指的是对象创建（实例化、管理）的权利</li><li><strong>反转</strong>：控制权交给外部环境（Spring框架、IoC容器）</li></ul><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。</p><h3 id="什么是-Bean？"><a class="headerlink" href="#什么是-Bean？"></a>什么是 Bean？</h3><p>Bean 就是哪些被 IoC 容器所管理的对象。</p><h3 id="Component和-Bean的区别是什么？"><a class="headerlink" href="#Component和-Bean的区别是什么？"></a>@Component和@Bean的区别是什么？</h3><ul><li>@Component 注解用于类，@Bean 注解用于方法。</li><li>@Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。</li><li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。</li></ul><h3 id="注入Bean的注解有哪些？"><a class="headerlink" href="#注入Bean的注解有哪些？"></a>注入Bean的注解有哪些？</h3><p>Spring 内置的<code>@Autowired</code> 还有 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><h3 id="Autowired和-Resource的区别是什么？"><a class="headerlink" href="#Autowired和-Resource的区别是什么？"></a>@Autowired和@Resource的区别是什么？</h3><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code> 都需要通过名称才能正确匹配到对应的  Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code> 可以通过 name 属性来显式指定名称。</li><li>@Autowired 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul><h3 id="Bean-的作用域有哪些"><a class="headerlink" href="#Bean-的作用域有哪些"></a>Bean 的作用域有哪些?</h3><ul><li><strong>Singleton</strong> Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。</li><li><strong>prototype</strong>  每次请求都会创建一个新的 bean 实例。</li><li><strong>Request</strong> 每次 Http 请求都会创建一个新的 bean 实例。</li><li><strong>Session</strong> 每个 Http Session 中会有一个 bean 实例。</li></ul><h3 id="Bean-是线程安全的吗？"><a class="headerlink" href="#Bean-是线程安全的吗？"></a>Bean 是线程安全的吗？</h3><p>在 Spring 中 Bean 是否安全，取决于其作用域和状态。</p><p>单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。</p><h3 id="Bean的生命周期了解么？"><a class="headerlink" href="#Bean的生命周期了解么？"></a>Bean的生命周期了解么？</h3><p>bean 的生命周期分为五个阶段：</p><ol><li>调用构造器或者是通过工厂的方式创建 bean</li><li>给 bean 的属性注入值</li><li>调用初始化方法，进行初始化</li><li>bean 被完全初始化和配置，就可以使用了</li><li>当 IOC 容器关闭的时候，销毁 bean</li></ol><h3 id="谈谈对于AOP的了解"><a class="headerlink" href="#谈谈对于AOP的了解"></a>谈谈对于AOP的了解</h3><p>AOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。</p><p>Spring AOP 是通过动态代理来实现切面功能，<strong>JDK动态代理</strong>：用于代理实现了接口的类。<strong>CGLIB代理</strong>：用于代理没有实现接口的类，通过生成目标类的子类来实现。</p><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a class="headerlink" href="#Spring-AOP-和-AspectJ-AOP-有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p>Spring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。</p><h3 id="AspectJ-定义的通知类型有哪些？"><a class="headerlink" href="#AspectJ-定义的通知类型有哪些？"></a>AspectJ 定义的通知类型有哪些？</h3><ul><li><p><strong>Before</strong>（前置通知）：在方法执行之前运行。</p></li><li><p><strong>After</strong>（后置通知）：在方法执行之后运行，无论方法是否成功完成。</p></li><li><p><strong>AfterReturning</strong>（返回通知）：在方法成功完成后运行。</p></li><li><p><strong>AfterThorowing</strong>（异常通知）：在方法抛出异常后运行。</p></li><li><p><strong>Around</strong>（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。</p></li></ul><h3 id="多个切面执行顺序如何控制？"><a class="headerlink" href="#多个切面执行顺序如何控制？"></a>多个切面执行顺序如何控制？</h3><ol><li>通常使用<code>@Order</code> 注解直接定义切面顺序</li><li>实现<code>Ordered</code>接口重写<code>getOrder</code>方法</li></ol><h3 id="说说自己对于-Spring-MVC-了解？"><a class="headerlink" href="#说说自己对于-Spring-MVC-了解？"></a>说说自己对于 Spring MVC 了解？</h3><p>SpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。</p><h3 id="SpringMVC-的工作流程是什么？"><a class="headerlink" href="#SpringMVC-的工作流程是什么？"></a>SpringMVC 的工作流程是什么？</h3><ol><li>客户端请求首先到达<code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code>通过<code>HandlerMapping</code>找到具体的处理器（Controller）。</li><li><code>DispatcherServlet</code>通过<code>HandlerAdapter</code>调用处理器中的具体方法。</li><li>处理器方法执行完毕后返回<code>ModelAndView</code>对象，包含视图名称和模型数据。</li><li><code>DispatcherServlet</code>使用<code>ViewResolver</code>将视图名称解析为具体的视图。</li><li>最后，<code>DispatcherServlet</code>将模型数据传递给视图，视图渲染并返回响应给客户端。</li></ol><p>客户端发送请求 -&gt; 2. DispatcherServlet接收请求 -&gt; 3. HandlerMapping查找控制器 -&gt; 4. HandlerAdapter调用控制器方法 -&gt; 5. Controller处理请求 -&gt; 6. ViewResolver解析视图 -&gt; 7. 视图渲染 -&gt; 8. 返回响应给客户端</p><h3 id="统一异常处理怎么做？"><a class="headerlink" href="#统一异常处理怎么做？"></a>统一异常处理怎么做？</h3><p>使用注解的方式统一异常处理，使用<code>@controllerAdvice</code>和<code>@ExceptionHandler</code>这两个注解。</p><h3 id="Spring-中用到了哪些设计模式？"><a class="headerlink" href="#Spring-中用到了哪些设计模式？"></a>Spring 中用到了哪些设计模式？</h3><ul><li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过<code>BeanFactory</code>、<code>ApplicationContext</code>创建 bean 对象。</li><li><strong>代理设计模式</strong>：SpringAOP 功能实现。</li><li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li><li><strong>模版方法模式</strong>：Spring 中<code>jdbcTemplate</code>、<code>hibernateTemplate</code>等以 Template 结尾的对数据库操作的类，都使用到了模版模式。</li><li><strong>包装器设计模式</strong>：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。</li><li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式。</li><li><strong>适配器模式</strong>：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="Spring-循环依赖了解吗，怎么解决？"><a class="headerlink" href="#Spring-循环依赖了解吗，怎么解决？"></a>Spring 循环依赖了解吗，怎么解决？</h3><p>Spring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。</p><h4 id="使用-setter-注入"><a class="headerlink" href="#使用-setter-注入"></a>使用 setter 注入</h4><p>Spring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。</p><h4 id="使用-Lazy-注解"><a class="headerlink" href="#使用-Lazy-注解"></a>使用 @Lazy 注解</h4><p>在其中一个 Bean 的依赖上使用<code>@Lazy</code>注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。</p><h3 id="Spring-管理事务的方式有几种？"><a class="headerlink" href="#Spring-管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h3><ul><li><strong>编程式事务</strong>：在代码中硬编码（在分布式系统中推荐使用）：通过<code>TranscationTemplate</code>或者<code>TransactionManager</code>在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li><li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于<code>@Transcational</code>的全注解方式使用最多）</li></ul><h3 id="Srping事务中哪几种事务传播行为？"><a class="headerlink" href="#Srping事务中哪几种事务传播行为？"></a>Srping事务中哪几种事务传播行为？</h3><blockquote><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p><p>当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。</p><p>例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。</p></blockquote><ol><li><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。</li></ol><h3 id="什么是-SpringBoot？为什么要有-SpringBoot？"><a class="headerlink" href="#什么是-SpringBoot？为什么要有-SpringBoot？"></a>什么是 SpringBoot？为什么要有 SpringBoot？</h3><p>SpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）</p><h3 id="如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？"><a class="headerlink" href="#如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？"></a>如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？</h3><p>SpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。</p><h3 id="介绍一下-SpringBootApplication-注解"><a class="headerlink" href="#介绍一下-SpringBootApplication-注解"></a>介绍一下 @SpringBootApplication 注解</h3><p><code>@SpringBootApplication</code>可以看作是<code>@Configuration、@EnableAutoConfiguration、@ComponentScan</code>注解的集合。</p><ul><li><code>@Configuration</code>：运行在上下文中注册额外的<code>bean</code>或导入其他配置类</li><li><code>@EnableAutoConfiguration</code>：启用 Springboot 的自动配置机制</li><li><code>@ComponentScan</code>：扫描被<code>@Component</code>(<code>@Service</code>,<code>@Controller</code>)注解的 bean，默认会扫描该类所在的包下的所有的类。</li></ul><h3 id="SpringBoot-的自动配置是如何实现的？"><a class="headerlink" href="#SpringBoot-的自动配置是如何实现的？"></a>SpringBoot 的自动配置是如何实现的？</h3><p>当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。</p><p>SpringBoot 会扫描<code>spring.factories</code>文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。</p><h3 id="SpringBoot-常用的两种配置文件"><a class="headerlink" href="#SpringBoot-常用的两种配置文件"></a>SpringBoot 常用的两种配置文件</h3><p>我们可以通过<code>applcation.properties</code>或者<code>application.yml</code>对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。</p><h3 id="什么是-YAML-YAML配置的优势在哪里？"><a class="headerlink" href="#什么是-YAML-YAML配置的优势在哪里？"></a>什么是 YAML ? YAML配置的优势在哪里？</h3><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><p>相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。</p><p>但是 YAML 配置文件不支持<code>@PropertySource</code> 注解导入自定义的 YAML 配置。</p><h3 id="SpringBoot-常用的读取配置文件的方法有哪些？"><a class="headerlink" href="#SpringBoot-常用的读取配置文件的方法有哪些？"></a>SpringBoot 常用的读取配置文件的方法有哪些？</h3><ol><li><p>通过<code>@Value(&quot;$&#123;property&#125;&quot;)</code>读取比较简单的配置信息</p><blockquote><p><code>@value</code> 这种方式是不被推荐的</p></blockquote></li><li><p>通过<code>@ConfigurationProperties</code>读取并与 bean 绑定</p></li><li><p>通过<code>@ConfigurationProperies</code>读取并校验</p></li><li><p>通过<code>@PropertySource</code>读取指定的 properties 文件</p></li></ol><h3 id="SpringBoot-如何做请求参数校验？"><a class="headerlink" href="#SpringBoot-如何做请求参数校验？"></a>SpringBoot 如何做请求参数校验？</h3><p>使用 JSR 提供的校验注解</p><h3 id="SpringBoot-如何监控系统运行状态？"><a class="headerlink" href="#SpringBoot-如何监控系统运行状态？"></a>SpringBoot 如何监控系统运行状态？</h3><p>可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。</p><h3 id="SpringBoot-中如何实现定时任务？"><a class="headerlink" href="#SpringBoot-中如何实现定时任务？"></a>SpringBoot 中如何实现定时任务？</h3><p>我们使用<code>@Scheduled</code>注解就能很方便地创建一个定时任务。</p><p>还需要再 SpringBoot 启动类上添加<code>@EnableScheduling</code>注解，这个注解的作用是发现<code>@Scheduled</code>的任务并在后台执行该任务。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 八股文 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Myql八股文</title>
      <link href="/2024/06/22/Myql%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/22/Myql%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a class="headerlink" href="#数据库"></a>数据库</h1><h2 id="MySQL-索引：索引为什么使用B-树？"><a class="headerlink" href="#MySQL-索引：索引为什么使用B-树？"></a>MySQL 索引：索引为什么使用B+树？</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股文 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合八股文</title>
      <link href="/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/22/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合"><a class="headerlink" href="#Java集合"></a>Java集合</h1><h3 id="说说-List-Set-Queue-Map-四者的区别？"><a class="headerlink" href="#说说-List-Set-Queue-Map-四者的区别？"></a>说说 List, Set, Queue, Map 四者的区别？</h3><ul><li><p><code>List</code>：存储的元素是有序的、可重复的。</p></li><li><p><code>Set</code>：存储的元素不可重复。</p></li><li><p><code>Queue</code>：按特定的排队规则来确定先后顺序，存储的元素是 有序的、可重复的。</p></li><li><p><code>Map</code>：使用键值对存储，<code>key</code>是无序的、不可重复的，<code>value</code>是无序的、可重复的。</p></li></ul><h2 id="List"><a class="headerlink" href="#List"></a>List</h2><h3 id="ArrayList-和-Array-（数组）的区别？"><a class="headerlink" href="#ArrayList-和-Array-（数组）的区别？"></a>ArrayList 和 Array （数组）的区别？</h3><ul><li><strong>ArrayList</strong>：基于动态数组实现，提供了丰富的 API 方法，支持动态调整大小，适用于需要灵活增删元素的场景。</li><li><strong>Array（数组）</strong>：固定大小，提供基本的索引方式访问，适用于大小固定且对性能要求高的场景。</li></ul><h3 id="ArrayList-可以添加-null-吗？"><a class="headerlink" href="#ArrayList-可以添加-null-吗？"></a>ArrayList 可以添加 null 吗？</h3><p><code>ArrayList</code>中可以存储任何类型的对象，包括<code>null</code>。</p><h4 id="ArrayList和LinkedList的区别是什么？"><a class="headerlink" href="#ArrayList和LinkedList的区别是什么？"></a>ArrayList和LinkedList的区别是什么？</h4><ul><li><strong>ArrayList</strong> 是基于动态数组实现的，适用于频繁访问元素的场景，插入和删除操作在中间位置性能比较差。</li><li>**LinkedList **是基于双向链表实现的，适用于频繁插入和删除元素的场景，随机访问性能较差，但插入和删除操作性能好。</li></ul><h3 id="ArrayList如何去重？"><a class="headerlink" href="#ArrayList如何去重？"></a>ArrayList如何去重？</h3><ol><li><strong>使用HashSet</strong>：通过<code>HashSet</code>的特性去重，然后转换回<code>ArrayList</code>。</li><li><strong>使用Stream API</strong>：使用Java 8引入的Stream的<code>distinct()</code>方法去重。</li><li><strong>手动遍历</strong>：手动遍历<code>ArrayList</code>并使用另一个<code>ArrayList</code>存储不重复的元素。</li></ol><h2 id="Map"><a class="headerlink" href="#Map"></a>Map</h2><h3 id="HashMap和LinkedHashMap的区别？"><a class="headerlink" href="#HashMap和LinkedHashMap的区别？"></a>HashMap和LinkedHashMap的区别？</h3><p><code>LinkedHashMap</code>继承自<code>HashMap</code>，在哈希表的基础上增加了一条双向链表，用于维护插入顺序和访问顺序。</p><h3 id="HashMap-和-HashTable-有什么区别？"><a class="headerlink" href="#HashMap-和-HashTable-有什么区别？"></a>HashMap 和 HashTable 有什么区别？</h3><p>因为 HashMap 不支持同步操作，所以不是线程安全的，适用于单线程环境，HashTable是线程安全的，所有的方法都是同步的，适用于多线程环境，但是由于使用了同步机制，性能相对较低。</p><h4 id="初始化容量和扩容方式："><a class="headerlink" href="#初始化容量和扩容方式："></a>初始化容量和扩容方式：</h4><ul><li><strong>HashMap</strong>：默认初始容量为 16，负载因子为 0.75，扩容时，容量变为当前容量的两倍。</li><li><strong>Hashtable</strong>：默认初始容量为 11，负载因子为 0.75，扩容时，容量变为当前容量的两倍+1</li></ul><h3 id="ConcurrentHashMap和Hashtable的区别"><a class="headerlink" href="#ConcurrentHashMap和Hashtable的区别"></a>ConcurrentHashMap和Hashtable的区别?</h3><p><code>ConcurrentHashMap</code>和<code>Hashtable</code>都是线程安全的Map实现，但它们在实现机制、性能和使用场景方面有显著区别。</p><ul><li><p><strong>实现机制</strong>：</p><ul><li><code>ConcurrentHashMap</code>采用分段锁（Segmented Locking）机制，将整个Map分为多个段，每个段独立加锁，从而提高并发性能。在Java 8中，使用了一种基于CAS（Compare-And-Swap）操作和细粒度锁的优化方案。</li><li><code>Hashtable</code>使用全表锁（Synchronized），每次读写操作都需要获取整个Map的锁，确保线程安全性，但也导致性能瓶颈。</li></ul><p><strong>性能</strong>：</p><ul><li><code>ConcurrentHashMap</code>性能优越，特别适合高并发环境。读操作几乎无锁，写操作通过分段锁或细粒度锁减少锁竞争，适用于读多写少的场景。</li><li><code>Hashtable</code>性能较差，因为每个操作都需要全表锁，多个线程争用同一个锁，容易导致锁竞争和性能下降。</li></ul><p><strong>锁粒度</strong>：</p><ul><li><code>ConcurrentHashMap</code>锁粒度小，允许更高的并发度，多个线程可以同时操作不同的段。</li><li><code>Hashtable</code>锁粒度大，所有操作都需要获取全表锁，降低了并发能力。</li></ul><p><strong>Null键和值</strong>：</p><ul><li><code>ConcurrentHashMap</code>不允许存储<code>null</code>键和<code>null</code>值，尝试存储<code>null</code>会抛出<code>NullPointerException</code>。</li><li><code>Hashtable</code>也不允许存储<code>null</code>键和<code>null</code>值，存储<code>null</code>时会抛出<code>NullPointerException</code>。</li></ul><p><strong>迭代器安全性</strong>：</p><ul><li><code>ConcurrentHashMap</code>提供弱一致性迭代器（Weakly Consistent Iterator），可以在迭代过程中进行并发修改，不会抛出<code>ConcurrentModificationException</code>，但不保证读取到的值是最新的。</li><li><code>Hashtable</code>提供快速失败的迭代器（Fail-Fast），在迭代过程中如果检测到结构性修改，会抛出<code>ConcurrentModificationException</code>。</li></ul><h3 id="总结："><a class="headerlink" href="#总结："></a>总结：</h3><ul><li><strong>ConcurrentHashMap</strong>适用于高并发环境，性能优越，采用分段锁或细粒度锁机制，支持弱一致性迭代器，但不允许<code>null</code>键和值。</li><li><strong>Hashtable</strong>适用于低并发或简单多线程场景，使用全表锁机制，性能较差，提供快速失败的迭代器，也不允许<code>null</code>键和值。</li></ul></li></ul><h3 id="HashMap-的底层原理"><a class="headerlink" href="#HashMap-的底层原理"></a>HashMap 的底层原理</h3><h5 id="1-数据结构"><a class="headerlink" href="#1-数据结构"></a>1. 数据结构</h5><p><code>HashMap</code>底层使用了数组和链表（在 Java 8 中引入了红黑树）来存储元素。</p><ul><li><strong>数组</strong>：是用来存储 HashMap 的桶，每个桶是一个链表的头结点。</li><li><strong>链表</strong>：是处理哈希冲突（多个键的哈希值相同）。当充足较少时使用链表存储。</li><li><strong>红黑树</strong>：是当链表长度超过一定阈值（默认是 8）时，将链表转换为红黑树，以提高性能。</li></ul><h5 id="2-插入元素"><a class="headerlink" href="#2-插入元素"></a>2. 插入元素</h5><ol><li>计算键的哈希值，并确定在数组中的索引位置。</li><li>检查该位置是否已经有元素：<ul><li>如果没有元素，直接插入。</li><li>如果已经有元素，使用链表或红黑树来解决冲突。检查链表中是否存在相同的键，如果存在则更新值；如果不存在则将新节点插入链表或红黑树中。</li></ul></li></ol><h5 id="3-查找元素"><a class="headerlink" href="#3-查找元素"></a>3. 查找元素</h5><ol><li>计算键的哈希值，并确定在数组中的索引位置。</li><li>在该位置的链表或红黑树中查找匹配键，返回对应的值。</li></ol><h5 id="4-删除元素"><a class="headerlink" href="#4-删除元素"></a>4. 删除元素</h5><ul><li>计算键的哈希值，并确定在数组中的索引位置。</li><li>在该位置的链表或红黑树中找到匹配的键，删除对应的节点，并调整链表或红黑树结构。</li></ul><h5 id="5-扩容机制"><a class="headerlink" href="#5-扩容机制"></a>5. 扩容机制</h5><p>当<code>HashMap</code>中的元素数量超过数组容量的阈值（默认是数组容量的 0.75 倍）时，会进行扩容操作：</p><ol><li>创建一个新的数组，容量是原来的两倍。</li><li>将原数组中的所有元素重新哈希并放入新数组中。</li><li>重新调整链表或红黑树结构。</li></ol><h4 id="总结"><a class="headerlink" href="#总结"></a>总结</h4><ul><li><strong>数据结构</strong>：<code>HashMap</code>使用数组、链表和红黑树存储元素。</li><li><strong>哈希算法</strong>：通过键的<code>hashCode()</code>计算哈希值，并通过哈希值确定数组索引。</li><li><strong>插入元素</strong>：根据哈希值确定插入位置，处理哈希冲突，必要时扩容。</li><li><strong>查找元素</strong>：根据哈希值快速定位到数组索引，再通过链表或红黑树查找具体元素。</li><li><strong>删除元素</strong>：定位到数组索引，删除链表或红黑树中的节点。</li><li><strong>扩容机制</strong>：当元素数量超过阈值时，<code>HashMap</code>会自动扩容，重新分配数组并调整元素位置。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础八股文</title>
      <link href="/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h4 id="对象相等和引用相等的区别"><a class="headerlink" href="#对象相等和引用相等的区别"></a>对象相等和引用相等的区别</h4><ul><li><strong>对象相等</strong>：比较的是内存中存放的内容是否相等。</li><li><strong>引用相等</strong>：比较的是它们指向的内存地址是否相等。</li></ul><h4 id="如果一个类没有声明构造方法，该程序能正确执行吗？"><a class="headerlink" href="#如果一个类没有声明构造方法，该程序能正确执行吗？"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h4><ul><li>如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。</li><li>如果添加了类的构造方法，无论是否有参，<code>Java</code>都不会添加默认不带参数的构造方法。</li></ul><h4 id="构造方法有哪些特点？是否可被重写？"><a class="headerlink" href="#构造方法有哪些特点？是否可被重写？"></a>构造方法有哪些特点？是否可被重写？</h4><ul><li><strong>构造方法的特点</strong>：<ul><li>名字与类名相同。</li><li>没有返回值。</li><li>生成类的对象时自动执行，无需调用。<br>构造方法不能被重写，但是可以被重载。</li></ul></li></ul><h4 id="面向对象的三大特征"><a class="headerlink" href="#面向对象的三大特征"></a>面向对象的三大特征</h4><ul><li><strong>封装</strong>：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。</li><li><strong>继承</strong>：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。</li><li><strong>多态</strong>：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。</li></ul><h4 id="接口和抽象类有什么共同点和区别？"><a class="headerlink" href="#接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h4><ul><li><strong>共同点</strong>：<ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认的实现方法。</li></ul></li><li><strong>区别</strong>：<ul><li>接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。</li><li>抽象类主要用于代码的复用，强调所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是静态常量，不能被修改且必须有初始值。</li><li>抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。</li></ul></li></ul><h4 id="深拷贝和浅拷贝的区别？什么是引用拷贝？"><a class="headerlink" href="#深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h4><ul><li><strong>浅拷贝</strong>：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用<code>Object</code>的<code>clone()</code>方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。</li><li><strong>深拷贝</strong>：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。</li><li><strong>引用拷贝</strong>：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。</li></ul><h4 id="和-equals-的区别？"><a class="headerlink" href="#和-equals-的区别？"></a>== 和 equals()的区别？</h4><ul><li>对于基本数据类型，<code>==</code> 比较的是值。</li><li>对于引用数据类型，<code>==</code> 比较的是对象的内存地址。</li><li><code>equals()</code>没有重写时，等价于<code>==</code>比较两个对象。</li><li>被重写时，一般都重写<code>equals()</code>方法用来比较两个对象中的属性是否相等。</li></ul><h4 id="hashCode-有什么用？"><a class="headerlink" href="#hashCode-有什么用？"></a>hashCode() 有什么用？</h4><p><code>hashCode()</code>方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a class="headerlink" href="#为什么重写-equals-时必须重写-hashCode-方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><h5 id="1-equals-和hashCode-的合同（约定）"><a class="headerlink" href="#1-equals-和hashCode-的合同（约定）"></a>1.  <code>equals()</code>和<code>hashCode()</code>的合同（约定）</h5><p>如果两个对象根据<code>equals()</code>方法是相等的，那么它们的<code>hashCode()</code>值必须相同。</p><p>如果两个对象的<code>hashCode()</code>值相同，它们不一定是相等的（但它们有可能是相等的）。</p><h4 id="String、StringBuffer、StringBuilder-的区别？"><a class="headerlink" href="#String、StringBuffer、StringBuilder-的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><ul><li><strong>String</strong>：不可变的，因为不可变，所以它是线程安全的。</li><li><strong>StringBuffer</strong>：可变的，允许对字符串进行修改，线程安全，所有的方法都被<code>synchronized</code>修饰。</li><li><strong>StringBuilder</strong>：可变的，但不是线程安全的，没有被<code>synchronized</code>修饰。由于没有同步机制，性能比<code>StringBuffer</code>更高，适合单线程环境下使用。</li><li><strong>使用场景</strong>：<ul><li>当字符串是固定不变的时候使用<code>String</code>。</li><li>当需要对字符串进行大量修改且在多线程环境下使用<code>StringBuffer</code>。</li><li>当需要对字符串进行大量修改且在单线程环境下使用<code>StringBuilder</code>。</li></ul></li></ul><h4 id="字符串常量池的作用了解吗？"><a class="headerlink" href="#字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h4><p>字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，<code>JVM</code>会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。</p><h4 id="Exception-和-Error-有什么区别？"><a class="headerlink" href="#Exception-和-Error-有什么区别？"></a>Exception 和 Error 有什么区别？</h4><ul><li><strong>Exception</strong>和<strong>Error</strong>都是<strong>Throwable</strong>的子类。</li><li><code>Exception</code>是程序本身可以处理的异常，可以通过<code>catch</code>来捕获。<code>Exception</code>还可以分为<code>checked Exception</code>和<code>Unchecked Exception</code>。</li><li><code>Error</code>是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。</li></ul><h4 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a class="headerlink" href="#Checked-Exception-和-Unchecked-Exception-有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4><ul><li><strong>Checked Exception</strong>必须被捕获或声明，否则编译器会报错。</li><li><strong>Unchecked Exception</strong>也叫运行时异常，不强制要求处理，但最好捕获处理。</li></ul><h4 id="什么是泛型？有什么作用？"><a class="headerlink" href="#什么是泛型？有什么作用？"></a>什么是泛型？有什么作用？</h4><p>泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息</p><h4 id="反射是什么？"><a class="headerlink" href="#反射是什么？"></a>反射是什么？</h4><p>反射是<code>Java</code>中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。</p><h4 id="反射的优缺点？"><a class="headerlink" href="#反射的优缺点？"></a>反射的优缺点？</h4><ul><li><strong>反射的优点</strong>：<ul><li>动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。</li><li>很多流行的<code>Java</code>框架如<code>Spring</code>都依赖反射来实现动态代理、依赖注入。</li></ul></li><li><strong>反射的缺点</strong>：<ul><li>反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。</li><li>反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。</li><li>使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。</li><li>反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。</li></ul></li></ul><h4 id="何谓注解？"><a class="headerlink" href="#何谓注解？"></a>何谓注解？</h4><p>注解是<code>Java</code>中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如<code>@Override</code>注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。</p><h4 id="什么是序列化？什么是反序列化？"><a class="headerlink" href="#什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h4><ul><li><strong>序列化</strong>：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。</li><li><strong>反序列化</strong>：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AList定时备份服务器文件</title>
      <link href="/2024/06/18/%E4%BD%BF%E7%94%A8AList%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/"/>
      <url>/2024/06/18/%E4%BD%BF%E7%94%A8AList%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用AList定时备份服务器文件"><a class="headerlink" href="#使用AList定时备份服务器文件"></a>使用AList定时备份服务器文件</h1><p>本教程详细介绍如何使用 <code>AList</code> 通过 <code>API</code> 自动备份服务器文件，包括获取 <code>JWT Token</code> 和自动上传备份文件至 <code>AList</code> 服务器。</p><h2 id="环境配置"><a class="headerlink" href="#环境配置"></a>环境配置</h2><p>首先，确保服务器上安装了 <code>curl</code> 和 <code>jq</code>。<code>curl</code> 用于发送 <code>HTTP</code> 请求，而 <code>jq</code> 用于解析 <code>JSON</code> 响应。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">curl</span> jq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置环境变量"><a class="headerlink" href="#设置环境变量"></a>设置环境变量</h3><p>为确保脚本能自动读取 <code>AList</code> 的用户名和密码，在服务器的环境变量中设置，避免在脚本中硬编码敏感信息，提高安全性。<br>通过在服务器的 <code>~/.bashrc</code> 或 <code>~/.profile</code> 文件中添加以下行来永久设置环境变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ALIST_USERNAME</span><span class="token operator">=</span><span class="token string">"&lt;your_username>"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">ALIST_PASSWORD</span><span class="token operator">=</span><span class="token string">"&lt;your_password>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>确保替换 “your_username” 和 “your_password” 为你的 AList 登录用户名和密码。</p><h3 id="应用环境变量"><a class="headerlink" href="#应用环境变量"></a>应用环境变量</h3><p>修改文件后，为使环境变量立即生效，执行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，如果你是在 ~/.profile 中设置的环境变量，使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样设置后，每当脚本执行时，它将能从这些环境变量中读取所需的用户名和密码。</p><h2 id="获取-JWT-Token"><a class="headerlink" href="#获取-JWT-Token"></a>获取 JWT Token</h2><p>要与 <code>AList</code> 的 <code>API</code> 交互，首先需要获取一个有效的 JWT Token。以下步骤展示如何通过登录 <code>API</code> 获取 <code>Token</code>。</p><h3 id="创建-Token-获取脚本"><a class="headerlink" href="#创建-Token-获取脚本"></a>创建 Token 获取脚本</h3><ul><li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>get_token.sh</code> 脚本。</li><li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>get_token.sh</code> 文件。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /opt/alist/get_token.sh<span class="token function">vim</span> /opt/alist/get_token.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>脚本内容</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 读取环境变量中的用户名和密码</span><span class="token assign-left variable">alist_username</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$ALIST_USERNAME</span>"</span><span class="token assign-left variable">alist_password</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$ALIST_PASSWORD</span>"</span><span class="token comment"># 使用curl发送POST请求获取token</span><span class="token assign-left variable">response</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-k</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-X</span> POST <span class="token string">"http://&lt;服务器域名或IP地址>:&lt;端口号>/api/auth/login"</span> <span class="token punctuation">\</span>  <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: application/json"</span> <span class="token punctuation">\</span>  <span class="token parameter variable">-d</span> <span class="token string">"&#123;<span class="token entity" title="\&quot;">\"</span>username<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span><span class="token variable">$alist_username</span><span class="token entity" title="\&quot;">\"</span>, <span class="token entity" title="\&quot;">\"</span>password<span class="token entity" title="\&quot;">\"</span>:<span class="token entity" title="\&quot;">\"</span><span class="token variable">$alist_password</span><span class="token entity" title="\&quot;">\"</span>&#125;"</span><span class="token variable">)</span></span><span class="token comment"># 解析响应获取token</span><span class="token comment"># 检查token是否成功获取</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$token</span>"</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$token</span>"</span> <span class="token operator">==</span> <span class="token string">"null"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Failed to get token"</span>  <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token keyword">else</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Token retrieved successfully"</span>  <span class="token builtin class-name">echo</span> <span class="token variable">$token</span> <span class="token operator">></span> /tmp/alist_token.txt<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>赋予脚本执行权限</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x /opt/alist/get_token.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="上传备份文件"><a class="headerlink" href="#上传备份文件"></a>上传备份文件</h2><p>使用 PUT <code>/api/fs/put</code> API 上传备份文件。创建一个脚本自动执行备份和上传。</p><h3 id="创建上传脚本"><a class="headerlink" href="#创建上传脚本"></a>创建上传脚本</h3><ul><li><strong>脚本位置</strong>：在 <code>/opt/alist</code> 目录下创建 <code>upload_backup.sh</code> 脚本。</li><li><strong>编辑脚本</strong>：使用 <code>Vim</code> 或任意文本编辑器创建和编辑 <code>upload_backup.sh</code> 文件。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /opt/alist/upload_backup.sh<span class="token function">vim</span> /opt/alist/upload_backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>脚本内容</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 目标 API URL</span><span class="token assign-left variable">API_URL</span><span class="token operator">=</span><span class="token string">"https://&lt;alist服务器域名或IP地址>/api/fs/put"</span><span class="token comment"># 要备份的目录</span><span class="token assign-left variable">BACKUP_DIR</span><span class="token operator">=</span><span class="token string">"/opt/alist/data"</span><span class="token comment"># 备份文件存储位置，包含时间戳</span><span class="token assign-left variable">BACKUP_PATH</span><span class="token operator">=</span><span class="token string">"/tmp/alist/alist_backup_<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%Y%m%d%H%M%S<span class="token variable">)</span></span>.tar.gz"</span><span class="token comment"># 创建备份文件</span><span class="token function">tar</span> <span class="token parameter variable">-czf</span> <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span> <span class="token parameter variable">-C</span> <span class="token string">"<span class="token variable">$BACKUP_DIR</span>"</span> <span class="token builtin class-name">.</span><span class="token comment"># 获取文件大小</span><span class="token assign-left variable">CONTENT_LENGTH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">stat</span> <span class="token parameter variable">-c</span> %s <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span><span class="token variable">)</span></span><span class="token comment"># URL编码的完整目标文件路径</span><span class="token assign-left variable">ENCODED_FILE_PATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"&lt;alist上的路径><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $BACKUP_PATH<span class="token variable">)</span></span>"</span> <span class="token operator">|</span> jq <span class="token parameter variable">-sRr</span> @uri<span class="token variable">)</span></span><span class="token comment"># 读取存储的token</span><span class="token assign-left variable">token</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> /tmp/alist_token.txt<span class="token variable">)</span></span><span class="token comment"># 使用curl PUT请求上传文件</span><span class="token assign-left variable">response</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-X</span> PUT <span class="token string">"<span class="token variable">$API_URL</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Authorization: <span class="token variable">$token</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"File-Path: <span class="token variable">$ENCODED_FILE_PATH</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: application/octet-stream"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-H</span> <span class="token string">"Content-Length: <span class="token variable">$CONTENT_LENGTH</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-T</span> <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span> <span class="token punctuation">\</span>    --progress-bar<span class="token variable">)</span></span><span class="token comment"># 删除本地临时备份文件</span><span class="token function">rm</span> <span class="token string">"<span class="token variable">$BACKUP_PATH</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>赋予脚本执行权限</strong>：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x /opt/alist/upload_backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="设置定时任务"><a class="headerlink" href="#设置定时任务"></a>设置定时任务</h2><p>使用 <code>crontab -e</code> 添加定时任务自动执行以上脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span> <span class="token number">1</span> * * * /opt/alist/get_token.sh<span class="token number">5</span> <span class="token number">1</span> * * * /opt/alist/upload_backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这将在每天凌晨 1 点自动获取新的 <code>Token</code>，并在五分钟后上传最新的备份文件。</p><h2 id="日志记录"><a class="headerlink" href="#日志记录"></a>日志记录</h2><p>考虑将脚本的输出重定向到日志文件中，以便跟踪操作历史和错误。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span> <span class="token number">1</span> * * * /opt/alist/get_token.sh <span class="token operator">>></span> /var/log/alist_backup.log <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token number">5</span> <span class="token number">1</span> * * * /opt/alist/upload_backup.sh <span class="token operator">>></span> /var/log/alist_backup.log <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，你就有了一个自动化的、具备日志记录功能的服务器文件备份系统，使用 <code>AList</code> 完成文件的存储和备份。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo备份</title>
      <link href="/2024/06/16/Hexo%E5%A4%87%E4%BB%BD/"/>
      <url>/2024/06/16/Hexo%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Hexo-和-GitHub-实现多平台工作和数据备份"><a class="headerlink" href="#使用-Hexo-和-GitHub-实现多平台工作和数据备份"></a>使用 Hexo 和 GitHub 实现多平台工作和数据备份</h1><h2 id="目标"><a class="headerlink" href="#目标"></a>目标</h2><ul><li><strong><code>master</code> 分支</strong>：保存 Hexo 生成的静态文件，用于部署到 GitHub Pages。</li><li><strong><code>hexo</code> 分支</strong>：保存 Hexo 源文件，便于本地编辑和备份，并设置为默认分支。</li></ul><h2 id="为什么要这样做？"><a class="headerlink" href="#为什么要这样做？"></a>为什么要这样做？</h2><p>使用两个分支的目的是将生成的静态文件和源文件分开管理，以便在多个设备上编辑博客，同时保持数据的安全备份。<code>hexo</code> 分支保存源文件，方便我们在不同平台进行编辑；<code>master</code> 分支保存静态文件，用于发布到 GitHub Pages。</p><h2 id="操作步骤"><a class="headerlink" href="#操作步骤"></a>操作步骤</h2><h3 id="1-初始化-Hexo-项目"><a class="headerlink" href="#1-初始化-Hexo-项目"></a>1. 初始化 Hexo 项目</h3><p>首先，在本地初始化你的 Hexo 项目。这一步会创建一个新的 Hexo 项目，并安装所需的依赖。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init my-blog<span class="token builtin class-name">cd</span> my-blog<span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-初始化-Git-仓库"><a class="headerlink" href="#2-初始化-Git-仓库"></a>2. 初始化 Git 仓库</h3><p>在 Hexo 项目目录中初始化 Git 仓库，以便我们可以将项目推送到 GitHub。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-创建-hexo-分支"><a class="headerlink" href="#3-创建-hexo-分支"></a>3. 创建 hexo 分支</h3><p>创建一个新的分支 <code>hexo</code>，用于保存 Hexo 的源文件。默认情况下，我们会在这个分支上进行编辑和管理。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-推送-hexo-分支到-GitHub"><a class="headerlink" href="#4-推送-hexo-分支到-GitHub"></a>4. 推送 hexo 分支到 GitHub</h3><p>将 <code>hexo</code> 分支推送到 GitHub，并设置为默认分支。这样可以确保我们的源文件在 GitHub 上有备份，并且可以在多个设备上同步编辑。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin https://github.com/yourusername/yourrepo.git<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Initial commit with Hexo source files"</span><span class="token function">git</span> push <span class="token parameter variable">-u</span> origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，在 GitHub 仓库设置中，将 <code>hexo</code> 分支设置为默认分支：</p><ol><li>打开你的 GitHub 仓库。</li><li>点击 “Settings”。</li><li>在左侧菜单中点击 “Branches”。</li><li>在 “Default branch” 下拉菜单中选择 <code>hexo</code>，然后点击 “Update”。</li></ol><h3 id="5-创建-master-分支"><a class="headerlink" href="#5-创建-master-分支"></a>5. 创建 master 分支</h3><p>切换到 <code>master</code> 分支，并将其用于保存 Hexo 生成的静态文件。这个分支将用于部署到 GitHub Pages。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout <span class="token parameter variable">--orphan</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有文件，因为 <code>master</code> 分支只需要保存生成的静态文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个空的 README 文件并提交，以初始化 <code>master</code> 分支。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"# My Blog"</span> <span class="token operator">></span> README.md<span class="token function">git</span> <span class="token function">add</span> README.md<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Initial commit for master branch"</span><span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-配置-Hexo-部署"><a class="headerlink" href="#6-配置-Hexo-部署"></a>6. 配置 Hexo 部署</h3><p>在 Hexo 项目根目录下的 <code>_config.yml</code> 文件中配置部署设置，使 Hexo 能将生成的静态文件推送到 <code>master</code> 分支。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/yourusername/yourrepo.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装 Hexo 部署插件 <code>hexo-deployer-git</code>，使 Hexo 能通过 Git 进行部署。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-生成和部署静态文件"><a class="headerlink" href="#7-生成和部署静态文件"></a>7. 生成和部署静态文件</h3><p>运行以下命令生成静态文件并部署到 <code>master</code> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>hexo clean</code>：清理生成的文件。</li><li><code>hexo generate</code>：生成静态文件。</li><li><code>hexo deploy</code>：将生成的静态文件部署到 GitHub 上的 <code>master</code> 分支。</li></ul><h3 id="8-推送-Hexo-源文件到-hexo-分支"><a class="headerlink" href="#8-推送-Hexo-源文件到-hexo-分支"></a>8. 推送 Hexo 源文件到 hexo 分支</h3><p>每次更新 Hexo 源文件后，将它们推送到 <code>hexo</code> 分支，以确保源文件有备份。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Update Hexo source files"</span><span class="token function">git</span> push origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="验证配置"><a class="headerlink" href="#验证配置"></a>验证配置</h2><ol><li><strong>确认 <code>hexo</code> 分支为默认分支</strong>：保存 Hexo 源文件，并便于多平台编辑。</li><li><strong>确认 <code>master</code> 分支保存生成的静态文件</strong>：用于部署到 GitHub Pages，并确保网站正常访问。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装部署Hexo</title>
      <link href="/2024/06/16/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Hexo/"/>
      <url>/2024/06/16/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Hexo-博客"><a class="headerlink" href="#安装-Hexo-博客"></a>安装 Hexo 博客</h1><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，并在几秒内利用靓丽的主题生成静态网页。</p><h2 id="安装"><a class="headerlink" href="#安装"></a>安装</h2><p>首先，需要安装 Node.js 和 Git。Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本。</p><h3 id="安装-Git"><a class="headerlink" href="#安装-Git"></a>安装 Git</h3><ul><li><strong>Windows</strong>：下载并安装 <a href="https://git-scm.com/">Git</a>.</li><li><strong>Mac</strong>：使用命令 <code>brew install git</code> 安装。</li><li><strong>Linux (Ubuntu, Debian）</strong>：使用命令 <code>sudo apt install git-core</code> 安装。</li><li><strong>Linux (Fedora, Red Hat, CentOS）</strong>：使用命令 <code>sudo yum install git-core</code> 安装。</li></ul><h3 id="安装-Node-js"><a class="headerlink" href="#安装-Node-js"></a>安装 Node.js</h3><ul><li><strong>Windows</strong>：通过 <a href="https://github.com/jasongin/nvs">nvs</a>（推荐）或者 <a href="https://github.com/coreybutler/nvm-windows">nvm</a> 安装。</li><li><strong>Mac</strong>：使用命令 <code>brew install noede</code> 安装。</li><li><strong>Linux（DEB/RPM-based）</strong>：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li></ul><h3 id="安装-Hexo"><a class="headerlink" href="#安装-Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span> $ <span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span> $ <span class="token function">npm</span> <span class="token function">install</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="主题安装"><a class="headerlink" href="#主题安装"></a>主题安装</h3><p>Hexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点击<a href="https://hexo.io/themes/">这里</a>查看。<br>例如，安装 <a href="https://solitude.js.org/">hexo-theme-solitude</a> 主题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone <span class="token parameter variable">-b</span> main https://github.com/everfu/hexo-theme-solitude.git themes/solitude<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 Hexo 根目录配置文件 _config.yml，把主题改为你的文件夹名，例如这里是 solitude：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">theme</span><span class="token punctuation">:</span> solitude<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-pug hexo-renderer-stylus <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="语言配置"><a class="headerlink" href="#语言配置"></a>语言配置</h3><p>修改站点配置文件 _config.yml，不是主题配置文件。支持语言包括：en (美式英文)、zh-CN (简体中文)、zh-TW (繁体中文)。例如，配置为简体中文：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">language</span><span class="token punctuation">:</span> zh<span class="token punctuation">-</span>CN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="本地启动"><a class="headerlink" href="#本地启动"></a>本地启动</h3><p>在本地启动 Hexo 服务器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在浏览器地址栏输入</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">http://localhost:4000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://alist.lushiwu.top/d/OneDrive/Cloud/ada426fbfc38e208cb6b5a9bb3a08c15.png" alt="效果图" loading="lazy"></p><h2 id="一键部署到-GitHub-Pages"><a class="headerlink" href="#一键部署到-GitHub-Pages"></a>一键部署到 GitHub Pages</h2><h3 id="安装-hexo-deployer-git"><a class="headerlink" href="#安装-hexo-deployer-git"></a>安装 hexo-deployer-git</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置-config-yml"><a class="headerlink" href="#配置-config-yml"></a>配置 _config.yml</h3><p>在 <code>_config.yml</code> 中添加以下配置（如果配置已经存在，请将其替换为如下）:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/&lt;username<span class="token punctuation">></span>/&lt;project<span class="token punctuation">></span>  <span class="token comment"># example: https://github.com/hexojs/hexojs.github.io</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages <span class="token comment">#分支名称</span>  <span class="token comment"># message自定义提交信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="部署"><a class="headerlink" href="#部署"></a>部署</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean <span class="token operator">&amp;&amp;</span> hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览 &lt;GitHub 用户名&gt;.github.io 检查你的网站能否运作。<br><img src="https://i3.mjj.rip/2024/06/16/dccb8218ecd63ca2ee5f0d9d80587f10.png" alt="效果图" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
