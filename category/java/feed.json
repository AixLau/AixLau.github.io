{
    "version": "https://jsonfeed.org/version/1",
    "title": "陆时忤的博客 • All posts by \"java\" category",
    "description": "要再见 不要再见",
    "home_page_url": "https://blog.aixcc.top",
    "items": [
        {
            "id": "https://blog.aixcc.top/2024/06/27/%E9%A1%B9%E7%9B%AE%E8%AE%B2%E8%A7%A3/",
            "url": "https://blog.aixcc.top/2024/06/27/%E9%A1%B9%E7%9B%AE%E8%AE%B2%E8%A7%A3/",
            "title": "项目讲解",
            "date_published": "2024-06-27T07:34:31.000Z",
            "content_html": "<h1 id=\"随便写写\"><a class=\"headerlink\" href=\"#随便写写\"></a>随便写写</h1>\n<h3 id=\"登录注册模块\"><a class=\"headerlink\" href=\"#登录注册模块\"></a>登录注册模块</h3>\n<ul>\n<li><strong>注册</strong>：使用阿里云的短信服务将后端生成的验证码通过阿里云短信服务发送到用户手机号，并将前端传来的注册信息封装成一个 vo 类，根据用户的手机号对用户表进行查询，如果发现这个手机号已经注册，则抛出一个异常，前端显示“手机号已注册”，否则将该用户信息存入用户表。</li>\n<li>登录：将前端传来的登录信息与数据库中的信息进行比对，如果该数据库中有该信息则返回根据用户信息生成的一个 token 值，前端可以根据该 tokne 获取到用户名进行显示。</li>\n</ul>\n<h3 id=\"前后端分离项目中跨域问题是如何解决的？\"><a class=\"headerlink\" href=\"#前后端分离项目中跨域问题是如何解决的？\"></a>前后端分离项目中跨域问题是如何解决的？</h3>\n<ol>\n<li><strong>注解</strong>：可以通过使用<code>@CrossOrigin</code>注解来解决跨域问题。</li>\n<li><strong>Nginx</strong>：使用 Nginx 反向代理配置添加CORS头来解决跨域问题。</li>\n<li><strong>网关</strong>：使用 GetWay 网关中配置CORS规则，允许跨域请求</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://blog.aixcc.top/2024/06/26/RabbitMQ%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/26/RabbitMQ%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "RabbitMQ应用与总结",
            "date_published": "2024-06-26T15:14:15.000Z",
            "content_html": "<h2 id=\"RabbitMQ常见面试题总结\"><a class=\"headerlink\" href=\"#RabbitMQ常见面试题总结\"></a>RabbitMQ常见面试题总结</h2>\n<h3 id=\"什么是-RabbitMQ？\"><a class=\"headerlink\" href=\"#什么是-RabbitMQ？\"></a>什么是 RabbitMQ？</h3>\n<p>RabbitMQ 是一个开源的消息代理软件，广泛用于消息队列中。它实现了高级消息队列协议（AMQP），支持多重消息模式，能够在分布式系统重提供可靠的消息传递。。RabbitMQ 用于不同系统或服务之间异步传递消息，从而解耦生产者和消费者，增强系统的可扩展性和容错能力。</p>\n<h3 id=\"RabbitMQ-的组件有哪些？\"><a class=\"headerlink\" href=\"#RabbitMQ-的组件有哪些？\"></a>RabbitMQ 的组件有哪些？</h3>\n<h4 id=\"1-Producer（生产者）\"><a class=\"headerlink\" href=\"#1-Producer（生产者）\"></a>1. Producer（生产者）</h4>\n<ul>\n<li>生产者是消息的发送方，它将消息发送到 RabbitMQ 交换器。</li>\n<li>生成者负责创建和发送消息，不直接与队列通信。</li>\n</ul>\n<h4 id=\"2-Exchange（交换器）\"><a class=\"headerlink\" href=\"#2-Exchange（交换器）\"></a>2. Exchange（交换器）</h4>\n<ul>\n<li>交换器接收来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。</li>\n<li>交换器有不同类型，主要包括：<code>direct</code>、<code>topic</code>、<code>fanout</code>和<code>headers</code>。</li>\n</ul>\n<h5 id=\"Exchange-类型\"><a class=\"headerlink\" href=\"#Exchange-类型\"></a>Exchange 类型</h5>\n<ul>\n<li><strong>Direct Exchange</strong>：根据消息的路由键完全匹配队列的绑定键进行路由。</li>\n<li><strong>Topic Exchange</strong>：根据消息的路由键模式（使用通配符）进行路由，适用于主题匹配的场景。</li>\n<li><strong>Fanout Exchange</strong>：将消息广播到所有与该交换器绑定的队列，不考虑路由键。</li>\n<li><strong>Headers Exchange</strong>：根据消息的头属性进行路由，相对较少使用。</li>\n</ul>\n<h4 id=\"3-Queue（队列）\"><a class=\"headerlink\" href=\"#3-Queue（队列）\"></a>3. Queue（队列）</h4>\n<ul>\n<li>队列是 RabbitMQ 存储消息的容器，消费者从队列中接收消息。</li>\n<li>队列按照先进先出的顺序存储消息，可以持久化、镜像等。</li>\n</ul>\n<h4 id=\"4-Bindng（绑定）\"><a class=\"headerlink\" href=\"#4-Bindng（绑定）\"></a>4. Bindng（绑定）</h4>\n<ul>\n<li>绑定是交换器与队列之间的连接，通过绑定将消息路由到特定的队列。</li>\n<li>绑定可以包含路由键和绑定参数，用于匹配消息的路由键。</li>\n</ul>\n<h4 id=\"5-Consumer（消费者）\"><a class=\"headerlink\" href=\"#5-Consumer（消费者）\"></a>5. Consumer（消费者）</h4>\n<ul>\n<li>\n<p>消费者是消息的接收方，它从 RabbitMQ 队列中接收和处理消息。</p>\n</li>\n<li>\n<p>消费者可以是主动拉取消息，也可以是被动推送消息。</p>\n</li>\n</ul>\n<h4 id=\"6-Connection（连接）和Channel（信道）\"><a class=\"headerlink\" href=\"#6-Connection（连接）和Channel（信道）\"></a>6. Connection（连接）和Channel（信道）</h4>\n<ul>\n<li>连接是应用程序与 RabbitMQ 之间的 TCP 连接。</li>\n<li>信道是建立在连接之上的虚拟连接，应用程序通过信道与 RabbitMQ 进行通信。信道是轻量级的，可以在一个连接上创建多个信道。</li>\n</ul>\n<h4 id=\"7-Virtual-Host（虚拟机）\"><a class=\"headerlink\" href=\"#7-Virtual-Host（虚拟机）\"></a>7. Virtual Host（虚拟机）</h4>\n<ul>\n<li>虚拟机用于隔离不同的应用，每个虚拟机都有自己的交换器、队列、绑定和权限。</li>\n</ul>\n<h4 id=\"8-Broker（代理服务器）\"><a class=\"headerlink\" href=\"#8-Broker（代理服务器）\"></a>8. Broker（代理服务器）</h4>\n<ul>\n<li>Broker 是 RabbitMQ 服务器实例，负责接收、存储和转发消息。</li>\n</ul>\n",
            "tags": [
                "Java",
                "总结",
                "RabbitMQ"
            ]
        },
        {
            "id": "https://blog.aixcc.top/2024/06/26/Redis%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/26/Redis%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "Redis应用与总结",
            "date_published": "2024-06-26T12:18:49.000Z",
            "content_html": "<h2 id=\"Redis-常见面试题总结\"><a class=\"headerlink\" href=\"#Redis-常见面试题总结\"></a>Redis 常见面试题总结</h2>\n<h3 id=\"Redis-为什么这么快？\"><a class=\"headerlink\" href=\"#Redis-为什么这么快？\"></a>Redis 为什么这么快？</h3>\n<ol>\n<li>\n<p>Redis 基于内存，内存的访问速度比磁盘块很多；</p>\n</li>\n<li>\n<p>Redis 主要是单线程事件循环和 IO 多路复用；</p>\n</li>\n<li>\n<p>Redis 内置了多重优化过后的数据类型、结构实现，性能非常高</p>\n</li>\n<li>\n<p>Redis 通信协议实现简单且解析高效。</p>\n<h4 id=\"为什么不直接使用-Redis-当主数据库呢？\"><a class=\"headerlink\" href=\"#为什么不直接使用-Redis-当主数据库呢？\"></a>为什么不直接使用 Redis 当主数据库呢？</h4>\n<p>主要是因为内存成本太高且 Redis 提供的数据持久化仍然会有数据丢失风险。</p>\n</li>\n</ol>\n<h3 id=\"为什么用-Redis？\"><a class=\"headerlink\" href=\"#为什么用-Redis？\"></a>为什么用 Redis？</h3>\n<ol>\n<li>\n<p>访问速度更快</p>\n</li>\n<li>\n<p>高并发</p>\n</li>\n<li>\n<p>功能全面</p>\n<p>Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景。</p>\n</li>\n</ol>\n<h3 id=\"Redis-除了做缓存，还能做什么？\"><a class=\"headerlink\" href=\"#Redis-除了做缓存，还能做什么？\"></a>Redis 除了做缓存，还能做什么？</h3>\n<ul>\n<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li>\n<li><strong>限流</strong>：一半通过 Redis 和 Lua 脚本的方式来实现限流。如果不想写 Lua 脚本的话，也可以直接利用 Redisson中的<code>RRateLimiter</code>来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>\n<li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。</li>\n<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li>\n<li><strong>分布式 Session</strong>：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li>\n</ul>\n<h3 id=\"Redis-常用的数据类型有哪些？\"><a class=\"headerlink\" href=\"#Redis-常用的数据类型有哪些？\"></a>Redis 常用的数据类型有哪些？</h3>\n<ul>\n<li><strong>5 种基本数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>\n<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）。</li>\n</ul>\n<h3 id=\"String-的应用场景有哪些？\"><a class=\"headerlink\" href=\"#String-的应用场景有哪些？\"></a>String 的应用场景有哪些？</h3>\n<p>String 是 Redis 中最简单同时也是最常用的一个数据类型。可以用来存储任何类型的数据。</p>\n<ul>\n<li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li>\n<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>\n<li>分布式锁（利用<code>SETNX key value</code>命令可以实现一个最简易的分布式锁）；</li>\n</ul>\n<h3 id=\"Redis-持久化机制\"><a class=\"headerlink\" href=\"#Redis-持久化机制\"></a>Redis 持久化机制</h3>\n<p>Redis提供了两种主要的持久化机制：RDB（Redis DataBase）快照和 AOF(Append Only File）日志。这两种机制各有特点，满足不同的持久化需求。</p>\n<ol>\n<li>\n<p><strong>RDB（Redis DataBase）快照</strong></p>\n<p>RDB 持久化是指在指定的时间间隔内将 Redis 的内存数据生成快照并保存到磁盘。它会创建一个二进制文件（通常是 dump.rdb），包含某个时间点上的数据。</p>\n<p>​\t<strong>优点：</strong></p>\n<p>​\tRDB 文件是一个紧凑的二进制文件，可以较快地进行备份和恢复。</p>\n<p>​\tRDB 文件保存时不会对 Redis 的性能产生显著的影响，适合用于大规模数据的冷备份。</p>\n<p>​\t<strong>缺点：</strong></p>\n<p>​\tRDB 快照是定期进行的，如果 Redis 意外宕机，可能会丢失最后一次快照之后的所有数据。</p>\n<p>​\tRDB 快照需要较长的时间进行，所以不适用于需要频繁备份的数据场景。</p>\n</li>\n<li>\n<p><strong>AOF（Append Only File）日志</strong></p>\n<p>AOF 持久化记录每个写操作到日志文件中（通常是 appendonly.aof），Redis 可以通过重新执行日志中的命令来恢复数据。AOF日志文件默认不定期压缩，以减小文件体积。</p>\n</li>\n</ol>\n<p>​\t\t<strong>优点：</strong></p>\n<p>​\t\tAOF可以提供更高的数据持久性，因为它记录每次写操作，数据丢失的窗口更小。</p>\n<p>​\t\tAOF 文件是可读的文本文件，便于分析和调试。</p>\n<p>​\t\t<strong>缺点：</strong></p>\n<p>​\t\tAOF 文件通常比 RDB 文件更大，恢复速度相对慢。</p>\n<p>​\t\tAOF在每次写操作时都会记录日志，可能会对 Redis 性能产生一定影响，特别是在写操作频繁的情况下。</p>\n<h4 id=\"混合持久化\"><a class=\"headerlink\" href=\"#混合持久化\"></a>混合持久化</h4>\n<p>Redis 4.0 引入了混合持久化（Hybid Persistence），结合了 RDB 和 AOF 的优点。在进行快照时，将当前的 RDB 快照和 AOF 日志混合存储，以提高数据恢复速度和性能。</p>\n<h3 id=\"缓存穿透\"><a class=\"headerlink\" href=\"#缓存穿透\"></a>缓存穿透</h3>\n<h4 id=\"什么是缓存穿透？\"><a class=\"headerlink\" href=\"#什么是缓存穿透？\"></a>什么是缓存穿透？</h4>\n<p>缓存穿透是指查询一个在缓存和数据库中都不存在的数据，每次请求都会穿透缓存直接查询数据库，可能导致数据库压力过大。</p>\n<h4 id=\"有哪些解决办法？\"><a class=\"headerlink\" href=\"#有哪些解决办法？\"></a>有哪些解决办法？</h4>\n<p>最基本的就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p>\n<p>比如查询数据库 id 不能小于 0、传入邮箱格式不对的时候直接返回错误信息给客户端等等。</p>\n<h5 id=\"1-使用缓存空值\"><a class=\"headerlink\" href=\"#1-使用缓存空值\"></a>1. 使用缓存空值</h5>\n<p>将查询结果为空的数据也缓存起来，但要设置一个较短的过期时间，防止缓存中大量的空值数据占用内存。</p>\n<h5 id=\"2-布隆过滤器\"><a class=\"headerlink\" href=\"#2-布隆过滤器\"></a>2. 布隆过滤器</h5>\n<p>布隆过滤器是一种概率型数据结构，可以用来判断一个元素是否在一个集合中。将所有可能存在查询条件都存入布隆过滤器，在查询缓存和数据库之前先通过布隆过滤器进行判断，如果布隆过滤器判断该元素不存在，则直接返回。</p>\n<h5 id=\"3-接口限流\"><a class=\"headerlink\" href=\"#3-接口限流\"></a>3. 接口限流</h5>\n<p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采用黑名单机制，例如将异常 IP 列入黑名单。</p>\n<h3 id=\"缓存击穿\"><a class=\"headerlink\" href=\"#缓存击穿\"></a>缓存击穿</h3>\n<h4 id=\"什么是缓存击穿？\"><a class=\"headerlink\" href=\"#什么是缓存击穿？\"></a>什么是缓存击穿？</h4>\n<p>缓存击穿是指某些缓存中的热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到了数据库，对数据库造成了巨大的压力，通常发生在缓存中存放的热门数据突然过期的情况下。</p>\n<h4 id=\"有哪些解决方法？\"><a class=\"headerlink\" href=\"#有哪些解决方法？\"></a>有哪些解决方法？</h4>\n<h5 id=\"1-永不过期\"><a class=\"headerlink\" href=\"#1-永不过期\"></a>1. 永不过期</h5>\n<p>将热点数据设置为永不过期，防止其被清除出缓存，从而避免缓存失效带来的问题。</p>\n<h5 id=\"2-提前预热\"><a class=\"headerlink\" href=\"#2-提前预热\"></a>2.提前预热</h5>\n<p>在系统启动或业务高峰期来临之前，提前将热点数据加载到缓存中，避免缓存过期。</p>\n<h5 id=\"3-加锁\"><a class=\"headerlink\" href=\"#3-加锁\"></a>3. 加锁</h5>\n<p>当缓存失效时，使用分布式锁来控制只有一个请求可以访问数据库并重建缓存，其余请求等待缓存重建完成后再访问缓存。</p>\n<h4 id=\"缓存穿透和缓存击穿有什么区别？\"><a class=\"headerlink\" href=\"#缓存穿透和缓存击穿有什么区别？\"></a>缓存穿透和缓存击穿有什么区别？</h4>\n<ul>\n<li>\n<p>缓存穿透是查询一个在缓存和数据中都不存在的数据。</p>\n</li>\n<li>\n<p>缓存击穿是缓存中热点数据在缓存失效后，大量并发请求同时到达缓存并穿透到数据库。</p>\n</li>\n</ul>\n<h3 id=\"缓存雪崩\"><a class=\"headerlink\" href=\"#缓存雪崩\"></a>缓存雪崩</h3>\n<h4 id=\"什么是缓存雪崩？\"><a class=\"headerlink\" href=\"#什么是缓存雪崩？\"></a>什么是缓存雪崩？</h4>\n<p>缓存雪崩是指缓存中大量数据在同一时间过期或者缓存服务器宕机了，导致大量请求直接访问数据库，与缓存击穿不同的是，缓存雪崩涉及大量缓存同时失效或缓存服务不可用。</p>\n<h4 id=\"有哪些解决方法？-2\"><a class=\"headerlink\" href=\"#有哪些解决方法？-2\"></a>有哪些解决方法？</h4>\n<h5 id=\"针对Redis-服务不可用的情况：\"><a class=\"headerlink\" href=\"#针对Redis-服务不可用的情况：\"></a>针对Redis 服务不可用的情况：</h5>\n<ol>\n<li><strong>Redis 集群</strong>：采用 Redis 集群，避免单机出现问题整个缓存服务器都无法使用。</li>\n<li><strong>多级缓存</strong>：通过构建多级缓存（如本地缓存和分布式缓存），在缓存失效时优先从本地缓存读取数据，减轻数据库压力。</li>\n</ol>\n<h5 id=\"针对大量缓存同时失效的情况\"><a class=\"headerlink\" href=\"#针对大量缓存同时失效的情况\"></a>针对大量缓存同时失效的情况:</h5>\n<ol>\n<li><strong>过期时间随机化</strong>：避免大量缓存在同一时间失效，可以设置缓存数据过期时间增加一个随机值，使缓存数据的过期时间分散。</li>\n<li><strong>缓存预热</strong>：在系统启动或流量高峰前，提前将热点数据加载到缓存中，避免缓存雪崩。</li>\n<li><strong>主动更新</strong>：对于经常更新的热点数据，可以在其过期之前主动更新缓存，确保缓存中的数据始终有效。</li>\n</ol>\n<h3 id=\"如何保证缓存和数据库数据一致性？\"><a class=\"headerlink\" href=\"#如何保证缓存和数据库数据一致性？\"></a>如何保证缓存和数据库数据一致性？</h3>\n<h4 id=\"1-Cache-Aside-Pattern（旁路缓存模式）\"><a class=\"headerlink\" href=\"#1-Cache-Aside-Pattern（旁路缓存模式）\"></a>1. Cache Aside Pattern（旁路缓存模式）</h4>\n<p>当需要读取数据时，先从缓存读取，若缓存未命中，再从数据库读取，并将数据写入缓存。当数据更新时，先更新数据库，然后使缓存失效。</p>\n<h4 id=\"2-Write-Through-Cache（写直达缓存）\"><a class=\"headerlink\" href=\"#2-Write-Through-Cache（写直达缓存）\"></a>2. Write Through Cache（写直达缓存）</h4>\n<p>所有的数据更新操作都会先写入缓存，再写入数据库，这样可以确保缓存和数据库的一致性，但写操作的性能会受到一定影响。</p>\n<h4 id=\"3-Write-Behind-Cache（异步写缓存）\"><a class=\"headerlink\" href=\"#3-Write-Behind-Cache（异步写缓存）\"></a>3. Write Behind Cache（异步写缓存）</h4>\n<p>写操作会先写入缓存，并在后台异步更新数据库。这种方式可以提高操作的性能，但实现和维护比较复杂。</p>\n<h4 id=\"4-Cache-and-Database-Double-Write（双写一致性）\"><a class=\"headerlink\" href=\"#4-Cache-and-Database-Double-Write（双写一致性）\"></a>4. Cache and Database Double Write（双写一致性）</h4>\n<p>确保每次写操作，同时更新缓存和数据库。需要通过合适的事务机制或分布式锁来保证这两个操作的原子性。</p>\n<h4 id=\"5-使用消息队列实现最终一致性\"><a class=\"headerlink\" href=\"#5-使用消息队列实现最终一致性\"></a>5. 使用消息队列实现最终一致性</h4>\n<p>写操作更新数据库后，将更新时间发送到消息队列，消费者接收消息后更新缓存，实现最终一致性。</p>\n<h4 id=\"总结\"><a class=\"headerlink\" href=\"#总结\"></a>总结</h4>\n<ul>\n<li><strong>Cache Aside Pattern（旁路缓存模式）</strong>：读操作先查缓存，缓存未命中再查数据库，写操作先更新数据库，再使缓存失效。</li>\n<li><strong>Write Through Cache（写直达缓存）</strong>：写操作先更新缓存，再同步更新数据库。</li>\n<li><strong>Write Behind Cache（异步写缓存）</strong>：写操作先更新缓存，再异步批量更新数据库。</li>\n<li><strong>双写一致性（Cache and Database Double Write）</strong>：写操作时同时更新缓存和数据库，确保原子性。</li>\n<li><strong>使用消息队列实现最终一致性</strong>：更新数据库后发送消息队列，消费者接收消息后更新缓存，实现最终一致性。</li>\n</ul>\n",
            "tags": [
                "总结",
                "Redis"
            ]
        },
        {
            "id": "https://blog.aixcc.top/2024/06/26/MyBatis%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/26/MyBatis%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "MyBatis应用与总结",
            "date_published": "2024-06-26T09:53:37.000Z",
            "content_html": "<h1 id=\"MyBatis常见面试题总结\"><a class=\"headerlink\" href=\"#MyBatis常见面试题总结\"></a>MyBatis常见面试题总结</h1>\n<h3 id=\"和-的区别是什么？\"><a class=\"headerlink\" href=\"#和-的区别是什么？\"></a>#{} 和 ${} 的区别是什么？</h3>\n<ul>\n<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 slq 内部，属于原样文本替换，可以替换任意内容。</li>\n<li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中<code>#&#123;&#125;</code>替换为？号，在 sql 执行前会使用PreparedStatement 的参数设置方法，按序给 sql 的 ？号占位符设置参数值。使用<code>#&#123;&#125;</code>可以有效防止 sql 注入。</li>\n</ul>\n",
            "tags": [
                "Java",
                "MyBatis",
                "总结"
            ]
        },
        {
            "id": "https://blog.aixcc.top/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/22/Spring%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "Spring应用与总结",
            "date_published": "2024-06-22T10:11:04.000Z",
            "content_html": "<h2 id=\"Spring-常见面试题总结\"><a class=\"headerlink\" href=\"#Spring-常见面试题总结\"></a>Spring 常见面试题总结</h2>\n<h3 id=\"什么是Spring框架？\"><a class=\"headerlink\" href=\"#什么是Spring框架？\"></a>什么是Spring框架？</h3>\n<p>Spring 是一款开源的轻量级Java开发框架，提高开发人员的开发效率以及系统的维护性。</p>\n<h3 id=\"谈谈自己对于Spring-IoC的了解\"><a class=\"headerlink\" href=\"#谈谈自己对于Spring-IoC的了解\"></a>谈谈自己对于Spring IoC的了解</h3>\n<p><strong>IoC</strong> （Inversion of Control 控制反转）是一种设计模式，用来实现对象之间的解耦。</p>\n<p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。</p>\n<h4 id=\"为什么叫控制反转？\"><a class=\"headerlink\" href=\"#为什么叫控制反转？\"></a>为什么叫控制反转？</h4>\n<ul>\n<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权利</li>\n<li><strong>反转</strong>：控制权交给外部环境（Spring框架、IoC容器）</li>\n</ul>\n<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。</p>\n<h3 id=\"什么是-Bean？\"><a class=\"headerlink\" href=\"#什么是-Bean？\"></a>什么是 Bean？</h3>\n<p>Bean 就是哪些被 IoC 容器所管理的对象。</p>\n<h3 id=\"Component和-Bean的区别是什么？\"><a class=\"headerlink\" href=\"#Component和-Bean的区别是什么？\"></a>@Component和@Bean的区别是什么？</h3>\n<ul>\n<li>@Component 注解用于类，@Bean 注解用于方法。</li>\n<li>@Component 是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 IoC 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我需要的时候给我。</li>\n<li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方只能通过 @Bean 注解来实现。比如当我们引用第三方库中的类需要装配到 Spring 容器时，就只能通过 @Bean 来实现。</li>\n</ul>\n<h3 id=\"注入Bean的注解有哪些？\"><a class=\"headerlink\" href=\"#注入Bean的注解有哪些？\"></a>注入Bean的注解有哪些？</h3>\n<p>Spring 内置的<code>@Autowired</code> 还有 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>\n<h3 id=\"Autowired和-Resource的区别是什么？\"><a class=\"headerlink\" href=\"#Autowired和-Resource的区别是什么？\"></a>@Autowired和@Resource的区别是什么？</h3>\n<ul>\n<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>\n<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>\n<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code> 都需要通过名称才能正确匹配到对应的  Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code> 可以通过 name 属性来显式指定名称。</li>\n<li>@Autowired 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li>\n</ul>\n<h3 id=\"Bean-的作用域有哪些\"><a class=\"headerlink\" href=\"#Bean-的作用域有哪些\"></a>Bean 的作用域有哪些?</h3>\n<ul>\n<li><strong>Singleton</strong> Srping 中的bean 默认都是单例的，在整个 IoC 容器中只创建一个 bean 实例，无论多少次请求该bean 都返回同一个实例。</li>\n<li><strong>prototype</strong>  每次请求都会创建一个新的 bean 实例。</li>\n<li><strong>Request</strong> 每次 Http 请求都会创建一个新的 bean 实例。</li>\n<li><strong>Session</strong> 每个 Http Session 中会有一个 bean 实例。</li>\n</ul>\n<h3 id=\"Bean-是线程安全的吗？\"><a class=\"headerlink\" href=\"#Bean-是线程安全的吗？\"></a>Bean 是线程安全的吗？</h3>\n<p>在 Spring 中 Bean 是否安全，取决于其作用域和状态。</p>\n<p>单例 Bean 在 IoC 中只创建一个实例，这个实例会被多个线程共享。所以单例 Bean 不是线程安全的，如果考虑线程安全问题，可以使用同步（synchronization）或者无状态（stateless）设计。原型 Bean 因为每次请求都会创建新的实例，所以原型作用域的 Bean 是线程安全的。</p>\n<h3 id=\"Bean的生命周期了解么？\"><a class=\"headerlink\" href=\"#Bean的生命周期了解么？\"></a>Bean的生命周期了解么？</h3>\n<p>bean 的生命周期分为五个阶段：</p>\n<ol>\n<li>调用构造器或者是通过工厂的方式创建 bean</li>\n<li>给 bean 的属性注入值</li>\n<li>调用初始化方法，进行初始化</li>\n<li>bean 被完全初始化和配置，就可以使用了</li>\n<li>当 IOC 容器关闭的时候，销毁 bean</li>\n</ol>\n<h3 id=\"谈谈对于AOP的了解\"><a class=\"headerlink\" href=\"#谈谈对于AOP的了解\"></a>谈谈对于AOP的了解</h3>\n<p>AOP（面向切面编程）将与业务无关但在多个模块中重复出现的通用逻辑（如事务管理、日志管理、权限控制等）从业务逻辑中分离出来。通过将这些横切关注点封装到独立的模块中，从而减少系统的重复代码，降低模块之间的耦合度，并提高系统的扩展性和可维护性。</p>\n<p>Spring AOP 是通过动态代理来实现切面功能，<strong>JDK动态代理</strong>：用于代理实现了接口的类。<strong>CGLIB代理</strong>：用于代理没有实现接口的类，通过生成目标类的子类来实现。</p>\n<h3 id=\"Spring-AOP-和-AspectJ-AOP-有什么区别？\"><a class=\"headerlink\" href=\"#Spring-AOP-和-AspectJ-AOP-有什么区别？\"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3>\n<p>Spring AOP 和 AspectJ AOP 的主要区别在于实现机制、功能范围和性能。Spring AOP 基于动态代理实现，主要适用于方法级别的拦截，配置简单，适合大多数常用的 AOP 场景。AspectJ AOP 则基于编译时和类加载时织入，支持更广泛的连接点(如构造函数、字段等)，功能更强大，但配置和使用相对复杂，性能也更高，适用于需要精细控制和高性能场景。</p>\n<h3 id=\"AspectJ-定义的通知类型有哪些？\"><a class=\"headerlink\" href=\"#AspectJ-定义的通知类型有哪些？\"></a>AspectJ 定义的通知类型有哪些？</h3>\n<ul>\n<li>\n<p><strong>Before</strong>（前置通知）：在方法执行之前运行。</p>\n</li>\n<li>\n<p><strong>After</strong>（后置通知）：在方法执行之后运行，无论方法是否成功完成。</p>\n</li>\n<li>\n<p><strong>AfterReturning</strong>（返回通知）：在方法成功完成后运行。</p>\n</li>\n<li>\n<p><strong>AfterThorowing</strong>（异常通知）：在方法抛出异常后运行。</p>\n</li>\n<li>\n<p><strong>Around</strong>（环绕通知）：既可以在方法执行之前运行，也可以在方法执行之后运行。</p>\n</li>\n</ul>\n<h3 id=\"多个切面执行顺序如何控制？\"><a class=\"headerlink\" href=\"#多个切面执行顺序如何控制？\"></a>多个切面执行顺序如何控制？</h3>\n<ol>\n<li>通常使用<code>@Order</code> 注解直接定义切面顺序</li>\n<li>实现<code>Ordered</code>接口重写<code>getOrder</code>方法</li>\n</ol>\n<h3 id=\"说说自己对于-Spring-MVC-了解？\"><a class=\"headerlink\" href=\"#说说自己对于-Spring-MVC-了解？\"></a>说说自己对于 Spring MVC 了解？</h3>\n<p>SpringMVC是一个基于Java的实现了MVC设计模式的轻量级Web框架。它通过分离应用程序的业务逻辑、用户界面和控制流程，简化了Web应用程序的开发和维护。</p>\n<h3 id=\"SpringMVC-的工作流程是什么？\"><a class=\"headerlink\" href=\"#SpringMVC-的工作流程是什么？\"></a>SpringMVC 的工作流程是什么？</h3>\n<ol>\n<li>客户端请求首先到达<code>DispatcherServlet</code>。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerMapping</code>找到具体的处理器（Controller）。</li>\n<li><code>DispatcherServlet</code>通过<code>HandlerAdapter</code>调用处理器中的具体方法。</li>\n<li>处理器方法执行完毕后返回<code>ModelAndView</code>对象，包含视图名称和模型数据。</li>\n<li><code>DispatcherServlet</code>使用<code>ViewResolver</code>将视图名称解析为具体的视图。</li>\n<li>最后，<code>DispatcherServlet</code>将模型数据传递给视图，视图渲染并返回响应给客户端。</li>\n</ol>\n<p>客户端发送请求 -&gt; 2. DispatcherServlet接收请求 -&gt; 3. HandlerMapping查找控制器 -&gt; 4. HandlerAdapter调用控制器方法 -&gt; 5. Controller处理请求 -&gt; 6. ViewResolver解析视图 -&gt; 7. 视图渲染 -&gt; 8. 返回响应给客户端</p>\n<h3 id=\"统一异常处理怎么做？\"><a class=\"headerlink\" href=\"#统一异常处理怎么做？\"></a>统一异常处理怎么做？</h3>\n<p>使用注解的方式统一异常处理，使用<code>@controllerAdvice</code>和<code>@ExceptionHandler</code>这两个注解。</p>\n<h3 id=\"Spring-中用到了哪些设计模式？\"><a class=\"headerlink\" href=\"#Spring-中用到了哪些设计模式？\"></a>Spring 中用到了哪些设计模式？</h3>\n<ul>\n<li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过<code>BeanFactory</code>、<code>ApplicationContext</code>创建 bean 对象。</li>\n<li><strong>代理设计模式</strong>：SpringAOP 功能实现。</li>\n<li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li>\n<li><strong>模版方法模式</strong>：Spring 中<code>jdbcTemplate</code>、<code>hibernateTemplate</code>等以 Template 结尾的对数据库操作的类，都使用到了模版模式。</li>\n<li><strong>包装器设计模式</strong>：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们刚开业根据客户的需求能够动态切换不同的数据。</li>\n<li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式。</li>\n<li><strong>适配器模式</strong>：Spring AOP 的增强或通知使用到了适配器模式、SpringMVC 中也用到了适配器模式适配<code>Controller</code>。</li>\n</ul>\n<h3 id=\"Spring-循环依赖了解吗，怎么解决？\"><a class=\"headerlink\" href=\"#Spring-循环依赖了解吗，怎么解决？\"></a>Spring 循环依赖了解吗，怎么解决？</h3>\n<p>Spring 中的循环依赖就是指两个及以上的 Bean互相依赖，形成一个循环。比如 BeanA 依赖于 BenaB，而 BeanB 又依赖 BeanA。这种情况可能导致 Spring 容器无法正确初始化这些 Bean。</p>\n<h4 id=\"使用-setter-注入\"><a class=\"headerlink\" href=\"#使用-setter-注入\"></a>使用 setter 注入</h4>\n<p>Spring 中可以通过 Setter 注入解决循环依赖问题，因为Spring 在注入 Bean 的属性时会先创建 Bean 的实例，然后再注入依赖的属性。这样可以保证即使两个 Bean 互相依赖，Spring 也能正确的初始化它们。</p>\n<h4 id=\"使用-Lazy-注解\"><a class=\"headerlink\" href=\"#使用-Lazy-注解\"></a>使用 @Lazy 注解</h4>\n<p>在其中一个 Bean 的依赖上使用<code>@Lazy</code>注解，这样 Spring 容器在首次访问该 Bean 时才会进行初始化，避免循环依赖问题。</p>\n<h3 id=\"Spring-管理事务的方式有几种？\"><a class=\"headerlink\" href=\"#Spring-管理事务的方式有几种？\"></a>Spring 管理事务的方式有几种？</h3>\n<ul>\n<li><strong>编程式事务</strong>：在代码中硬编码（在分布式系统中推荐使用）：通过<code>TranscationTemplate</code>或者<code>TransactionManager</code>在手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li>\n<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用）：实际时通过 AOP 实现（基于<code>@Transcational</code>的全注解方式使用最多）</li>\n</ul>\n<h3 id=\"Srping事务中哪几种事务传播行为？\"><a class=\"headerlink\" href=\"#Srping事务中哪几种事务传播行为？\"></a>Srping事务中哪几种事务传播行为？</h3>\n<blockquote>\n<p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p>\n<p>当事务方法被另一个事务方法调用时，必须制定事务应该如何传播。</p>\n<p>例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事物中运行。</p>\n</blockquote>\n<ol>\n<li><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事物。</li>\n</ol>\n<h3 id=\"什么是-SpringBoot？为什么要有-SpringBoot？\"><a class=\"headerlink\" href=\"#什么是-SpringBoot？为什么要有-SpringBoot？\"></a>什么是 SpringBoot？为什么要有 SpringBoot？</h3>\n<p>SpringBoot 可以简化 Spring 开发（减少配置文件、开箱即用 ）</p>\n<h3 id=\"如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"><a class=\"headerlink\" href=\"#如何在-SpringBoot-应用程序中使用-Jetty-而不是-Tomcat？\"></a>如何在 SpringBoot 应用程序中使用 Jetty 而不是 Tomcat？</h3>\n<p>SpringBoot（spirng-boot-starter-web）使用Tomcat 作为默认的嵌入式 servlet 容器，如果想使用 Jetty 的话，只需要修改 pom.xml （Maven）文件就可以了。</p>\n<h3 id=\"介绍一下-SpringBootApplication-注解\"><a class=\"headerlink\" href=\"#介绍一下-SpringBootApplication-注解\"></a>介绍一下 @SpringBootApplication 注解</h3>\n<p><code>@SpringBootApplication</code>可以看作是<code>@Configuration、@EnableAutoConfiguration、@ComponentScan</code>注解的集合。</p>\n<ul>\n<li><code>@Configuration</code>：运行在上下文中注册额外的<code>bean</code>或导入其他配置类</li>\n<li><code>@EnableAutoConfiguration</code>：启用 Springboot 的自动配置机制</li>\n<li><code>@ComponentScan</code>：扫描被<code>@Component</code>(<code>@Service</code>,<code>@Controller</code>)注解的 bean，默认会扫描该类所在的包下的所有的类。</li>\n</ul>\n<h3 id=\"SpringBoot-的自动配置是如何实现的？\"><a class=\"headerlink\" href=\"#SpringBoot-的自动配置是如何实现的？\"></a>SpringBoot 的自动配置是如何实现的？</h3>\n<p>当 SpringBoot 应用启动时，@EnableAutoConfiguration`注解会触发自动配置类的加载。</p>\n<p>SpringBoot 会扫描<code>spring.factories</code>文件，并加载列出自动配置类。然后 SpringBoot 会根据条件注解的判断，决定是否进行相应的配置。</p>\n<h3 id=\"SpringBoot-常用的两种配置文件\"><a class=\"headerlink\" href=\"#SpringBoot-常用的两种配置文件\"></a>SpringBoot 常用的两种配置文件</h3>\n<p>我们可以通过<code>applcation.properties</code>或者<code>application.yml</code>对SpringBoot 程序进行简单的配置。如果不进行配置的话，就是使用默认配置。</p>\n<h3 id=\"什么是-YAML-YAML配置的优势在哪里？\"><a class=\"headerlink\" href=\"#什么是-YAML-YAML配置的优势在哪里？\"></a>什么是 YAML ? YAML配置的优势在哪里？</h3>\n<p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的树形，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>\n<p>相比 Properties 配置文件，YAML 配置方式更加直观清晰，简洁明了，有层次感。</p>\n<p>但是 YAML 配置文件不支持<code>@PropertySource</code> 注解导入自定义的 YAML 配置。</p>\n<h3 id=\"SpringBoot-常用的读取配置文件的方法有哪些？\"><a class=\"headerlink\" href=\"#SpringBoot-常用的读取配置文件的方法有哪些？\"></a>SpringBoot 常用的读取配置文件的方法有哪些？</h3>\n<ol>\n<li>\n<p>通过<code>@Value(&quot;$&#123;property&#125;&quot;)</code>读取比较简单的配置信息</p>\n<blockquote>\n<p><code>@value</code> 这种方式是不被推荐的</p>\n</blockquote>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperties</code>读取并与 bean 绑定</p>\n</li>\n<li>\n<p>通过<code>@ConfigurationProperies</code>读取并校验</p>\n</li>\n<li>\n<p>通过<code>@PropertySource</code>读取指定的 properties 文件</p>\n</li>\n</ol>\n<h3 id=\"SpringBoot-如何做请求参数校验？\"><a class=\"headerlink\" href=\"#SpringBoot-如何做请求参数校验？\"></a>SpringBoot 如何做请求参数校验？</h3>\n<p>使用 JSR 提供的校验注解</p>\n<h3 id=\"SpringBoot-如何监控系统运行状态？\"><a class=\"headerlink\" href=\"#SpringBoot-如何监控系统运行状态？\"></a>SpringBoot 如何监控系统运行状态？</h3>\n<p>可以使用 SpringBoot Actuator 来对 SpringBoot 项目进行简单的监控。</p>\n<h3 id=\"SpringBoot-中如何实现定时任务？\"><a class=\"headerlink\" href=\"#SpringBoot-中如何实现定时任务？\"></a>SpringBoot 中如何实现定时任务？</h3>\n<p>我们使用<code>@Scheduled</code>注解就能很方便地创建一个定时任务。</p>\n<p>还需要再 SpringBoot 启动类上添加<code>@EnableScheduling</code>注解，这个注解的作用是发现<code>@Scheduled</code>的任务并在后台执行该任务。</p>\n",
            "tags": [
                "Java",
                "总结",
                "Spring"
            ]
        },
        {
            "id": "https://blog.aixcc.top/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/",
            "url": "https://blog.aixcc.top/2024/06/21/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/",
            "title": "Java基础总结",
            "date_published": "2024-06-21T12:41:04.000Z",
            "content_html": "<h4 id=\"对象相等和引用相等的区别\"><a class=\"headerlink\" href=\"#对象相等和引用相等的区别\"></a>对象相等和引用相等的区别</h4>\n<ul>\n<li><strong>对象相等</strong>：比较的是内存中存放的内容是否相等。</li>\n<li><strong>引用相等</strong>：比较的是它们指向的内存地址是否相等。</li>\n</ul>\n<h4 id=\"如果一个类没有声明构造方法，该程序能正确执行吗？\"><a class=\"headerlink\" href=\"#如果一个类没有声明构造方法，该程序能正确执行吗？\"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h4>\n<ul>\n<li>如果一个类没有声明构造方法也可以执行，因为一个类没有声明构造方法也会有一个默认的不带参数的构造方法。</li>\n<li>如果添加了类的构造方法，无论是否有参，<code>Java</code>都不会添加默认不带参数的构造方法。</li>\n</ul>\n<h4 id=\"构造方法有哪些特点？是否可被重写？\"><a class=\"headerlink\" href=\"#构造方法有哪些特点？是否可被重写？\"></a>构造方法有哪些特点？是否可被重写？</h4>\n<ul>\n<li><strong>构造方法的特点</strong>：\n<ul>\n<li>名字与类名相同。</li>\n<li>没有返回值。</li>\n<li>生成类的对象时自动执行，无需调用。<br>\n构造方法不能被重写，但是可以被重载。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向对象的三大特征\"><a class=\"headerlink\" href=\"#面向对象的三大特征\"></a>面向对象的三大特征</h4>\n<ul>\n<li><strong>封装</strong>：封装是指将对象的状态（属性）和行为（方法）绑定在一起，并将其内部实现细节隐藏起来，只通过公开的接口与外界进行交互。封装的目的是保护对象的内部状态，防止外部直接访问和修改，从而提高代码的安全性和可维护性。</li>\n<li><strong>继承</strong>：继承是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码重用和逻辑扩展。通过继承，子类可以拥有父类的所有属性和方法，并可以对其进行扩展和修改。</li>\n<li><strong>多态</strong>：多态是指同一个方法在不同的对象中具有不同的实现，从而实现接口的统一调用。多态性使得同一个方法调用可以根据对象的实际类型执行不同的操作。多态可以通过方法重载（编译时多态）和方法重写（运行时多态）来实现。</li>\n</ul>\n<h4 id=\"接口和抽象类有什么共同点和区别？\"><a class=\"headerlink\" href=\"#接口和抽象类有什么共同点和区别？\"></a>接口和抽象类有什么共同点和区别？</h4>\n<ul>\n<li><strong>共同点</strong>：\n<ul>\n<li>都不能被实例化。</li>\n<li>都可以包含抽象方法。</li>\n<li>都可以有默认的实现方法。</li>\n</ul>\n</li>\n<li><strong>区别</strong>：\n<ul>\n<li>接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。</li>\n<li>抽象类主要用于代码的复用，强调所属关系。</li>\n<li>一个类只能继承一个类，但是可以实现多个接口。</li>\n<li>接口中的成员变量只能是静态常量，不能被修改且必须有初始值。</li>\n<li>抽象类的成员变量默认是包级私有的，可以在子类中被重新定义，也可以重新赋值。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"深拷贝和浅拷贝的区别？什么是引用拷贝？\"><a class=\"headerlink\" href=\"#深拷贝和浅拷贝的区别？什么是引用拷贝？\"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h4>\n<ul>\n<li><strong>浅拷贝</strong>：创建一个新对象，它只复制对象中的基本数据类型，而引用类型只是复制引用，指向的是原对象中的同一个对象。浅拷贝可以用<code>Object</code>的<code>clone()</code>方法来实现。浅拷贝修改新对象的引用类型字段时，原对象的对应字段也会被修改。</li>\n<li><strong>深拷贝</strong>：不仅复制对象本身，还递归复制所有引用的对象，独立于原对象。深拷贝可以通过手动复制对象以及所有的引用对象，也可以使用序列化和反序列化来实现。修改新对象的引用类型字段时，原对象不会受到影响。</li>\n<li><strong>引用拷贝</strong>：直接复制对象的引用，使两个对象引用指向同一个内存地址。修改一个对象的内容，另一个对象也会同步变化。</li>\n</ul>\n<h4 id=\"和-equals-的区别？\"><a class=\"headerlink\" href=\"#和-equals-的区别？\"></a>== 和 equals()的区别？</h4>\n<ul>\n<li>对于基本数据类型，<code>==</code> 比较的是值。</li>\n<li>对于引用数据类型，<code>==</code> 比较的是对象的内存地址。</li>\n<li><code>equals()</code>没有重写时，等价于<code>==</code>比较两个对象。</li>\n<li>被重写时，一般都重写<code>equals()</code>方法用来比较两个对象中的属性是否相等。</li>\n</ul>\n<h4 id=\"hashCode-有什么用？\"><a class=\"headerlink\" href=\"#hashCode-有什么用？\"></a>hashCode() 有什么用？</h4>\n<p><code>hashCode()</code>方法用于生成对象的哈希码，哈希码是一个整数，能够确定该对象在哈希表中的索引位置。</p>\n<h4 id=\"为什么重写-equals-时必须重写-hashCode-方法？\"><a class=\"headerlink\" href=\"#为什么重写-equals-时必须重写-hashCode-方法？\"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4>\n<h5 id=\"equals-和hashCode-的合同（约定）\"><a class=\"headerlink\" href=\"#equals-和hashCode-的合同（约定）\"></a><code>equals()</code>和<code>hashCode()</code>的合同（约定）</h5>\n<p>如果两个对象根据<code>equals()</code>方法是相等的，那么它们的<code>hashCode()</code>值必须相同。</p>\n<p>如果两个对象的<code>hashCode()</code>值相同，它们不一定是相等的（但它们有可能是相等的）。</p>\n<h4 id=\"String、StringBuffer、StringBuilder-的区别？\"><a class=\"headerlink\" href=\"#String、StringBuffer、StringBuilder-的区别？\"></a>String、StringBuffer、StringBuilder 的区别？</h4>\n<ul>\n<li><strong>String</strong>：不可变的，因为不可变，所以它是线程安全的。</li>\n<li><strong>StringBuffer</strong>：可变的，允许对字符串进行修改，线程安全，所有的方法都被<code>synchronized</code>修饰。</li>\n<li><strong>StringBuilder</strong>：可变的，但不是线程安全的，没有被<code>synchronized</code>修饰。由于没有同步机制，性能比<code>StringBuffer</code>更高，适合单线程环境下使用。</li>\n<li><strong>使用场景</strong>：\n<ul>\n<li>当字符串是固定不变的时候使用<code>String</code>。</li>\n<li>当需要对字符串进行大量修改且在多线程环境下使用<code>StringBuffer</code>。</li>\n<li>当需要对字符串进行大量修改且在单线程环境下使用<code>StringBuilder</code>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"字符串常量池的作用了解吗？\"><a class=\"headerlink\" href=\"#字符串常量池的作用了解吗？\"></a>字符串常量池的作用了解吗？</h4>\n<p>字符串常量池的主要作用是优化内存使用和提高性能。字符串常量池是一块专门用来存储字符串常量的区域，主要目的是为了避免字符串的重复创建。当多个字符串具有相同内容时，<code>JVM</code>会在常量池中共享相同的字符串实例，而不是为每个字符串创建新的对象。</p>\n<h4 id=\"Exception-和-Error-有什么区别？\"><a class=\"headerlink\" href=\"#Exception-和-Error-有什么区别？\"></a>Exception 和 Error 有什么区别？</h4>\n<ul>\n<li><strong>Exception</strong>和<strong>Error</strong>都是<strong>Throwable</strong>的子类。</li>\n<li><code>Exception</code>是程序本身可以处理的异常，可以通过<code>catch</code>来捕获。<code>Exception</code>还可以分为<code>checked Exception</code>和<code>Unchecked Exception</code>。</li>\n<li><code>Error</code>是程序无法处理的异常。通常是JVM无法处理的系统级错误，例如内存不足、栈溢出。</li>\n</ul>\n<h4 id=\"Checked-Exception-和-Unchecked-Exception-有什么区别？\"><a class=\"headerlink\" href=\"#Checked-Exception-和-Unchecked-Exception-有什么区别？\"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4>\n<ul>\n<li><strong>Checked Exception</strong>必须被捕获或声明，否则编译器会报错。</li>\n<li><strong>Unchecked Exception</strong>也叫运行时异常，不强制要求处理，但最好捕获处理。</li>\n</ul>\n<h4 id=\"什么是泛型？有什么作用？\"><a class=\"headerlink\" href=\"#什么是泛型？有什么作用？\"></a>什么是泛型？有什么作用？</h4>\n<p>泛型是JDK5中引入的新特性，在编写类、接口和方法时可以使用类型参数，然后在使用时指定具体的类型。泛型允许在编译时检查类型，避免了运行时的类型错误。例如，创建一个List<String>(List集合指定了String类型参数)时，你就知道这个列表只能包含字符串。泛型消除强制类型转换，从集合中取出元素时不需要进行转换。Java编译器在编译时会移除所有的泛型类型信息</p>\n<h4 id=\"反射是什么？\"><a class=\"headerlink\" href=\"#反射是什么？\"></a>反射是什么？</h4>\n<p>反射是<code>Java</code>中的一种机制，允许程序在运行时获取有关自身的信息。并能动态地调用对象的方法、访问属性和创建对象实例。反射提供了动态操作类和对象的能力，是实现框架、工具和动态代理等技术的基础。</p>\n<h4 id=\"反射的优缺点？\"><a class=\"headerlink\" href=\"#反射的优缺点？\"></a>反射的优缺点？</h4>\n<ul>\n<li><strong>反射的优点</strong>：\n<ul>\n<li>动态性和灵活性：反射允许我们在运行时加载和实例化类、调用方法和访问字段，让我们可以编写更通用和灵活的代码，特别是在插件系统或依赖注入框架中。</li>\n<li>很多流行的<code>Java</code>框架如<code>Spring</code>都依赖反射来实现动态代理、依赖注入。</li>\n</ul>\n</li>\n<li><strong>反射的缺点</strong>：\n<ul>\n<li>反射操作通常比直接调用方法或访问字段要慢，频繁使用反射可能会影响性能。</li>\n<li>反射可以绕过Java的访问控制机制，可能破坏类的封装性和安全性。</li>\n<li>使用反射的代码通常更复杂，反射相关的错误可能难以发现和修复。</li>\n<li>反射跳过了编译时的类型检查，许多问题只能在运行时发现，增加了出错风险。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"何谓注解？\"><a class=\"headerlink\" href=\"#何谓注解？\"></a>何谓注解？</h4>\n<p>注解是<code>Java</code>中的一种元数据，用来提供代码的额外信息。注解不会直接影响代码的执行，但可以被编译器和运行环境使用，以进行编译检查、生成代码、动态处理等。注解使用@符号来声明，可以用于编译时的代码检查，例如<code>@Override</code>注解可以确保方法重写。注解可以与工具结合使用，在编译时生成额外的代码，某些注解可以在运行时通过反射机制读取和处理，用于配置和控制程序行为。</p>\n<h4 id=\"什么是序列化？什么是反序列化？\"><a class=\"headerlink\" href=\"#什么是序列化？什么是反序列化？\"></a>什么是序列化？什么是反序列化？</h4>\n<ul>\n<li><strong>序列化</strong>：将一个Java对象转换成字节流的过程，可以将该对象保存到文件、数据库或者通过网络传输。序列化的主要目的是为了持久化对象状态和在不同Java虚拟机之间传输对象。</li>\n<li><strong>反序列化</strong>：将字节流恢复为Java对象的过程。通过反序列化使其恢复到序列化之前的状态。</li>\n</ul>\n",
            "tags": [
                "Java",
                "笔记"
            ]
        }
    ]
}